<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo]]></title>
  <subtitle><![CDATA[我的<a href="https://github.com/bluestein">GitHub</a>]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2016-03-29T13:12:40.183Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LPS: Longest Palindromic Substring(最长回文子串)]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-LPS/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-LPS/</id>
    <published>2016-03-29T12:04:32.000Z</published>
    <updated>2016-03-29T13:12:40.183Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>回文字符串的意思是指一个字符串，从头开始读和从尾开始读都是一样。例如，aba 是一个回文字符串，而 abc 不是。其中，单个字符也是回文字符串。</p>
<p>最长回文子串指在一个字符串中找到最长的那个回文字符串（可以假设该字符串只有一个最长字符串）。例如，</p>
<p>s = “caba”</p>
<p>最长的回文子串是 aba。</p>
<a id="more"></a>
<h2 id="Brute_force_solution,_O(n^3)">Brute force solution, O(n^3)</h2><p>暴力法就是取出所有可能的子字符串，然后验证它是否为回文字符串，最后得到最长的回文子串。</p>
<p>总共有 C(n, 2) 种子字符串（不包括单个字符的情况），因为验证每个子字符串的需要 O(n) 时间，故总共需要 O(n^3)。</p>
<h2 id="Dynamic_programming_solution,_O(n^2)">Dynamic programming solution, O(n^2)</h2><p>为了改善暴力法的时间复杂度，首先需要避免重复计算的问题。比如，ababa，当我们知道 bab 是回文字符串时，很明显就可以看出 ababa 是回文字符串，因为 bab 的左边和右边的字符是相同的，都为 a。</p>
<p>更一般的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设 <span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← true  当且仅当 si...sj（字符串 s 下标从 <span class="tag">i</span> 到 j 的子串）是回文字符串</span><br><span class="line">否则 <span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← false</span><br></pre></td></tr></table></figure>
<p>即有</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← ( <span class="function"><span class="title">P</span><span class="params">(i+<span class="number">1</span>, j-<span class="number">1</span>)</span></span> &amp;&amp; Si == Sj )</span><br></pre></td></tr></table></figure>
<p>综合起来就是</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">            true                             ,i = j</span></span><br><span class="line">P[<span class="link_label">i</span>][<span class="link_reference">j</span>] = &#123; s[i] = s[j]                      ,j = i + 1</span><br><span class="line"><span class="code">            s[i] = s[j] and P(i + 1, j - 1)  ,j &gt; i + 1</span></span><br></pre></td></tr></table></figure>
<p>于是有如下 O(n^2) time, O(n^2) space 的解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_DP</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">bool</span> *P = <span class="keyword">new</span> <span class="keyword">bool</span>[n * n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// vector&lt;vector&lt;bool&gt;&gt; P(n, vector&lt;bool&gt;(n, false)); // time exceeded</span></span><br><span class="line">	<span class="keyword">int</span> max_len = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P[i * n + i] = <span class="literal">true</span>; <span class="comment">// P[i][i]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// P[j][i] = (s[j] == s[i] &amp;&amp; (i - j &lt; 2 || P[j + 1][i - 1]));</span></span><br><span class="line">			P[j * n + i] = (s[j] == s[i] &amp;&amp; (i - j &lt; <span class="number">2</span> || P[(j + <span class="number">1</span>) * n + i - <span class="number">1</span>]));</span><br><span class="line">			<span class="keyword">if</span> (P[j * n + i] &amp;&amp; max_len &lt; (i - j + <span class="number">1</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				max_len = i - j + <span class="number">1</span>;</span><br><span class="line">				start = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] P;</span><br><span class="line">	P = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法需要 O(n^2) 的空间和时间复杂度，可作如下改进，得到  O(n^2) time, O(1) space 的解法：</p>
<p>通过观察可以发现，回文字符串是中心对称的。所以一个会文字符串可以从它的中心开始展开，并且一共有 2n - 1 个这样的中心。</p>
<p>为什么有 2n - 1 个中心？是因为回文的中心可以在两个字符之间，如，abba 的中心在两个 b 之间。</p>
<p>因为从中心展开一个回文字符串需要 O(n) 时间复杂度，故总的时间复杂度为 O(n^2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expandCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n - <span class="number">1</span> &amp;&amp; s[l] == s[r])</span><br><span class="line">	&#123;</span><br><span class="line">		l--;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_DP</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">string</span>();  </span><br><span class="line">    <span class="comment">// single char itself is a palindrome</span></span><br><span class="line">	<span class="built_in">string</span> longest = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> s1 = expandCenter(s, i, i);</span><br><span class="line">		<span class="built_in">string</span> s2 = expandCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (s1.size() &gt; longest.size()) longest = s1;</span><br><span class="line">		<span class="keyword">if</span> (s2.size() &gt; longest.size()) longest = s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher’s_algorithm">Manacher’s algorithm</h2><p>该算法只需要 O(n) 时间复杂度。</p>
<p>分析内容待续（自己都还没理解透彻。。）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform S into T.</span></span><br><span class="line"><span class="comment">// For example, S = "abba", T = "^#a#b#b#a#$".</span></span><br><span class="line"><span class="comment">// ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">	<span class="built_in">string</span> ans = <span class="string">"^"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += <span class="string">"#"</span> + s.substr(i, <span class="number">1</span>);</span><br><span class="line">	ans += <span class="string">"#$"</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manacher's Algorithm, O(n) time, O(n) space</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_Manachers</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> T = preProcess(s);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = T.size();</span><br><span class="line">	<span class="keyword">int</span> *P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;  <span class="comment">// equals to i' = C - (i - C)</span></span><br><span class="line">		P[i] = (R &gt; i) ? min(R - i, P[i_mirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Attempt to expand palindrome centered at i</span></span><br><span class="line">		<span class="keyword">while</span> (T[i + <span class="number">1</span> + P[i]] == T[i - <span class="number">1</span> - P[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			P[i]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If palindrome centered at i expand past R,</span></span><br><span class="line">		<span class="comment">// adjust center based on expanded palindrome</span></span><br><span class="line">		<span class="keyword">if</span> (i + P[i] &gt; R)</span><br><span class="line">		&#123;</span><br><span class="line">			C = i;</span><br><span class="line">			R = i + P[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the maximun element in P</span></span><br><span class="line">	<span class="keyword">int</span> max_len = <span class="number">0</span>, center_index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (P[i] &gt; max_len)</span><br><span class="line">		&#123;</span><br><span class="line">			max_len = P[i];</span><br><span class="line">			center_index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] P;</span><br><span class="line">	P = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s.substr((center_index - <span class="number">1</span> - max_len) / <span class="number">2</span>, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference：</p>
<ol>
<li><a href="http://articles.leetcode.com/longest-palindromic-substring-part-i/" target="_blank" rel="external">longest palindromic substring part I</a></li>
<li><a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="external">longest palindromic substring part II</a></li>
</ol>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>回文字符串的意思是指一个字符串，从头开始读和从尾开始读都是一样。例如，aba 是一个回文字符串，而 abc 不是。其中，单个字符也是回文字符串。</p>
<p>最长回文子串指在一个字符串中找到最长的那个回文字符串（可以假设该字符串只有一个最长字符串）。例如，</p>
<p>s = “caba”</p>
<p>最长的回文子串是 aba。</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://bluestein.github.io/tags/DP/"/>
    
      <category term="LPS" scheme="http://bluestein.github.io/tags/LPS/"/>
    
      <category term="Manacher’s" scheme="http://bluestein.github.io/tags/Manacher%E2%80%99s/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCS: Longest Common Subsequence(最长公共子序列)]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-LCS/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-LCS/</id>
    <published>2016-03-25T14:30:32.000Z</published>
    <updated>2016-03-25T15:27:52.048Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="概念">概念</h2><h3 id="子序列">子序列</h3><p>设X = &lt; x1, x2,…, xm &gt;，若有1≤ i1 &lt; i2 &lt; … &lt; ik &le; m，使得 Z = &lt; z1, z2, …, zk&gt; = &lt; xi1, xi2, …, xik &gt;，则称Z 是X 的子序列， 记为Z &lt; X。<br>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Z = &lt; B,C,B,A &gt;,  则有Z &lt; X。</p>
<a id="more"></a> 
<h3 id="公共子序列">公共子序列</h3><p>设X，Y 是两个序列，且有Z &lt; X 和Z &lt; Y， 则称Z 是X 和Y 的公共子序列。 </p>
<h3 id="最长公共子序列的概念">最长公共子序列的概念</h3><p>若Z &lt; X，Z &lt; Y，且不存在比Z 更长的X 和Y 的公共子序列， 则称Z是X和Y 的最长公共子序列，记为Z &isin; LCS(X, Y)。</p>
<h3 id="最长公共子序列往往不止一个">最长公共子序列往往不止一个</h3><p>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Y = &lt; B,D,C,A,B,A &gt;.</p>
<p>则 Z = &lt; B,C,B,A &gt;,   Z’ = &lt; B,C,A,B &gt;,  Z’’ = &lt; B,D,A,B &gt; 均属于LCS(X, Y) ，即X,Y 有3 个LCS。</p>
<h2 id="算法">算法</h2><h3 id="Brute-force（暴力法）">Brute-force（暴力法）</h3><p>列出X 的所有长度不超过n （即|Y|）的子序列，从长到短逐一进行检查，看其是否为Y 的子序列，直到找到第一个最长公共子序列。由于X共有2^m 个子序列，故此方法对较大的m 没有实用价值。</p>
<h3 id="DP(动态规划)">DP(动态规划)</h3><p>记Xi = &lt; x1，…，xi &gt;即X序列的前i个字符 (1 &le; i &le; m)（前缀） Yj = &lt; y1，…，yj &gt;即Y 序列的前j 个字符 (1≤ j≤ n)（前缀） 假定Z = &lt; z1，…，zk &gt; &isin; LCS(X, Y)。 </p>
<ol>
<li>若xm = yn（最后一个字符相同），则不难用反证法证明：<br>该字符必是X 与Y 的任一最长公共子序列Z（设长度为k）的 最后一个字符，即有zk = xm = yn 且显然有 Zk-1 &isin; LCS(Xm-1 , Yn-1) 即Z 的前缀Zk-1 是Xm-1 与Yn-1 的最长公共子序列。 </li>
<li>若xm &ne; yn，则亦不难用反证法证明：<br>要么Z &isin; LCS(Xm-1, Y)，要么Z &isin; LCS(X, Yn-1)。 由于zk &ne; xm 与zk &ne; yn 其中至少有一个必成立，因此： 若zk &ne; xm则有Z &isin; LCS(Xm-1 , Y)， 若zk &ne; yn 则有Z &isin; LCS(X, Yn-1)。</li>
</ol>
<p><strong>所以</strong></p>
<ol>
<li>若xm = yn，则问题化归成求Xm-1 与Yn-1 的LCS。<br>（LCS(X, Y)的长度等于LCS(Xm-1, Yn-1) 的长度加1） </li>
<li>若xm &ne; yn 则问题化归成求Xm-1 与Y 的LCS 及X 与Yn-1 的LCS<br>LCS(X , Y)的长度为：max{LCS(Xm-1, Y)的长度, LCS(X, Yn-1)的长度} </li>
</ol>
<p>引进一个二维数组C，用C[i,j]记录Xi与Yj的LCS的长度   如果我们是自底向上进行递推计算，那么在计算C[i,j]之前， C[i-1,j-1], C[i-1,j]与C[i,j-1]均已计算出来。此时我们 根据X[i]=Y[j]还是X[i]Y[j]，就可以计算出C[i,j]： </p>
<ol>
<li>若X[i] = Y[j]，则执行C[i,j]←C[i-1,j-1]+1；</li>
<li>若X[i] &ne; Y[j]，则根据： 若C[i-1,j]≥C[i,j-1]则C[i,j]←C[i-1,j]；</li>
<li>否则C[i,j]←C[i,j-1]。即有</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span>;                         若i = <span class="number">0</span> 或j = <span class="number">0</span>；</span><br><span class="line">C[i,j] =&#123; C[i-<span class="number">1</span>, j-<span class="number">1</span>] + <span class="number">1</span>;           若i, j &gt; <span class="number">0</span> 且 xi = yj；</span><br><span class="line">          max&#123;C[i-<span class="number">1</span>, j], C[i, j-<span class="number">1</span>]&#125;  若i, j &gt; <span class="number">0</span> 且 xi != yj；</span><br></pre></td></tr></table></figure>
<p>如下图</p>
<p><img src="/images/LCS.png" alt=""></p>
<p>为了构造出LCS，使用一个m &times; n 的二维数组b， b[i,j] 记录C[i,j] 是通过哪一个子问题的值求得的, 以决定搜索的方向： </p>
<ol>
<li>若X[i] = Y[j]，，则b[i,j] 中记入“↖”；</li>
<li>若C[i-1,j] ≥ C[i,j-1]，则b[i,j] 中记入“↑”； </li>
<li>若C[i-1,j] &lt; C[i,j-1]，则b[i,j] 中记入“←”；</li>
</ol>
<p>算法伪代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LCS(X,Y,m,n,C) &#123;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">0</span> to m <span class="keyword">do</span> C[i,<span class="number">0</span>]←<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to n <span class="keyword">do</span> C[<span class="number">0</span>,j]←<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> to m <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span> to n <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> x[i]=y[j] &#123;</span><br><span class="line">                C[i,j]←C[i-<span class="number">1</span>,j-<span class="number">1</span>]+<span class="number">1</span>；</span><br><span class="line">                b[i,j]←“↖” ；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> C[i-<span class="number">1</span>,j]≥C[i,j-<span class="number">1</span>] &#123;</span><br><span class="line">                C[i,j]←C[i-<span class="number">1</span>,j]；</span><br><span class="line">                b[i,j]←“↑” ；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                C[i,j]←C[i,j-<span class="number">1</span>]；</span><br><span class="line">                b[i,j]←“←”;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<strong>一个</strong>LCS(X,Y) 的递归算法</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">LCS_Output</span>(<span class="keyword">b,X,i,j) </span>&#123;</span><br><span class="line">    <span class="preprocessor">if</span> i<span class="number">=0</span> or j<span class="number">=0</span> </span><br><span class="line">        return<span class="comment">; </span></span><br><span class="line">    <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“↖” </span>&#123;             <span class="comment">/*X[i]=Y[j]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i-1,j-1)；</span><br><span class="line"></span>        输出 X[i]；</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="preprocessor">else</span> <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“↑” </span>          <span class="comment">/*C[i-1,j]≥C[i,j-1]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i-1,j) </span></span><br><span class="line">    <span class="preprocessor">else</span> <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“←” </span>          <span class="comment">/*C[i-1,j]&lt;C[i,j-1]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i,j-1)</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>对上述例子调用 <strong>LCS_Output(b,X,7,6)</strong>。</p>
<p>下面是输出全部LCS 的C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LCS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LCS_L</span><span class="params">(<span class="built_in">string</span> x, <span class="built_in">string</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; C)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = x.size(), n = y.size();</span><br><span class="line">		C = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (x[i - <span class="number">1</span>] == y[j - <span class="number">1</span>]) C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">// 相同</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (C[i - <span class="number">1</span>][j] &gt;= C[i][j - <span class="number">1</span>]) C[i][j] = C[i - <span class="number">1</span>][j];  <span class="comment">// 不相同，取较大的一个</span></span><br><span class="line">				<span class="keyword">else</span> C[i][j] = C[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LCS_output</span><span class="params">(<span class="built_in">string</span> x, <span class="built_in">string</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; C, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span> lcs)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x[i - <span class="number">1</span>] == y[j - <span class="number">1</span>])  <span class="comment">// 由右上角产生</span></span><br><span class="line">			&#123;</span><br><span class="line">				lcs.push_back(x[i - <span class="number">1</span>]);</span><br><span class="line">				--i;</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>      (C[i - <span class="number">1</span>][j] &gt; C[i][j - <span class="number">1</span>]) --i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (C[i - <span class="number">1</span>][j] &lt; C[i][j - <span class="number">1</span>]) --j;</span><br><span class="line">				<span class="keyword">else</span>  <span class="comment">// equal</span></span><br><span class="line">				&#123;</span><br><span class="line">					LCS_output(x, y, C, i - <span class="number">1</span>, j, lcs);</span><br><span class="line">					LCS_output(x, y, C, i, j - <span class="number">1</span>, lcs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(lcs.begin(), lcs.end());</span><br><span class="line">		ans.push_back(lcs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	LCS lcs;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; C;</span><br><span class="line">	<span class="built_in">string</span> x = <span class="string">"ABCBDAB"</span>, y = <span class="string">"BDCABA"</span>, str;</span><br><span class="line">	lcs.LCS_L(x, y, C);</span><br><span class="line">	lcs.LCS_output(x, y, C, x.size(), y.size(), str);;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> s : lcs.ans)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BCBA</span><br><span class="line"></span><span class="keyword">BCAB</span><br><span class="line"></span><span class="keyword">BDAB</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="概念">概念</h2><h3 id="子序列">子序列</h3><p>设X = &lt; x1, x2,…, xm &gt;，若有1≤ i1 &lt; i2 &lt; … &lt; ik &le; m，使得 Z = &lt; z1, z2, …, zk&gt; = &lt; xi1, xi2, …, xik &gt;，则称Z 是X 的子序列， 记为Z &lt; X。<br>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Z = &lt; B,C,B,A &gt;,  则有Z &lt; X。</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://bluestein.github.io/tags/DP/"/>
    
      <category term="LCS" scheme="http://bluestein.github.io/tags/LCS/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用位操作符实现四则运算]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-add-substract-multiply-divide/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-add-substract-multiply-divide/</id>
    <published>2016-03-21T10:10:32.000Z</published>
    <updated>2016-03-21T11:07:20.997Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>如何使用位操作分别实现整数的加减乘除四种运算呢？</p>
<p>常用到的位操作：</p>
<p>1, 等式： <strong>-n = ~(n - 1) = ~n + 1</strong></p>
<p>2, 获取整数n的二进制中最后一个1： <strong>n &amp; (-n) 或者 n &amp; ~(n - 1)</strong></p>
<blockquote>
<p>如 n = 010100，则 -n = 101100，n &amp; (-n) = 000100</p>
</blockquote>
<p>3, 去掉整数n的二进制中最后一个1： <strong>n &amp; (n-1)</strong></p>
<blockquote>
<p>如：n = 010100，n-1 = 010011，n &amp; (n-1) = 010000</p>
</blockquote>
<a id="more"></a> 
<h2 id="加法">加法</h2><p>可以利用“异或”操作实现整数加法运算：<br>对应位数的“异或操作”可得到该位的数值，对应位的“与操作”可得到该位产生的高位进位，如：a =  010010，b = 100111，计算步骤如下：</p>
<p>第一轮：a ^ b= 110101，(a &amp; b) &lt;&lt; 1 = 000100， 由于进位（000100）大于0，则进入下一轮计算，a = 110101，b = 000100，a ^ b = 110001，(a &amp; b) &lt;&lt; 1= 001000，由于进位大于0，则进入下一轮计算：a = 110001，b = 001000，a ^ b = 111001，(a &amp; b) &lt;&lt; 1 = 0，进位为0，终止。计算结果为：111001。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Maths::add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> a;  <span class="comment">// 没有进位</span></span><br><span class="line">	<span class="keyword">int</span> sum = a ^ b;  <span class="comment">// 不计进位的和</span></span><br><span class="line">	<span class="keyword">int</span> carry = a &amp; b;  <span class="comment">// 进位</span></span><br><span class="line">	carry &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(sum, carry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">sum</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">sum</span> = a ^ b;  <span class="comment">// 不带进位</span></span><br><span class="line">		b = ((a &amp; b) &lt;&lt; <span class="number">1</span>);  <span class="comment">// 进位</span></span><br><span class="line">		a = <span class="keyword">sum</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="减法">减法</h2><p>减法可很容易地转化为加法：a - b = a + (-b) = a + (~b + 1 )</p>
<p>即，取减数的补码再相加 1</p>
<ol>
<li>负数的补码：原码取反加1</li>
<li>正数的补码：原码</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> complement = add(~b, <span class="number">1</span>); </span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, complement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法">乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">111</span>		(<span class="number">7</span>)</span><br><span class="line">  * <span class="number">101</span>		(<span class="number">5</span>)</span><br><span class="line">---------------</span><br><span class="line">	<span class="number">111</span>		(<span class="number">00111</span>) <span class="number">7</span> 向左移动 <span class="number">0</span> 位：<span class="number">111</span></span><br><span class="line">   <span class="number">000</span>		(<span class="number">00000</span>) <span class="number">7</span> 向左移动 <span class="number">1</span> 位：<span class="number">1110</span></span><br><span class="line">  <span class="number">111</span>		(<span class="number">11100</span>) <span class="number">7</span> 向左移动 <span class="number">2</span> 位：<span class="number">11100</span></span><br><span class="line">---------------</span><br><span class="line">  <span class="number">100011</span>	(<span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>b 的第0 位，为1，则结果加上 111，因为 1 * （111） = 111</li>
<li>b 的第2 位，为0，则结果加上 0000，因为 0 * (1110) = 0000</li>
<li>b 的第3 位，为1，则结果加上 11100，因为 1 * (11100) = 11100</li>
</ol>
<p>可以看到，<strong>b 每向右移一位，a 就要向左移动一位。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> isNegtive = (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>);  <span class="comment">// 决定结果的正负</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = -b;  <span class="comment">// 负数转化为正数计算</span></span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = -a;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = add(ans, a); <span class="comment">// 从右至左取 b 的二进制中的 1 （即右移）</span></span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isNegtive ? -ans : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="除法">除法</h2><p>除法就是由乘法的过程逆推，依次减掉（如果a 够减）b^(2^31), b^(2^30), …, b^8, b^4, b^2, b^1。</p>
<p><strong>b 减掉相应数量，则结果需加上相应的数量。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNegtive = (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = -b;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = -a;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((a &gt;&gt; i) &gt;= b)</span><br><span class="line">		&#123;</span><br><span class="line">			a = substract(a, (b &lt;&lt; i));</span><br><span class="line">			ans = add(ans, (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isNegtive ? -ans : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>如何使用位操作分别实现整数的加减乘除四种运算呢？</p>
<p>常用到的位操作：</p>
<p>1, 等式： <strong>-n = ~(n - 1) = ~n + 1</strong></p>
<p>2, 获取整数n的二进制中最后一个1： <strong>n &amp; (-n) 或者 n &amp; ~(n - 1)</strong></p>
<blockquote>
<p>如 n = 010100，则 -n = 101100，n &amp; (-n) = 000100</p>
</blockquote>
<p>3, 去掉整数n的二进制中最后一个1： <strong>n &amp; (n-1)</strong></p>
<blockquote>
<p>如：n = 010100，n-1 = 010011，n &amp; (n-1) = 010000</p>
</blockquote>]]>
    
    </summary>
    
      <category term="4-Arithmetic-Operations" scheme="http://bluestein.github.io/tags/4-Arithmetic-Operations/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="bit-manipulate" scheme="http://bluestein.github.io/tags/bit-manipulate/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深拷贝带随机指针的链表]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-copy-random-list/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-copy-random-list/</id>
    <published>2016-03-20T13:48:32.000Z</published>
    <updated>2016-03-20T13:57:37.743Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。返回一个深拷贝的链表。</p>
<ol>
<li>浅拷贝(影子克隆):只复制对象的基本类型，对象类型，仍属于原来的引用</li>
<li>深拷贝(深度克隆):不仅复制对象的基本类型，同时也复制原对象中的对象，就是说完全是新产生的对象</li>
</ol>
<a id="more"></a> 
<p>介绍两种方法，分别需要： O(n) time, O(n) space 和 O(n) time, O(1) space</p>
<h2 id="Solution1">Solution1</h2><p>三遍遍历。 O(n) time, O(n) space</p>
<p>分成3步：</p>
<ol>
<li>复制节点，如A-B-C =&gt; A-A’-B-B’-C-C’</li>
<li>依次遍历节点A,B,C，将A’B’C’这些节点的随机指针与其一致</li>
<li>分离成 A-B-C 和 A’-B’-C’，A’-B’-C’便是所求链表</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">RandomListNode* copyRandomList_nn(RandomListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line">	RandomListNode *cur = head;</span><br><span class="line">	<span class="comment">// 创建拷贝</span></span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		RandomListNode *node = <span class="literal">new</span> RandomListNode(cur<span class="subst">-&gt;</span>label);</span><br><span class="line">		node<span class="subst">-&gt;</span>next = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">		cur<span class="subst">-&gt;</span>next = node;</span><br><span class="line">		cur = node<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整random 指针</span></span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		RandomListNode *node = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">		<span class="comment">// 指向自身</span></span><br><span class="line">		<span class="keyword">if</span> (cur<span class="subst">-&gt;</span>random == cur) node<span class="subst">-&gt;</span>random = node;</span><br><span class="line">		<span class="comment">// 指向非空且不指向自身</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur<span class="subst">-&gt;</span>random) node<span class="subst">-&gt;</span>random = cur<span class="subst">-&gt;</span>random<span class="subst">-&gt;</span>next;</span><br><span class="line">		<span class="comment">// 指向空时，无需操作，因为默认为空</span></span><br><span class="line">		cur = cur<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分离</span></span><br><span class="line">	RandomListNode *copy = cur = head<span class="subst">-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span> (cur<span class="subst">-&gt;</span>next) &#123;</span><br><span class="line">		cur<span class="subst">-&gt;</span>next = cur<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next;</span><br><span class="line">		cur = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2">Solution2</h2><p>将各节点依次往后移一位，新建最后一位节点。 O(n) time, O(1) space</p>
<p>分成两步：</p>
<ol>
<li>移动：1-&gt;2-&gt;3-&gt;null =&gt; 1-&gt;1-&gt;2-&gt;3-&gt;null</li>
<li>调整指针关系</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">RandomListNode* copyRandomList_n1(RandomListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line">	RandomListNode *prev = head, *cur = head-&gt;next;</span><br><span class="line">	RandomListNode *copy;</span><br><span class="line">	<span class="keyword">int</span> prev_label = head-&gt;label, cur_label;</span><br><span class="line">	<span class="comment">// 移动 label</span></span><br><span class="line">	<span class="comment">// 1-2-3-null =&gt; 1-1-2-3-null</span></span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="comment">// label 往后移动一位</span></span><br><span class="line">		cur_label = cur-&gt;label;</span><br><span class="line">		cur-&gt;label = prev_label;</span><br><span class="line">		prev_label = cur_label;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 往后移动指针</span></span><br><span class="line">		prev = cur;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后一个节点，需要新建，并连接到原链表</span></span><br><span class="line">	RandomListNode *last = <span class="keyword">new</span> RandomListNode(prev_label);</span><br><span class="line">	prev-&gt;next = last;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整 random 指针</span></span><br><span class="line">	prev = head, cur = head-&gt;next;</span><br><span class="line">	RandomListNode *cur_random = head-&gt;random, *prev_random;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		prev_random = cur_random; <span class="comment">// 获取prev 的random 指针</span></span><br><span class="line">		cur_random = cur-&gt;random; <span class="comment">// 记录当前random 指针</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指向自身</span></span><br><span class="line">		<span class="keyword">if</span> (prev_random == prev) cur-&gt;random = cur;</span><br><span class="line">		<span class="comment">// 指向非空且不指向自身</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (prev_random) cur-&gt;random = prev_random-&gt;next;</span><br><span class="line">		<span class="comment">// 指向空</span></span><br><span class="line">		<span class="keyword">else</span> cur-&gt;random = nullptr;</span><br><span class="line"></span><br><span class="line">		prev = cur;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。返回一个深拷贝的链表。</p>
<ol>
<li>浅拷贝(影子克隆):只复制对象的基本类型，对象类型，仍属于原来的引用</li>
<li>深拷贝(深度克隆):不仅复制对象的基本类型，同时也复制原对象中的对象，就是说完全是新产生的对象</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="deep copy" scheme="http://bluestein.github.io/tags/deep-copy/"/>
    
      <category term="linked list" scheme="http://bluestein.github.io/tags/linked-list/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的后序遍历]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-postorder-traversal/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-postorder-traversal/</id>
    <published>2016-03-19T12:09:32.000Z</published>
    <updated>2016-03-19T13:45:48.636Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>
<a id="more"></a>
<p>比如，有如下二叉树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>则我们可以知道</p>
<ol>
<li>先序：preorder = [1,2,4,3,5]</li>
<li>中序：inorder = [2,4,1,3,5]</li>
<li>后序：postorder = [4,2,5,3,1]</li>
</ol>
<p>下面介绍的是后序遍历算法，分别使用递归和非递归方法。</p>
<h2 id="递归方法">递归方法</h2><p>算法首先遍历左子树，然后遍历右子树，最后是根节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	postorder(root, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">	postorder(root-&gt;left, ans);  <span class="comment">// 左子树</span></span><br><span class="line">	postorder(root-&gt;right, ans);  <span class="comment">// 右子树</span></span><br><span class="line">	ans.push_back(root-&gt;val);  <span class="comment">// 根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归方法">非递归方法</h2><p>可以用栈或 Morris 遍历</p>
<h3 id="1-_栈">1. 栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="comment">// 栈：时间复杂度 O(n)， 空间复杂度 O(n)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Trees::postorderTraversal(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">const</span> TreeNode*&gt; s;</span><br><span class="line">	<span class="comment">// *p 正在访问的点，*q 刚刚访问的点</span></span><br><span class="line">	<span class="keyword">const</span> TreeNode *p, *q;</span><br><span class="line">	p = root;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;  <span class="comment">// 往左走</span></span><br><span class="line">			s.push(p);</span><br><span class="line">			p = p-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		q = <span class="literal">nullptr</span>;  <span class="comment">// 未被访问过</span></span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			p = s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="comment">// 右孩子不存在，或已被访问</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right == q) &#123;</span><br><span class="line">				ans.push_back(p-&gt;val);</span><br><span class="line">				q = p;  <span class="comment">// 保存刚访问的节点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//当前节点不能访问，再次进栈</span></span><br><span class="line">				s.push(p);</span><br><span class="line">				<span class="comment">// 先处理右子树</span></span><br><span class="line">				p = p-&gt;right;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!s.empty());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_Morris">2. Morris</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="comment">// Morris：时间复杂度 O(n)， 空间复杂度 O(1)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Trees::postorderTraversal_Morris(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	TreeNode fake(-<span class="number">1</span>);</span><br><span class="line">	TreeNode *cur, *prev = nullptr;</span><br><span class="line">	function&lt; void(<span class="keyword">const</span> TreeNode*) &gt; visit = [&amp;ans](<span class="keyword">const</span> TreeNode *node) &#123;</span><br><span class="line">		ans.push_back(node-&gt;val);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	fake.left = root;</span><br><span class="line">	cur = &amp;fake;</span><br><span class="line">	<span class="keyword">while</span> (cur != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;left == nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur; <span class="comment">// 必须要有</span></span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			TreeNode *node = cur-&gt;left;</span><br><span class="line">			<span class="keyword">while</span> (node-&gt;right != nullptr &amp;&amp; node-&gt;right != cur)</span><br><span class="line">			&#123;</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 还没线索化，则建立线索 */</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right == nullptr)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;right = cur;</span><br><span class="line">				prev = cur;  <span class="comment">// 必须要有</span></span><br><span class="line">				cur = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 已经线索化，则访问节点，并删除线索 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit_reverse(cur-&gt;left, prev, visit);</span><br><span class="line">				prev-&gt;right = nullptr;</span><br><span class="line">				prev = cur;  <span class="comment">// 必须要有</span></span><br><span class="line">				cur = cur-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逆转路径</span></span><br><span class="line">void Trees::reverse(TreeNode *from, TreeNode *to)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode *x = from, *y = from-&gt;right, *z;</span><br><span class="line">	<span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != to)</span><br><span class="line">	&#123;</span><br><span class="line">		z = y-&gt;right;</span><br><span class="line">		y-&gt;right = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问逆转后的路径上的所有结点</span></span><br><span class="line">void Trees::visit_reverse(TreeNode *from, TreeNode *to,</span><br><span class="line">	function&lt; void(<span class="keyword">const</span> TreeNode*) &gt;&amp; visit)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode *p = to;</span><br><span class="line">	reverse(from, to);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">		<span class="keyword">if</span> (p == from) <span class="keyword">break</span>;</span><br><span class="line">		p = p-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(to, from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较复杂，可以参考 <a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）- cnblogs</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="binary tree" scheme="http://bluestein.github.io/tags/binary-tree/"/>
    
      <category term="postorder traversal" scheme="http://bluestein.github.io/tags/postorder-traversal/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[按奇偶分割数组]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-partition-array/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-partition-array/</id>
    <published>2016-03-18T14:00:05.000Z</published>
    <updated>2016-03-18T14:47:11.060Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="问题描述">问题描述</h2><p>给定一个数组，比如 array = { 6, 2, 3, 1, 1, 3, 5, 8}，对该数组进行整理，使得所有奇数都在前面，所有的偶数都在后面。且满足下列条件之一：</p>
<ol>
<li>保证所有奇数的相对顺序不改变，所有偶数的相对顺序不改变</li>
<li>不要求相对顺序不变</li>
</ol>
<a id="more"></a>
<p>愚钝，暂时只想到下面这些：</p>
<h2 id="1-_保持相对位置">1. 保持相对位置</h2><h3 id="a-_利用冒泡思想">a. 利用冒泡思想</h3><p>复杂度： T(n) = O(n^2), S(n) = O(1)<br>描述：从左至右扫描，遇到奇数则将其往左移动，直到遇到最近的奇数停止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) &#123;  <span class="comment">// odd</span></span><br><span class="line">			<span class="keyword">int</span> k = i;</span><br><span class="line">			<span class="keyword">while</span> (k &gt; j) &#123;  <span class="comment">// bubble: swap with the previous one</span></span><br><span class="line">				<span class="keyword">int</span> tmp = nums[k];</span><br><span class="line">				nums[k] = nums[k - <span class="number">1</span>];</span><br><span class="line">				nums[k - <span class="number">1</span>] = tmp;</span><br><span class="line">				--k;</span><br><span class="line">			&#125;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135628</span></span><br></pre></td></tr></table></figure>
<h3 id="b-_使用额外数组">b. 使用额外数组</h3><p>复杂度： T(n) = O(n), S(n) = O(n)<br>描述： </p>
<ol>
<li>新建一个数组，扫描原数组中的奇数并保存到新数组</li>
<li>再次扫描原数组，保存扫描到的所有偶数至新数组</li>
<li>然后把新数组的元素拷贝到原数组即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Arrays::partitionArray_copy(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 1. put odd number to copy</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) copy.push_back(nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 2. put even number to copy</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(nums[i] % <span class="number">2</span>)) copy.push_back(nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 3. copy to nums</span></span><br><span class="line">	&#123;</span><br><span class="line">		nums[i] = copy[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135628</span></span><br></pre></td></tr></table></figure>
<h2 id="2-_不保持相对位置">2. 不保持相对位置</h2><h3 id="a-_借助快速排序分区的方法">a. 借助快速排序分区的方法</h3><p>复杂度： T(n) = O(n), S(n) = O(1)<br>描述： </p>
<ol>
<li>使用两个指针i, j，从数组左边（右边一样）同时开始扫描</li>
<li>指针i 所指的元素是奇数时，则与j 所指元素对换</li>
<li>重复过程2，直到i 到达末尾</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_same</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) &#123; <span class="comment">// odd</span></span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135268</span></span><br></pre></td></tr></table></figure>
<h3 id="b-_两指针相撞">b. 两指针相撞</h3><p>复杂度： T(n) = O(n), S(n) = O(1)<br>描述：</p>
<ol>
<li>使用两个指针，i 指向头, j 指向尾，分别从数组左右边两边同时开始扫描</li>
<li>i 寻找第一个偶数，j 寻找第一个奇数，然后将它们所指元素对换</li>
<li>重复过程2 直至i &lt; j</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_both</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(nums[i] % <span class="number">2</span>) &amp;&amp; (nums[j] % <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">			i++, j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) i++;  <span class="comment">// skip odd</span></span><br><span class="line">		<span class="keyword">if</span> (!(nums[j] % <span class="number">2</span>)) j--;  <span class="comment">// skip even</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53311268</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="问题描述">问题描述</h2><p>给定一个数组，比如 array = { 6, 2, 3, 1, 1, 3, 5, 8}，对该数组进行整理，使得所有奇数都在前面，所有的偶数都在后面。且满足下列条件之一：</p>
<ol>
<li>保证所有奇数的相对顺序不改变，所有偶数的相对顺序不改变</li>
<li>不要求相对顺序不变</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="array" scheme="http://bluestein.github.io/tags/array/"/>
    
      <category term="partition" scheme="http://bluestein.github.io/tags/partition/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由前序遍历和中序遍历树构造二叉树]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-preorder-inorder/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-preorder-inorder/</id>
    <published>2016-03-17T14:23:05.000Z</published>
    <updated>2016-03-19T13:45:46.083Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>
<a id="more"></a>
<p>比如，有如下二叉树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>则我们可以知道</p>
<ol>
<li>先序：preorder = [1,2,4,3,5]</li>
<li>中序：inorder = [2,4,1,3,5]</li>
<li>后序：postorder = [4,2,5,3,1]</li>
</ol>
<h2 id="算法">算法</h2><p>算法首先利用先序遍历序列构造“跟”节点，然后依据中序遍历序列来构造左右子树。就拿上面二叉树举例，算法流程如下：</p>
<ol>
<li>根节点（root）是先序序列中的第一个节点preorder[0] = 1；</li>
<li>在inorder 中找到值等于1 的点，然后将inorder 分为左右两块，即[2,4] 和[3,5]</li>
<li>利用两块[2,4] 和[3,5] 分别用来构造根节点1 的左右子树。</li>
<li>递归产生各子树</li>
</ol>
<p>C++代码如下（仅供参考）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * class TreeNode &#123;</span><br><span class="line"> * public:</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left, *right;</span><br><span class="line"> *     TreeNode(int val) &#123;</span><br><span class="line"> *         this-&gt;val = val;</span><br><span class="line"> *         this-&gt;left = this-&gt;right = NULL;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *@param preorder : A list of integers that preorder traversal of a tree</span><br><span class="line">     *@param inorder : A list of integers that inorder traversal of a tree</span><br><span class="line">     *@return : Root of a tree</span><br><span class="line">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_pre = preorder.size(), len_in = inorder.size();</span><br><span class="line">        <span class="keyword">if</span> (!len_in || !len_pre) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;  <span class="comment">// in: 中序遍历根节点所在位置</span></span><br><span class="line">        <span class="keyword">while</span> (preorder[<span class="number">0</span>] != inorder[in]) in++;  <span class="comment">// 在中序遍历找到根节点位置</span></span><br><span class="line">        preorder.erase(preorder.begin()); <span class="comment">// 去除preorder的第一个元素</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it_in = inorder.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_left, inorder_right;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="number">0</span>)  <span class="comment">// 有左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            inorder_left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(it_in, it_in + in);  <span class="comment">// 左侧子树的中序遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in != len_in -<span class="number">1</span>)  <span class="comment">// 有右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            inorder_right = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(it_in + in + <span class="number">1</span>, inorder.end());  <span class="comment">// 右侧子树的中序遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = buildTree(preorder, inorder_left);  <span class="comment">// 构造左子树</span></span><br><span class="line">        root-&gt;right = buildTree(preorder, inorder_right);  <span class="comment">// 构造右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="binary tree" scheme="http://bluestein.github.io/tags/binary-tree/"/>
    
      <category term="inorder" scheme="http://bluestein.github.io/tags/inorder/"/>
    
      <category term="preorder" scheme="http://bluestein.github.io/tags/preorder/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce]]></title>
    <link href="http://bluestein.github.io/2016/03/ML-map-reduce/"/>
    <id>http://bluestein.github.io/2016/03/ML-map-reduce/</id>
    <published>2016-03-11T14:15:10.000Z</published>
    <updated>2016-03-11T14:19:39.987Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="map函数和reduce函数">map函数和reduce函数</h3><p>map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p>
<ol>
<li>map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</li>
<li>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</li>
</ol>
<a id="more"></a>
<p>使用词频统计来做例子：拆分文件集，copy程序，整合结果。下面是MapReduce函数的核心代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">	// key: document name</span><br><span class="line">	// value: document contents</span><br><span class="line">	<span class="keyword">for</span> each word w <span class="keyword">in</span> value:</span><br><span class="line">		EmitIntermediate(w, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">	// key: a word</span><br><span class="line">	// values: a list of counts</span><br><span class="line">	int result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> each v <span class="keyword">in</span> values:</span><br><span class="line">		result += ParseInt(v);</span><br><span class="line">		Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>在统计词频的例子里，map 函数接受的键是文件名，值是文件的内容，map 逐个遍历单词，每遇到一个单词w，就产生一个中间键值对<w, "1"="">，这表示单词w 咱又找到了一个；MapReduce 将键相同（都是单词w）的键值对传给reduce 函数，这样reduce 函数接受的键就是单词w，值是一串”1”（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些“1”累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统（GFS 或HDFS）。</w,></p>
<h3 id="MapReduce工作">MapReduce工作</h3><p><img src="/images/mapReduce.jpg" alt=""></p>
<p>上图是论文里给出的流程图。一切都是从最上方的user program 开始的，user program 链接了MapReduce 库，实现了最基本的Map 函数和Reduce 函数。图中执行的顺序都用数字标记了。</p>
<ol>
<li>MapReduce 库先把user program 的输入文件划分为M份（M为用户定义），每一份通常有16MB 到64MB，如图左方所示分成了split0~4；然后使用fork 将用户进程拷贝到集群内其它机器上。</li>
<li>user program 的副本中有一个称为master，其余称为worker，master 是负责调度的，为空闲worker 分配作业（Map 作业或者Reduce 作业），worker 的数量也是可以由用户指定的。</li>
<li>被分配了Map 作业的worker，开始读取对应分片的输入数据，Map 作业数量是由M 决定的，和split一一对应；Map 作业从输入数据中抽取出键值对，每一个键值对都作为参数传递给map 函数，map 函数产生的中间键值对被缓存在内存中。</li>
<li>缓存的中间键值对会被定期写入本地磁盘，而且被分为R 个区，R 的大小是由用户定义的，将来每个区会对应一个Reduce 作业；这些中间键值对的位置会被通报给master，master 负责将信息转发给Reduce worker。</li>
<li>master 通知分配了Reduce 作业的worker 它负责的分区在什么位置（不止一个地方，每个Map 作业产生的中间键值对都可能映射到所有R 个不同分区），当Reduce worker 把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是同一个Reduce 作业（因为分区少），所以排序是必须的。</li>
<li>reduce worker 遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce 函数，reduce 函数产生的输出会添加到这个分区的输出文件中。</li>
<li>当所有的Map 和Reduce 作业都完成了，master 唤醒正版的user program，MapReduce 函数调用返回user program 的代码。</li>
</ol>
<p>所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一个MapReduce程序处理。整个过程中，输入数据是来自底层分布式文件系统（GFS）的，中间数据是放在本地文件系统的，最终输出数据是写入底层分布式文件系统（GFS）的。而且我们要注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。</p>
<h3 id="用户的权利">用户的权利</h3><p>用户最主要的任务是实现map 和reduce 接口，但还有一些有用的接口是向用户开放的。</p>
<ol>
<li>input reader：这个函数会将输入分为M个部分，并且定义了如何从数据中抽取最初的键值对，比如词频的例子中定义文件名和文件内容是键值对</li>
<li>partition function：这个函数用于将map函数产生的中间键值对映射到一个分区里去，最简单的实现就是将键求哈希再对R取模</li>
<li>compare function：这个函数用于Reduce作业排序，这个函数定义了键的大小关系</li>
<li>output writer：负责将结果写入底层分布式文件系统</li>
<li>combiner function：实际就是reduce 函数，这是用于前面提到的优化。比如统计词频时，如果每个<w, "1"="">要读一次，因为reduce 和map 通常不在一台机器，非常浪费时间，所以可以在map 执行的地方先运行一次combiner，这样reduce 只需要读一次<w, "n"="">了</w,></w,></li>
<li>map 和reduce 函数</li>
</ol>
<p>参见 <a href="http://blog.csdn.net/opennaive/article/details/7514146" target="_blank" rel="external">csdn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="map函数和reduce函数">map函数和reduce函数</h3><p>map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p>
<ol>
<li>map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</li>
<li>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</li>
</ol>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://bluestein.github.io/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://bluestein.github.io/tags/MapReduce/"/>
    
      <category term="分布式" scheme="http://bluestein.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Hadoop" scheme="http://bluestein.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Efficient Online Evaluation of Big Data Stream Classifiers]]></title>
    <link href="http://bluestein.github.io/2016/03/ML-evaluation-of-data-stream/"/>
    <id>http://bluestein.github.io/2016/03/ML-evaluation-of-data-stream/</id>
    <published>2016-03-09T01:57:05.000Z</published>
    <updated>2016-03-11T13:05:27.450Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372" target="_blank" rel="external">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>
<a id="more"></a>
<p>如今，几乎所有研究者都需要有效的评价他们自己模型的有效性。然而，数据流领域的评价标准面临很多挑战。数据流中的实例是随着时间到来的，并且这些数据所包含的概念（concept）也可能也时间有关。再者，大量的数据还可能面临类别不平衡（class imbalance）问题。现阶段的数据流评价标准一般使用 prequential(predictive sequential?) setting，并且只建立一个模型，不能够实时地计算出统计意义（statistical significance）。</p>
<p>提供统计的意义是非常重要，确保评价结果是有效且没有误导成分。现提出三种突出的有误导性的评价的例子：</p>
<ol>
<li>为了评价两个分类器在数据流上的statistical significance 好坏，会利用McNemar’s test。然而这两个分类器实际上是同一个算法的两个对象（这么理解：C++中的类，new 两个对象），只是使用不同seed 对决策树的随机组合。McNemar’s test对于小型数据来说表现不错，但是使用在大型数据上就是误导。然而，它在数据流分类中却被广泛的使用。</li>
<li>将数据分成独立（disjoint）的两块：training，test，是通常的做法。然而，这种类型的分法，导致一个评价程序仅仅通过分类器的话，不能正确的区分这两块用不同方式构造的数据;</li>
<li>a simple majority class（多类） classifier that keeps the majority class of a sliding window may have positive k statistic and positive harmonic mean accuracy（调和平均精度） for some periods.</li>
</ol>
<p>对于四个问题：</p>
<ol>
<li>Validation methodology（方法验证）</li>
<li>Statistical testing（统计测试）：McNemar’s test 是误导</li>
<li>Unbalanced measure（不平衡衡量标准）：通常的F1-Measure 和Accuracy 会偏向一个类</li>
<li>Forgetting mechanism（遗忘机制）：sliding window（滑动窗口） 和 exponential forgetting 是两种很流行的方法，但是他们都很确定参数。</li>
</ol>
<p>解决方法是：</p>
<ol>
<li>new bootstrap validation</li>
<li>Sign test 和 Wilcoxon signed-rank test</li>
<li>κ_{m} statistic </li>
<li>new forgetting mechanism for prequential evaluation based<br>on ADWIN </li>
</ol>
<h3 id="validation_methodology">validation methodology</h3><p>validation methodology 是用来决定训练集合和测试集合的算法。在文献中有两种主要方法来评价数据流：</p>
<ol>
<li>prequential evaluation：平均10次随机生成数据流上的实验结果。或者使用真实数据集和非随机分类器（non-randomized）进行一个实验；</li>
<li>标准的10-fold 交叉验证；</li>
</ol>
<p>第一类中，使用真实数据和非随机分类器时不能获得statistical significance。第二类把每个fold 的流当成独立的，所以可能会丢失概念漂移的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>]]>
    
    </summary>
    
      <category term="big data" scheme="http://bluestein.github.io/tags/big-data/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/tags/data-stream/"/>
    
      <category term="evaluation" scheme="http://bluestein.github.io/tags/evaluation/"/>
    
      <category term="Machine Learning" scheme="http://bluestein.github.io/categories/Machine-Learning/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/categories/Machine-Learning/data-stream/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里电话面试]]></title>
    <link href="http://bluestein.github.io/2016/03/interview-ali/"/>
    <id>http://bluestein.github.io/2016/03/interview-ali/</id>
    <published>2016-03-08T14:00:05.000Z</published>
    <updated>2016-03-10T11:04:14.286Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>
<a id="more"></a>
<p>关于我答不上来这件事，我知道完全是我自己没准备，以至于错失一次好机会。也总结出关于投递简历的一点小建议（其实是师兄告诉我的。。）：<strong>在deadline之前，在没准备好的情况下，先别冲动投简历！</strong>至于怎么界定“准备好”，就得看大家自己的感觉了。对于我来说，至少需要把基础书看上一遍吧。。不能跟我一样卡壳在基础知识上，以至于面试官认为你根本不是简历上说的那么犀利（excellent？就那意思啦），甚至认为在造假，这种错误我绝不能再犯第二次，嗯，不能。。</p>
<p>下面是今天的问题，大概。。</p>
<p>1，    HTPP中URL由几部分组成<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">URL-Wikipedia</a>）</p>
<p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p>
<ul>
<li>传送协议。</li>
<li>服务器。（通常为域名，有时为IP地址）</li>
<li>端口号。（以数字方式表示，若为HTTP的预设值“:80”可省略）</li>
<li>路径。（以“/”字元区别路径中的每一个目录名称）</li>
<li>查询。（GET模式的表单参数，以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题）</li>
</ul>
<p>2，排序算法<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">排序算法-Wikipedia</a>）</p>
<h4 id="稳定的排序">稳定的排序</h4><ol>
<li>冒泡排序（bubble sort）— O(n2)</li>
<li>鸡尾酒排序（cocktail sort）—O(n2)</li>
<li>插入排序（insertion sort）—O(n2)</li>
<li>桶排序（bucket sort）—O(n)；需要O(k)额外空间</li>
<li>计数排序（counting sort）—O(n+k)；需要O(n+k)额外空间</li>
<li>归并排序（merge sort）—O(n log n)；需要O(n)额外空间</li>
<li>原地归并排序— O(n log2 n)如果使用最佳的现在版本</li>
<li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li>
<li>鸽巢排序（pigeonhole sort）—O(n+k)；需要O(k)额外空间</li>
<li>基数排序（radix sort）—O(n·k)；需要O(n)额外空间</li>
<li>侏儒排序（gnome sort）— O(n2)</li>
<li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li>
<li>块排序（block sort）— O(n log n)</li>
<li>额外儿童网二对一后退萨大人排序（children two to one additional network Back Sa adults sort）— O(n2)</li>
</ol>
<h4 id="不稳定排序">不稳定排序</h4><ol>
<li>选择排序（selection sort）—O(n2)</li>
<li>希尔排序（shell sort）—O(n log2 n)如果使用最佳的现在版本</li>
<li>Clover排序算法（Clover sort）—O(n)期望时间，O(n2)最坏情况</li>
<li>梳排序— O(n log n)</li>
<li>堆排序（heap sort）—O(n log n)</li>
<li>平滑排序（smooth sort）— O(n log n)</li>
<li>快速排序（quick sort）—O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li>
<li>内省排序（introsort）—O(n log n)</li>
<li>耐心排序（patience sort）—O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li>
</ol>
<p>3，浏览器输入一个网址，其背后原理解释<br>答：(参考 <a href="http://www.cricode.com/3696.html" target="_blank" rel="external">在浏览器中输入网址后都发生了什么</a>)</p>
<p>从输入一个网址到显示，包括dns解析，http协议解析，html解析，js解析，以及各种内容渲染</p>
<ol>
<li><p>浏览器发起DNS查询请求<br>在广域网中，我们是基于IP地址进行通信的。但通常客户访问的是一个网址，为此，我们需要先得到网址对应的IP地址，这就需要域名服务系统将域名转换成IP地址。</p>
</li>
<li><p>域名服务器向客户端返回查询结果域名，从而完成域名到IP地址的转换</p>
</li>
<li><p>客户端向web服务器发送HTTP请求<br>在得到了域名对应的IP地址后，客户端便可以向真正的web服务器发生HTTP请求。<br>HTTP请求是一个基于TCP协议之上的应用层协议——超文本传输协议。浏览器通过DNS获取到web服务器真的IP地址后，便向web服务器发起tcp连接请求，通过TCP三次握手建立好连接后，浏览器便可以将HTTP请求数据通过发送给服务器了。</p>
</li>
<li><p>发送响应数据给客户端<br>Web服务器通常通过监听80端口，来获取客户端的HTTP请求。与客户端建立好TCP连接后，web服务器开始接受客户端发来的数据，并通过HTTP解码，从接受到的网络数据中解析出请求的url信息以前其他诸如Accept-Encoding、Accept-Language等信息。<br>至此，一个HTTP通信过程完成。web服务器会根据HTTP请求头中的Connection字段值决定是否关闭TCP链接通道，当Connection字段值为keep-alive时，web服务器不会立即关闭此连接。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>]]>
    
    </summary>
    
      <category term="alibaba" scheme="http://bluestein.github.io/tags/alibaba/"/>
    
      <category term="hhh" scheme="http://bluestein.github.io/tags/hhh/"/>
    
      <category term="interview" scheme="http://bluestein.github.io/tags/interview/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="JobHunting" scheme="http://bluestein.github.io/categories/Odds-Ends/JobHunting/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KMP: 字符串匹配算法]]></title>
    <link href="http://bluestein.github.io/2016/03/Algorithm-KMP/"/>
    <id>http://bluestein.github.io/2016/03/Algorithm-KMP/</id>
    <published>2016-03-08T07:23:05.000Z</published>
    <updated>2016-03-08T08:01:38.905Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="external">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>
<a id="more"></a>
<h3 id="1">1</h3><p><img src="/images/kmp/kmp_1.png" alt=""></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<h3 id="2">2</h3><p><img src="/images/kmp/kmp_2.png" alt=""></p>
<p>因为B与A不匹配，搜索词再往后移。</p>
<h3 id="3">3</h3><p><img src="/images/kmp/kmp_3.png" alt=""></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>
<h3 id="4">4</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<h3 id="5">5</h3><p><img src="/images/kmp/kmp_6.png" alt=""></p>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较就像上图所示。<strong>这样做虽然可行，但是效率很差</strong>，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>
<h3 id="6">6</h3><p><img src="/images/kmp/kmp_8.png" alt=""></p>
<p>可以针对搜索词，算出一张<strong>部分匹配表</strong>（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<h3 id="7">7</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">　　移动位数 </span>=<span class="string"> 已匹配的字符数 - 对应的部分匹配值</span></span><br></pre></td></tr></table></figure>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<h3 id="8">8</h3><p><img src="/images/kmp/kmp_10.png" alt=""></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<h3 id="9">9</h3><p><img src="/images/kmp/kmp_11.png" alt=""><br>因为空格与A不匹配，继续后移一位。</p>
<h3 id="10">10</h3><p><img src="/images/kmp/kmp_12.png" alt=""></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<h3 id="11">11</h3><p><img src="/images/kmp/kmp_13.png" alt=""></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<h2 id="Partial_Match_Table：部分匹配表">Partial Match Table：部分匹配表</h2><p><img src="/images/kmp/kmp_14.png" alt=""></p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<p>参考 @阮一峰 <a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">KMP-cnblog</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>]]>
    
    </summary>
    
      <category term="KMP" scheme="http://bluestein.github.io/tags/KMP/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[const与指针、函数]]></title>
    <link href="http://bluestein.github.io/2016/03/cpp-const-pointer-function/"/>
    <id>http://bluestein.github.io/2016/03/cpp-const-pointer-function/</id>
    <published>2016-03-05T01:23:05.000Z</published>
    <updated>2016-03-05T02:46:17.003Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>2. const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p>关于指针的其他内容，请参考本站文章<a href="http://bluestein.github.io/2015/11/cpp-primer4-11/">指针</a>。</p>
<h2 id="const与函数">const与函数</h2><hr>
<p><strong>1. 用const修饰函数的参数</strong></p>
<p>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。const 只能修饰输入参数：</p>
<p><strong>如果输入参数采用“指针传递”，那么加 const 修饰可以防止意外地改动该指针，起到保护作用。</strong></p>
<p>例如 StringCopy 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *destination, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>source</code> 是输入参数，<code>destination</code> 是输出参数。给 <code>destination</code> 加上 const 修饰后，<strong>如果函数体内的语句试图改动 source 的内容，编译器将指出错误。</strong></p>
<p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，则输入参数无需保护，所以不要加 const 修饰。</p>
<p>例如， void func(int x) 而不是 void func(const int x) 。同理，同理不要将函数 void fun2(A a) 写成 void func2(const A a)。其中 A 为用户自定义的数据类型。</p>
<p>对于非内部数据类型的参数而言，象 void func(A a) 这样声明的函数注定效率比较底。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p><strong>为了提高效率，可以将函数声明改为 void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数 void func(A &amp;a) 存在一个缺点:</strong></p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p>
<p>以此类推，是否应将 void func(int x) 改写为 void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p>总结一下：</p>
<ol>
<li>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将 void func(A a) 改为 void func(const A &amp;a)。</li>
<li>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如 void func(int x) 不应该改为void func(const int &amp;x)。</li>
</ol>
<p><strong>2. 用const 修饰函数的返回值</strong></p>
<p>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，<strong>该返回值只能被赋给加const 修饰的同类型指针</strong>。</p>
<p>如下语句将出现编译错误：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。</p>
<p>例如，不要把函数 int getInt(void) 写成 const int getInt(void)。同理不要把函数 A getA(void) 写成 const A getA(void)，其中 A 为用户自定义的数据类型。</p>
<p>如果返回值不是内部数据类型，将函数 A getA(void) 改写为 const A &amp; getA(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">A</span> &amp; operate = (const <span class="type">A</span> &amp;other); <span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> a, b, <span class="built_in">c</span>; <span class="comment">// a, b, c 为 A 的对象</span></span><br><span class="line">a = b = <span class="built_in">c</span>; <span class="comment">// 正常的链式赋值</span></span><br><span class="line">(a = b) = <span class="built_in">c</span>; <span class="comment">// 不正常的链式赋值，但合法</span></span><br></pre></td></tr></table></figure>
<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p>
<p><strong>3. const 成员函数</strong></p>
<p>任何不会修改数据成员的函数都应该声明为 const 类型。如果在编写 const 成员函数时，不慎修改了数据成员，或者调用了其它非 const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p>
<p>以下程序中，类 Stack 的成员函数 GetCount 仅用于计数，从逻辑上讲 GetCount 应当为 const 函数。编译器将指出 GetCount 函数中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_num;</span><br><span class="line">	<span class="keyword">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::GetCount(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	++m_num; <span class="comment">// 编译错误，企图修改数据成员 m_num</span></span><br><span class="line">	Pop(); <span class="comment">// 编译错误，企图调用非 const 函数</span></span><br><span class="line">	<span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 成员函数的声明看起来怪怪的：const 关键字只能放在函数声明的尾部，大概是因为其它地方都已经被占用了。</p>
<p>关于 const 函数的几点规则：</p>
<ol>
<li>const 对象只能访问 const 成员函数,而非 const 对象可以访问任意的成员函数,包括 const 成员函数.</li>
<li>const 对象的成员是不可修改的,然而 const 对象通过指针维护的对象却是可以修改的.</li>
<li>const 成员函数不可以修改对象的数据,不管对象是否具有 const 性质.它在编译时,以是否修改成员数据为依据,进行检查.</li>
<li>然而加上 mutable 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 const 成员函数是可以修改它的</li>
</ol>
<p>该部分,参考<a href="http://www.cnblogs.com/Fancyboy2004/archive/2008/12/23/1360810.html" target="_blank" rel="external">原文</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="const" scheme="http://bluestein.github.io/tags/const/"/>
    
      <category term="指针" scheme="http://bluestein.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[冬跑]]></title>
    <link href="http://bluestein.github.io/2016/02/interest-winter-running/"/>
    <id>http://bluestein.github.io/2016/02/interest-winter-running/</id>
    <published>2016-02-25T07:15:05.000Z</published>
    <updated>2016-03-05T02:44:53.849Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>
<a id="more"></a>
<h3 id="1、跑鞋">1、跑鞋</h3><p>我个人觉得，要跑步的话必须现有一双好的跑鞋。我在网络上看到，这个网站 <a href="http://www.myprecisionfit.com" title="myprecisionfit" target="_blank" rel="external">myprecisionfit</a> 能够根据自身情况进行跑鞋推荐。这个网站推荐了好几双，各种价位的都有，但考虑到刚入门和能不坚持下去都是个问题就选了一双经济承受范围内 wave 系列。在京东和天猫都有官方旗舰店，可自行选择购买。我的选择是：（切记，要根据自身情况选择跑鞋，我列出我的选择是为了理清预算）</p>
<ul>
<li>MIZUNO Wave Laser 2 ￥329</li>
</ul>
<h3 id="2、服饰装备">2、服饰装备</h3><h4 id="2-1、上身">2.1、上身</h4><p>看到网络大部分意见上说冬天需要三层：</p>
<ul>
<li>最里层：速干T；</li>
<li>中层：保暖；</li>
<li>最外层：防风；</li>
<li>其他：臂包，袜子，手套，帽子等；</li>
</ul>
<p>上面所说的所有装备均可以在 <a href="http://www.decathlon.com.cn/zh/running" title="迪卡侬" target="_blank" rel="external">迪卡侬</a> 买到，而且性价比不错。先声明，绝对不是打广告。我选择的是</p>
<ul>
<li>速干T：KALENJI EKIDEN TS ￥19.9</li>
<li>保暖：KALENJI EKIDEN LS ￥69.9</li>
<li>防风：<ul>
<li>KALENJI COMFORT PROTECT WIND ￥79.0</li>
<li>其他</li>
</ul>
</li>
<li>其他：<ul>
<li>臂包：KALENJI ARMBAND ￥49.9</li>
<li>袜子：暂未购买</li>
<li>其他</li>
</ul>
</li>
</ul>
<h4 id="2-2、下身">2.2、下身</h4><p>也有说不用特别选下身的，只要是普通运动裤都可以。但是我个人觉得别人有这个卖的话顺便也买一条，反正也不贵呀。对于下身来说，分两层就可以了吧。</p>
<ul>
<li>内层：快干内裤；</li>
<li>外层：运动长裤（冬天当然是长裤）；</li>
</ul>
<p>同样的，也可以在迪卡侬选购，再说一遍，我真的不是打广告的（=_=）。我的选择是：</p>
<ul>
<li>内层：暂时未买，试试看再说；</li>
<li>外层：KALENJI EKIDEN PANT ￥99.0</li>
</ul>
<p><strong>总预算：329 + 19.9 + 69.9 + 79.0 + 49.9 + 99.0 = ￥646.7</strong></p>
<h3 id="3、开跑">3、开跑</h3><p>以下内容参考了知乎</p>
<h4 id="3-1、空气环境">3.1、空气环境</h4><p>一般来说PM2.5超过100就要慎重，比100低基本问题不大；大于100，小于150，属于轻度污染，如果对雾霾比较敏感的人不太适宜跑步，如果不是很敏感，勉强可以接受；但是如果是150～200，这属于中度污染，跑步这个时候对人体是不健康的；如果追求健康就不要跑了。超过200逼近300的话，无论如何是不能出去跑的，等个合适的天再出门跑步，实在熬不住，那就跑步机或去周围空气好的城市或山区跑一下，这里提醒大家PM2.5指数以当时指数为准。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</p>
<h4 id="3-2、跑步流程：热身→跑步→拉伸">3.2、跑步流程：热身→跑步→拉伸</h4><ul>
<li>跑步姿势可以参考 <a href="http://www.zhihu.com/question/31089103/answer/61288749" target="_blank" rel="external">缺个口子的大苹果 - 正确的跑步姿势是怎样的？</a>。</li>
<li>预热：晨跑前先喝大概250cc糖水或香蕉，防止低血糖。然后先可以先走一走，比如出家门走到运动场。通过血液循环，使身体由内而外地热起来。然后只要再做做准备动作，身体就可以充分放松了。注意不要像散步一样随意走，要保持正确的姿势，从骨盆开始带动腿。（<a href="http://www.zhihu.com/question/36505010/answer/67853152" target="_blank" rel="external">袁超 - 冬天了，跑步方便吗？</a>）</li>
<li>跑步：调整呼吸开跑，完成预定目标。</li>
<li>拉伸：要充分的拉伸。</li>
</ul>
<h4 id="3-3、注意事项">3.3、注意事项</h4><ol>
<li>如果喜欢一边跑步一边听歌的话最好换个蓝牙耳机。北京冬天早上空气冷，普通耳机橡胶线遇冷容易变硬，弹性减小，再加上跑步运动，很容易把耳机线拉断。</li>
<li>记得带个润唇膏，暴漏在干冷天气里的嘴唇很容易干裂。如果遇到大风天，可以戴防风眼镜。</li>
<li>秋季空气中湿度减少，容易引起咽喉干燥、口舌少津、嘴唇干裂、鼻子出血、大便干燥等症状。再加上运动时丧失的水分会加重人体缺乏水分的反应，所以，运动后一定要多喝开水，多吃梨、苹果、乳类、芝麻、新鲜蔬菜等柔润食物，或是平时多喝冰糖梨水、冬瓜汤等食物来保持上呼吸道黏膜的正常分泌，防止咽喉肿痛。</li>
<li>如果运动量较大，出汗过多，可在开水中加少量食盐，以维持体内酸碱平衡，有条件的可以喝一些含电解质的运动饮料，防止肌肉出现痉挛。</li>
<li>如进行长跑锻炼，还要饮用适量的糖开水，以防低血糖，出现头晕、出虚汗、四肢乏力等不良生理反应。</li>
<li>运动时补水不能在运动前或运动后一下子喝很多，运动前喝多了容易造成肠胃负担加重，而且一动起来胃里咣咣响也影响锻炼。运动后猛喝会带走大量的电解质，部分流出体外，对身体不好，运动时饮水最好能分次少量饮用，比如锻炼20分钟，喝150到200毫升，饮料浓度为6-8%的低渗饮料（含糖、钠、钾、钙、镁）。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</li>
</ol>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>]]>
    
    </summary>
    
      <category term="running" scheme="http://bluestein.github.io/tags/running/"/>
    
      <category term="sport" scheme="http://bluestein.github.io/tags/sport/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="兴趣" scheme="http://bluestein.github.io/categories/Odds-Ends/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单词转换程序]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-12/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-12/</id>
    <published>2016-01-14T12:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.938Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; trans_map;</span><br><span class="line">	<span class="built_in">string</span> key, value;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"wrong number of arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream map_file;</span><br><span class="line">	map_file.open(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!map_file) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no transformation file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (map_file &gt;&gt; key &gt;&gt; value) &#123;</span><br><span class="line">		trans_map.insert(make_pair(key, value));</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream input;</span><br><span class="line">	input.open(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no input file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> line;</span><br><span class="line">	<span class="keyword">while</span> (getline(input, line)) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">s</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (s &gt;&gt; word) &#123;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::const_iterator map_citer = trans_map.find(word);</span><br><span class="line">			<span class="keyword">if</span> (map_citer != trans_map.end()) &#123;</span><br><span class="line">				word = map_citer-&gt;second;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (first) &#123;</span><br><span class="line">				first = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关联容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-associative_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-associative_container/</id>
    <published>2016-01-14T06:49:02.000Z</published>
    <updated>2016-03-05T02:41:48.583Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>
<a id="more"></a>
<ol>
<li>map 以 key-value（键-值） 的形式组织：键作为元素在 map 中的索引，而值则表示所要存储和读取的元素。</li>
<li>set 仅包含键，可以看成含有很多键值得集合。</li>
</ol>
<table>
<thead>
<tr>
<th>关联容器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>关联数组</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
</tr>
<tr>
<td>multimap</td>
<td>一个键可出现多次的 map 类型</td>
</tr>
<tr>
<td>multiset</td>
<td>一个键可出现多次的 set 类型</td>
</tr>
</tbody>
</table>
<p>一般来说，<strong>如果想有效的存储不同值得集合</strong>，使用 set 比较合适；而 map 容器则更适合用于存储键关联值得情况。<br>比如在文本处理时，可以使用 set 来存储要忽略的词，而 map 可以使用作字典：单词本身是键，其解释是值。</p>
<blockquote>
<p>set 和 map 的键是唯一的，每个键只能出现一次。如果想使用一个键对应多个值得情况，那么使用 multiset 和 multimap 类型。</p>
</blockquote>
<h3 id="pair_类型">pair 类型</h3><p>在介绍关联容器之前，必须先了解一种与之相关的简单的标准库类型——pair 类型，在 <code>utility</code> 头文件中定义</p>
<table>
<thead>
<tr>
<th>pair 类型所提供的操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pair<t1, t2=""> p1</t1,></td>
<td>创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用<strong>值初始化</strong></td>
</tr>
<tr>
<td>pair<t1, t2=""> p1(v1,v2)</t1,></td>
<td>创建一个 pair 对象，它的两个元素类型分别是 T1 和 T2。其中 first 成员初始化为 v1，second 成员初始化为 v2</td>
</tr>
<tr>
<td>make_pair(v1, v2)</td>
<td>用 v1 和 v2 创建一个 pair 对象，其元素的类型分别是 v1 和 v2 的类型。</td>
</tr>
<tr>
<td>p1 &lt; p2</td>
<td>两个 pair 对象的小于运算，其定义遵循字典次序：如果 <code>p1.first &lt; p2.first</code> 或 <code>!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second</code> 则返回 true</td>
</tr>
<tr>
<td>p1 == p2</td>
<td>等于操作</td>
</tr>
<tr>
<td>p.first</td>
<td>返回 p 中的 first（第一个） 成员</td>
</tr>
<tr>
<td>p.second</td>
<td>返回 p 中的 second（第二个） 成员</td>
</tr>
</tbody>
</table>
<h4 id="pair_的创建和初始化">pair 的创建和初始化</h4><p>在创建 pair 对象时，必须提供两个类型名，这两个类型名不必相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; line;</span><br></pre></td></tr></table></figure>
<p><strong>创建 pair 时，如果不提供初始化式，则调用默认构造函数进行值初始化。</strong>所以，<code>anon</code> 是包含两个空 string 成员的 pair 对象； <code>word_count</code> 中的 int 型成员获得 0 值； <code>line</code> 则是存储一个空 string 和一个空 vector 类型的对象。</p>
<p>也可以提供初始化式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author(<span class="string">"James"</span>, <span class="string">"Joyce"</span>);</span><br></pre></td></tr></table></figure>
<p>pair 类型使用起来较繁琐，可以使用 typedef 简化声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">"Marcel"</span>, <span class="string">"Proust"</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="pair_对象操作">pair 对象操作</h4><p>与其他标准库类型不同，对于 pair 类型，<strong>可以直接访问其数据成员，它的成员都是公有的</strong>。分别命名为 first 和 second。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook;</span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author == <span class="string">"Joyce"</span>)</span><br><span class="line">	firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure>
<p>除了构造函数之外，标准库还提供一个 make_pair 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="built_in">string</span> first, last;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123;</span><br><span class="line">	next_auth = make_pair(first, last);</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为成员是公有的，所以可以直接输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; next_auth.first &gt;&gt; next_auth.second) &#123;</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联容器">关联容器</h3><p>关联容器与顺序容器共享大部分的操作，但并不是全部。关联容器不支持 <strong>front, push_front, pop_front, back, push_back, pop_back</strong> 等操作。共享的包括：</p>
<ol>
<li><p>三种构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;</span><br><span class="line">C&lt;T&gt; c1(c2);</span><br><span class="line">C&lt;T&gt; c(begin, end);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算</p>
</li>
<li>begin，end，rbegin，rend</li>
<li>typedef。注意：对于 map 类型，<strong>value_type 的类型是 pair 类型。</strong></li>
<li>swap 和 赋值操作。<strong>但不提供 assign 函数</strong>。</li>
<li>clear，erase。<strong>关联容器 erase 操作返回 void 类型</strong>。</li>
<li>容器大小的操作。<strong>不支持 resize 操作</strong>。</li>
</ol>
<p>对于与顺序容器相同的操作，关联容器重新定义了这些操作的含义或返回类型，主要区别在于关联容器中使用了键。</p>
<blockquote>
<p>元素在关联容器中根据键的顺序排列。</p>
</blockquote>
<h3 id="map_类型">map 类型</h3><p>map 可以理解为 <strong>关联数组</strong>，但是通过键获取元素值，而不是位置。</p>
<h4 id="map_的定义">map 的定义</h4><p>要使用 map 需包含 map 头文件</p>
<table>
<thead>
<tr>
<th>map 的构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v=""> m;</k,></td>
<td>空 map 对象，键和值得类型分别为 k 和 v</td>
</tr>
<tr>
<td>map<k, v=""> m(m1)</k,></td>
<td>创建 m1 的副本</td>
</tr>
<tr>
<td>map<k, v=""> m(begin, end);</k,></td>
<td>创建 begin 至 end 范围内所有元素的副本</td>
</tr>
</tbody>
</table>
<p><strong>键类型的约束</strong></p>
<p>在使用关联容器时，<strong>它的键类型必须要有一个比较函数</strong>。所使用的比较函数必须在键类型上<strong>严格弱排序</strong>。所谓严格弱排序，可以理解为键类型数据上的“小于”关系，不能出现相互“小于”的情况。</p>
<blockquote>
<p>在实际应用中，键类型必须定义 &lt; 操作符，而且该操作符能正确的工作。</p>
</blockquote>
<h4 id="map_定义的类型">map 定义的类型</h4><p>map 对象是键-值对，每个元素分为两个部分：键和其关联的值。map 的 value_type 可以很清楚的表示这种情况，该类型是 pair 类型。</p>
<table>
<thead>
<tr>
<th>map 定义的类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v="">::key_type</k,></td>
<td>键的类型</td>
</tr>
<tr>
<td>map<k, v="">::mapped_type</k,></td>
<td>值的类型</td>
</tr>
<tr>
<td>map<k, v="">::value_type</k,></td>
<td>键-值的类型：pair类型。有 first 和 second 两个公有成员</td>
</tr>
</tbody>
</table>
<p>对 map 的迭代器解引用会产生一个 pair 类型值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h4 id="向_map_添加元素">向 map 添加元素</h4><p><strong>下标</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面程序会发生：</p>
<ol>
<li>在 <code>word_count</code> 中查找键为 Anna 的元素，没有找到；</li>
<li>将一个键为 Anna 的 pair 插入到 <code>word_count</code>，该 pair 的值为 (“Anna”, 0)。</li>
<li>读取新插入的元素，并将它赋值为 1.</li>
</ol>
<blockquote>
<p>故使用下标访问 map 中没有的元素会导致向该容器中添加一个新元素。</p>
</blockquote>
<p><strong>insert</strong></p>
<table>
<thead>
<tr>
<th>insert 操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.insert(p);</td>
<td>p 是 value_type 类型的值，如果 p.first 不存在，则插入 p 到 m，否则 m 保持不变。该函数返回一个 pair 对象，包含一个指向 p 的 map 的迭代器，和一个 bool 值。</td>
</tr>
<tr>
<td>m.insert(begin, end);</td>
<td>插入 begin 和 end 范围内的值。返回 void 类型</td>
</tr>
<tr>
<td>m.insert(iter, p)</td>
<td>如果 p.first 不在 m 中，则以 iter 为起点搜索 p 的存储位置。返回一个迭代器，指向新插入的 p。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<p><strong>insert 的返回值类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// use typedef</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret_type;</span><br><span class="line">ret_type ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<h4 id="查找_map_中的元素">查找 map 中的元素</h4><p>读取 map 中一个元素最简单的方法是下标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">int</span> occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>但是有个弊端：如果该键不在 map 中，则会插入之。</p>
<p>对于查找或读取元素，map 提供了两个操作： count 和 find。</p>
<ol>
<li>find： <code>m.find(key)</code>, 如果存在 key 索引的元素，返回指向该元素的迭代器，否则返回末端迭代器，即 end()；</li>
<li>count：<code>m.count(key)</code>,  返回 m 中 k 出现的次数；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (word_count.count(<span class="string">"Anna"</span>))</span><br><span class="line">	occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>这里对元素做了两次查询，在优化性能时可以考虑。find 则更适合查询元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"Anna"</span>);</span><br><span class="line"><span class="keyword">if</span> (it != word_count.end())</span><br><span class="line">	occurs = it-&gt;second;</span><br></pre></td></tr></table></figure>
<h4 id="从_map_删除元素">从 map 删除元素</h4><table>
<thead>
<tr>
<th>删除元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.erase(key)</td>
<td>删除键为 k 的元素。返回 size_type 类型的值，表示删除元素的个数</td>
</tr>
<tr>
<td>m.erase(iter)</td>
<td>删除迭代器 iter 指向的元素。iter 必须指向存在的元素，且不能等于 m.end()。返回 void 类型。</td>
</tr>
<tr>
<td>m.erase(begin, end)</td>
<td>删除范围内的元素。返回 void 类型。</td>
</tr>
</tbody>
</table>
<h3 id="set_类型">set 类型</h3><p>set 跟 map 不同，它只是单纯的键的集合。支持：</p>
<ol>
<li>insert</li>
<li>count，find</li>
<li>erase</li>
</ol>
<p>另外：</p>
<ol>
<li>不支持下标操作；</li>
<li>没有 mapped_type 类型；</li>
</ol>
<h4 id="set_类型的定义和使用">set 类型的定义和使用</h4><p>set 存放的是一系列唯一值的集合。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; endl; <span class="comment">// prints 20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; endl; <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向 set 添加元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; sset;</span><br><span class="line">sset.insert(<span class="string">"C.X.Q"</span>);</span><br><span class="line">sset.insert(<span class="string">"I L U"</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">iset.insert(ivec.begin(), ivec.end());</span><br></pre></td></tr></table></figure>
<p><strong>从 set 中获取元素</strong></p>
<p>set 不提供下标操作，只能使用 find 和 count 函数，count 函数的返回值只能是 1 或 0，因为里面的元素都是唯一的。正如不能修改 map 的键一样，set 中的键也是 const 类型。在获得指向 set 中某元素的迭代器后，只能对其做读操作，不能做写操作。</p>
<h3 id="multiset_和_multimap">multiset 和 multimap</h3><p>map 和 set 中键都是唯一的，而 multimap 和 multiset 类型则允许同一个键多次出现。也就是说每次调用 insert 都会添加一个元素，而 erase 则会删除跟该键有关的所有元素。</p>
<h4 id="multiset_和_multimap_中查找元素">multiset 和 multimap 中查找元素</h4><p>在 multimap 中，同一个键的所有元素都相邻存放。</p>
<p><strong>使用 find 和 count 函数</strong></p>
<p>count 返回某个键的出现的次数，find 返回的是一个迭代器，指向第一个正在查找的键的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"C.X.Q."</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::size_type sz_type;</span><br><span class="line">sz_type entrise = authors.count(search_item);</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter = authors.find(search_item);</span><br><span class="line"><span class="keyword">for</span> (sz_type cnt = <span class="number">0</span>; cnt != entrise; ++cnt, ++iter)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>另一种解决办法</strong></p>
<table>
<thead>
<tr>
<th>返回迭代器的关联操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.lower_cound(key)</td>
<td>返回一个迭代器，指向第一个不小于 key 的元素</td>
</tr>
<tr>
<td>m.upper_bound(key)</td>
<td>返回一个迭代器，指向第一个大于 key 的元素</td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>返回一个迭代器的 pair 对象<br>first 成员等价于 m.lower_bound(key),second 成员等价于 m.upper_bound(key)</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LaTeX: LLNCS v2.4]]></title>
    <link href="http://bluestein.github.io/2016/01/ML-LATEX-LLNCS/"/>
    <id>http://bluestein.github.io/2016/01/ML-LATEX-LLNCS/</id>
    <published>2016-01-09T02:02:00.000Z</published>
    <updated>2016-03-05T02:37:36.864Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/" target="_blank" rel="external">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="Invoke_LLNCS_class">Invoke LLNCS class</h4><p>LLNCS 只是标准 LATEX “article” class 的拓展版本，所以在文章中可以使用所有 “article” 的语法。如果要使用 LLNCS class，则使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;llncs&#125;</span><br><span class="line">%</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">&lt;Your contribution&gt;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文章已经用_LATEX_写好而未使用_LLNCS_格式的情况">文章已经用 LATEX 写好而未使用 LLNCS 格式的情况</h4><p>请不要使用任何会影响文档布局或格式的 LATEX 或 TEX命令（即像 <code>\textheight</code>, <code>\vspace</code>, <code>\headsep</code>, etc）。然而，有可能会有例外的情况下，可以使用一些。</p>
<h3 id="公式输入">公式输入</h3><p>公式会以您文章出现的顺序在右手边使用阿拉伯数字自动编号。当你的工作在数学模式时，都是用斜体字排版。有时候你需要插入非数学元素（例如单词或短语）。这种插入的代码应该使用 roman（即 <code>\mbox</code>）如下例所示： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125; </span><br><span class="line">\left(\frac&#123;a^&#123;<span class="number">2</span>&#125; + b^&#123;<span class="number">2</span>&#125;&#125;&#123;c^&#123;<span class="number">3</span>&#125;&#125; \right) = <span class="number">1</span> \quad</span><br><span class="line">\mbox&#123; <span class="keyword">if</span> &#125; c\neq <span class="number">0</span> \mbox&#123; and <span class="keyword">if</span> &#125; a,b,c\in \bbbr \enspace .</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<p><img src="/images/equation_sample.png" alt=""></p>
<p>如果你想在一个显示公式后立即开始新的段落，插入一个空白行，以产生所需的缩进。如果不插入一个空白行或代码 <code>\noindent</code> 会立即继续之前的文本而没有没有新的段落。</p>
<p>displayed 公式也使用相同的方式处理，其他普通文本则在结束本句前使用 <code>\enspace</code>。</p>
<p>注意括号的尺寸或其他分隔符必须保证是闭合的，使用下面命令可以保证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left( 或者 \left[ 和 \right) 或者 \right].</span><br></pre></td></tr></table></figure>
<h4 id="斜体和_Roman_体">斜体和 Roman 体</h4><ol>
<li>在公式中，一般使用斜体，但下标应使用 Roman 体而不是斜体。</li>
<li>确保一些物理标记使用 <code>\mathrm</code> 命令，如 Hz： <code>\mathrm{Hz}</code>。还有一些常用的数学函数，如 log，sin，exp，max和sup应该使用：<code>\log</code>，<code>\sin</code>，<code>\exp</code>，<code>\max</code> 和 <code>\sup</code>。</li>
<li>化学式应该使用 Roman 体，如： H2O。</li>
<li>熟悉的单词或句子不应使用斜体，如： et al., a priori, in situ, bremsstrahlung, eigenvalues。</li>
</ol>
<h3 id="How_to_Edit_Input_(Source)_File">How to Edit Input (Source) File</h3><h4 id="Headings">Headings</h4><p>标题中的所有单词应该都大写，除了连词、介词 (例如 on, of, by, and, or, but, from, with, without, under) 还有定冠词和不定冠词 (the, a, an) 除非他们出现在开头，否则均小写。公式的字母必须在文本内排版。</p>
<h4 id="大写和不大写">大写和不大写</h4><ol>
<li>下面情况均需大写：<ol>
<li>Headings。</li>
<li>文章中的缩写和表达式，如：  Fig(s)., Table(s), Sect(s)., Chap(s)., Theorem, Corollary, Deﬁnition etc. 跟数字一起使用时，如： Fig.3, Table 1, Theorem 2。</li>
</ol>
</li>
<li>下面情况不能大写：<ol>
<li>在文章中，当 ﬁgure(s), table(s), equation(s), theorem(s) 等词没有与编号一起使用时。</li>
<li>图表图例和表格标题，除非是缩写。</li>
</ol>
</li>
</ol>
<h4 id="词的缩写">词的缩写</h4><ol>
<li>下列词除非是出现在句子开头，否则在文章中应该使用缩写： Chap., Sect., Fig.。例如： The results are depicted in Fig.5. Figure 9 reveals that …. <blockquote>
<p>注： 公式一般使用括号跟数字代替，但出现在句子开头时需使用 “Equation”。 例如：Equation (14) is very important. However, (15) makes it clear that …. </p>
</blockquote>
</li>
<li>如果文章中有出现全局的缩写，应该在第一次出现的时候标明，如： Plurisubharmonic (PSH) Functions, Strong Optimization (SOPT) Problem.</li>
</ol>
<h3 id="文章的开头">文章的开头</h3><p>文章的标题（必须的）使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;&lt;Your contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>标题中所有单词应大写，除了连词、介词和不出现在开头的定冠词和不定冠词。标题没有结束标点。</p>
<p>如果是很长的标题，使用 <code>\\</code> 另起一行。</p>
<p>If you are to produce running heads for a speciﬁc volume the standard (of no such running heads) is overwritten with the [runningheads] option in the \documentclass line. For long titles that do not ﬁt in the single line of the running head a warning is generated. You can specify an abbreviated title for the running head on odd pages with the command：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\titlerunning&#123;&lt;Your abbreviated contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>There is also a possibility to change the text of the title that goes into the table of contents (that’s for volume editors only – there is no table of contents for a single contribution). For this use the command:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\toctitle&#123;&lt;Your changed title <span class="keyword">for</span> the table of contents&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>副标题使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\subtitle&#123;&lt;subtitle of your contribution&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>作者使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;&lt;author(s) name(s)&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>为每个作者或地址指定标号时，使用： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\inst&#123;&lt;no&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>超过一位作者的话，可以使用 <code>\and</code> 分隔。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是地址（学校，公司）了，多于一个地址，使用 <code>\and</code> 命令会自动编号，请确保跟作者顺序对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\institute&#123;&lt;name of an institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>\institute</code> 内使用 <code>\email{&lt;email address&gt;}</code> 可以提供email地址。如果在文章的任何地方需要注脚，请使用(immediately after the word where the footnote indicator should be placed)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\thanks&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>\thanks</code> 仅能出现在 <code>\title</code>, <code>\author</code> and <code>\institute</code>中. 如果有两个或更多的脚注使用 <code>\fnmsep</code> (i.e. footnote mark separator) 分隔.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\maketitle</span><br></pre></td></tr></table></figure>
<p>然后 heading 就结束了，到这一步为止，还不会产生任何文本。</p>
<p>接下来就是摘要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">&lt;Text of the summary of your article&gt;</span><br><span class="line">\end&#123;abstract&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### How to Code Your Text ###</span></span><br><span class="line"></span><br><span class="line">用以下代码的话，标题会自动编号：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">\section&#123;This is a First-Order Title&#125; </span><br><span class="line">\subsection&#123;This is a Second-Order Title&#125; </span><br><span class="line">\subsubsection&#123;This is a Third-Order Title.&#125; </span><br><span class="line">\paragraph&#123;This is a Fourth-Order Title.&#125;</span><br></pre></td></tr></table></figure>
<p><code>\section</code> and <code>\subsection</code> 没有 end punctuation。<code>\subsubsection</code> and <code>\paragraph</code> 需要在末尾 punctuate。 </p>
<p>另外，theorem-like environments 会自动编号，如果要使用计数器，只需指定 <code>envcountsame</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountsame]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>例如 <code>\begin{lema}</code>，第一次调用时会编号为1，再次调用编号为2，以此类推。如果需要每个 section 都重新计数，则指定为 <code>envcountreset</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountreset]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预定义的_Theorem-like_Environments">预定义的 Theorem-like Environments</h3><p>下面的标题随你选择：</p>
<ol>
<li><p>加粗并带斜体文本的 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;corollary&#125; &lt;text&gt; \end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; &lt;text&gt; \end&#123;lemma&#125; </span><br><span class="line">\begin&#123;proposition&#125; &lt;text&gt; \end&#123;proposition&#125; </span><br><span class="line">\begin&#123;theorem&#125; &lt;text&gt; \end&#123;theorem&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下的一般表现为斜体 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;proof&#125; &lt;text&gt; \qed \end&#123;proof&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这不编号，并且在结束前有一个吸引眼球的 square （即 <code>\qed</code>）。</p>
<ol>
<li>更多斜体和加粗体 run-in 标题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;definition&#125; &lt;text&gt; \end&#123;definition&#125;</span><br><span class="line">\begin&#123;example&#125; &lt;text&gt; \end&#123;example&#125; </span><br><span class="line">\begin&#123;exercise&#125; &lt;text&gt; \end&#123;exercise&#125; </span><br><span class="line">\begin&#123;note&#125; &lt;text&gt; \end&#123;note&#125; </span><br><span class="line">\begin&#123;problem&#125; &lt;text&gt; \end&#123;problem&#125; </span><br><span class="line">\begin&#123;question&#125; &lt;text&gt; \end&#123;question&#125; </span><br><span class="line">\begin&#123;remark&#125; &lt;text&gt; \end&#123;remark&#125; </span><br><span class="line">\begin&#123;solution&#125; &lt;text&gt; \end&#123;solution&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自定义的_Theorem-like_Environments">自定义的 Theorem-like Environments</h3><p>加强了标准的 <code>\newtheorem</code> 命令，得到两个新的命令 <code>\ spnewtheorem</code> 和 <code>\spnewtheorem*</code>，现在可以使用来定义新的语法。需要两个参数：type style 和 text style。type style 表示所出现的环境，text style 表示新环境的 text style。使用 <code>\ spnewtheorem</code> 的两种方法：</p>
<h4 id="第一种（推荐！）">第一种（推荐！）</h4><p>如果想与其他环境共享计数器，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;[&lt;num_like&gt;]&#123;&lt;caption&gt;&#125; &#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>[&lt;num_like&gt;]</code> 指定为想要共享的环境。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;mainth&#125;[theorem]&#123;Main Theorem&#125;&#123;\bfseries&#125;&#123;\itshape&#125; </span><br><span class="line">\begin&#123;theorem&#125; The early bird gets the worm. \end&#123;theorem&#125; </span><br><span class="line">\begin&#123;mainth&#125; The early worm gets eaten. \end&#123;mainth&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theorem <span class="number">3.</span> The early bird gets the worm. </span><br><span class="line">Main Theorem <span class="number">4.</span> The early worm gets eaten.</span><br></pre></td></tr></table></figure>
<h4 id="第二种">第二种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;[&lt;within&gt;]</span><br><span class="line">&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会定义一个名为 <code>&lt;env_name&gt;</code> 的环境，它以 <code>&lt;cap_font&gt;</code> 打印标题 <code>&lt;caption&gt;</code>， 它以 <code>&lt;body_font&gt;</code> 打印文本。在每个新 section 指定 <code>&lt;within&gt;</code> 时，会重新编号。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;joke&#125;&#123;Joke&#125;[subsection]&#123;\bfseries&#125;&#123;\rmfamily&#125;</span><br></pre></td></tr></table></figure>
<p>deﬁnes a new environment called joke which prints the caption Joke in boldface and the text in roman. The jokes are numbered starting from 1 at the beginning of every subsection with the number of the subsection preceding the number of the joke e.g. 7.2.1 for the ﬁrst joke in subsection 7.2.</p>
<h4 id="Unnumbered_Environments">Unnumbered Environments</h4><p>如果想要非编号环境，使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem*&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序代码">程序代码</h3><p>可以使用 verbatim 环境或者 LATEX 的 verbatim package。</p>
<p>文章示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;Hamiltonian Mechanics&#125;</span><br><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line">\institute&#123;Princeton University, Princeton NJ <span class="number">08544</span>, USA</span><br><span class="line">\and </span><br><span class="line">Universit\’&#123;e&#125; de Paris-Sud, </span><br><span class="line">Laboratoire d’Analyse Num\’&#123;e&#125;rique, B\^&#123;a&#125;timent <span class="number">425</span>,\\</span><br><span class="line">F-<span class="number">91405</span> Orsay Cedex, France&#125;</span><br><span class="line"></span><br><span class="line">\maketitle </span><br><span class="line">% </span><br><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">This paragraph shall summarize the contents of the paper in <span class="keyword">short</span> terms. </span><br><span class="line">\end&#123;abstract&#125; </span><br><span class="line">%</span><br><span class="line">\section&#123;Fixed-Period Problems: The Sublinear Case&#125; </span><br><span class="line">% </span><br><span class="line">With <span class="keyword">this</span> chapter, the preliminaries are over, and we begin the search <span class="keyword">for</span> periodic solutions \dots </span><br><span class="line">% </span><br><span class="line">\subsection&#123;Autonomous Systems&#125; </span><br><span class="line">% </span><br><span class="line">In <span class="keyword">this</span> section we will consider the <span class="keyword">case</span> when the Hamiltonian </span><br><span class="line">$H(x)$ \dots </span><br><span class="line">% </span><br><span class="line">\subsubsection*&#123;The General Case: Nontriviality.&#125; </span><br><span class="line">% </span><br><span class="line">We assume that $H$ is </span><br><span class="line">$\left(A_&#123;\infty&#125;, B_&#123;\infty&#125;\right)$-subqua\-dra\-tic </span><br><span class="line">at infinity, <span class="keyword">for</span> some constant \dots </span><br><span class="line">% </span><br><span class="line">\paragraph&#123;Notes and Comments.&#125; </span><br><span class="line">The first results on subharmonics were \dots </span><br><span class="line">% </span><br><span class="line">\begin&#123;proposition&#125;</span><br><span class="line">Assume $H’(<span class="number">0</span>)=<span class="number">0</span>$ and $ H(<span class="number">0</span>)=<span class="number">0</span>$. Set \dots </span><br><span class="line">\end&#123;proposition&#125; </span><br><span class="line">\begin&#123;proof&#125;[of proposition] </span><br><span class="line">Condition (<span class="number">8</span>) means that, <span class="keyword">for</span> every $\delta’&gt;\delta$, there is </span><br><span class="line">some $\varepsilon&gt;<span class="number">0</span>$ such that \dots \qed </span><br><span class="line">\end&#123;proof&#125; </span><br><span class="line">% </span><br><span class="line">\begin&#123;example&#125;[\rmfamily (External forcing)] </span><br><span class="line">Consider the system \dots </span><br><span class="line">\end&#123;example&#125; </span><br><span class="line">\begin&#123;corollary&#125; </span><br><span class="line">Assume $H$ is $C^&#123;<span class="number">2</span>&#125;$ and </span><br><span class="line">$\left(a_&#123;\infty&#125;, b_&#123;\infty&#125;\right)$-subquadratic </span><br><span class="line">at infinity. Let \dots </span><br><span class="line">\end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; </span><br><span class="line">Assume that $H$ is $C^&#123;<span class="number">2</span>&#125;$ on $\bbbr^&#123;<span class="number">2</span>n&#125;\backslash \&#123;<span class="number">0</span>\&#125;$ </span><br><span class="line">and that $H’’(x)$ is \dots </span><br><span class="line">\end&#123;lemma&#125; </span><br><span class="line">\begin&#123;theorem&#125;[(Ghoussoub-Preiss)] </span><br><span class="line">Let $X$ be a Banach Space and $\Phi:X\to\bbbr$ \dots</span><br><span class="line">\end&#123;theorem&#125; </span><br><span class="line">\begin&#123;definition&#125; </span><br><span class="line">We shall say that a $C^&#123;<span class="number">1</span>&#125;$ function $\Phi:X\to\bbbr$ </span><br><span class="line">satisfies \dots </span><br><span class="line">\end&#123;definition&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例如下图，或<a href="http://www.springer.com/computer/lncs/lncs+authors" target="_blank" rel="external">官网</a>下载查看</p>
<p><img src="/images/paper_sample.png" alt=""></p>
<h3 id="文本优化">文本优化</h3><table>
<thead>
<tr>
<th>文本优化</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\,</td>
<td>产生一个小型空格。例如在数字之间</td>
</tr>
<tr>
<td>—</td>
<td>产生一个横杠。前后无空格</td>
</tr>
<tr>
<td>&nbsp;—&nbsp;</td>
<td>产生一个横杠。前后各一空格</td>
</tr>
<tr>
<td>-</td>
<td>连字符。前后无空格</td>
</tr>
<tr>
<td>$-$</td>
<td>负号。只在文本中使用</td>
</tr>
</tbody>
</table>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>\,$^&#123;\circ&#125;$C etc., </span><br><span class="line">Dr h.\,c.\,Rockefellar-Smith \dots </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>\,km and Prof.\,Dr Mallory \dots </span><br><span class="line"><span class="number">1950</span>--<span class="number">1985</span> \dots </span><br><span class="line"><span class="keyword">this</span> -- written on a computer -- is now printed </span><br><span class="line">$-<span class="number">30</span>$\,K \dots</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>◦C etc., Dr h.c.Rockefellar-Smith ... </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>km and Prof.Dr Mallory ... </span><br><span class="line"><span class="number">1950</span>–<span class="number">1985</span> ... </span><br><span class="line"><span class="keyword">this</span> – written on a computer – is now printed </span><br><span class="line">−<span class="number">30</span>K ...</span><br></pre></td></tr></table></figure>
<h3 id="特殊字体">特殊字体</h3><p>普通的字体类型（Roman）不需要代码。斜体 (<code>{\em &lt;text&gt;}</code> 或 <code>\emph{&lt;text&gt;}</code>)，如果需要，黑体用于强调：</p>
<table>
<thead>
<tr>
<th>特殊字体</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{\itshape Text}</code></td>
<td>斜体文本</td>
</tr>
<tr>
<td><code>{\em &lt;text&gt;}</code></td>
<td>强调的文本</td>
</tr>
<tr>
<td><code>{\bfseries Text}</code></td>
<td>重要文本</td>
</tr>
<tr>
<td><code>\vec{Symbol}</code></td>
<td>向量只能出现在 math mode。如 <code>$\vec{A \times B\cdot C}</code> 得到 <code>A×B ·C</code></td>
</tr>
</tbody>
</table>
<h3 id="Footnotes">Footnotes</h3><p>注脚应该被包含在下面代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\footnote&#123;Text&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote\footnote&#123;The footnote is automatically numbered.&#125; and text continues ...</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote^<span class="number">4</span> and text continues ...</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125; </span><br><span class="line">  \item First item </span><br><span class="line">  \item Second item </span><br><span class="line">  \begin&#123;enumerate&#125; </span><br><span class="line">    \item First nested item </span><br><span class="line">    \item Second nested item </span><br><span class="line">  \end&#123;enumerate&#125; \item </span><br><span class="line">  Third item </span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First item </span><br><span class="line">2. 2. Second item </span><br><span class="line">   (a) First nested item</span><br><span class="line">   (b) Second nested item </span><br><span class="line">3. Third item</span><br></pre></td></tr></table></figure>
<h3 id="插图">插图</h3><p>图片应该插入到第一次提到该图片的段落后（不是段落中），它会被自动编号。图片应该是 PostScript 文件——最好是 EPS 数据，通过 epsfig package 生成。</p>
<p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;x cm&#125; </span><br><span class="line">\caption[ ]&#123;...text of caption...&#125; (Do type [ ]) </span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><code>x</code>表示图片的高度。 </p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;<span class="number">2.5</span>cm&#125; </span><br><span class="line">\caption&#123;This is the caption of the figure displaying a white eagle and a white horse on a snow field&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多请参见 LATEX 文档 p. 26 ff. 和 p. 204</p>
</blockquote>
<h3 id="表格">表格</h3><h4 id="使用_LATEX_编写表格">使用 LATEX 编写表格</h4><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125; </span><br><span class="line">\caption&#123;Critical $N$ values&#125; </span><br><span class="line">\begin&#123;tabular&#125;&#123;llllll&#125; </span><br><span class="line">\hline\noalign&#123;\smallskip&#125;</span><br><span class="line">$&#123;\mathrm M&#125;_\odot$ &amp; $\beta_&#123;<span class="number">0</span>&#125;$ &amp; $T_&#123;\mathrm c6&#125;$ &amp; $\gamma$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm L&#125;$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm&#123;Te&#125;&#125;$\\ </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">\hline </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">  <span class="number">30</span> &amp; <span class="number">0.82</span> &amp; <span class="number">38.4</span> &amp; <span class="number">35.7</span> &amp; <span class="number">154</span> &amp; <span class="number">320</span> \\ </span><br><span class="line">  <span class="number">60</span> &amp; <span class="number">0.67</span> &amp; <span class="number">42.1</span> &amp; <span class="number">34.7</span> &amp; <span class="number">138</span> &amp; <span class="number">340</span> \\ </span><br><span class="line">  <span class="number">120</span> &amp; <span class="number">0.52</span> &amp; <span class="number">45.1</span> &amp; <span class="number">34.0</span> &amp; <span class="number">124</span> &amp; <span class="number">370</span> \\ </span><br><span class="line">\hline </span><br><span class="line">\end&#123;tabular&#125; </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="/images/table_sample.png" alt=""></p>
<h4 id="不使用_LATEX">不使用 LATEX</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\caption&#123;text of your caption&#125; </span><br><span class="line">\vspace&#123;x cm&#125; % the actual height needed <span class="keyword">for</span> your table </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Signs_and_Characters">Signs and Characters</h4><p>更多请参见原文档和 LATEX 官方文档 pp.41 ff.</p>
<h4 id="参考文献">参考文献</h4><p>有三种参考文献模式：number only，letter-number， 或 author-year。更多请参见 LATEX 官方文档 p. 71.<br>LLNCS 有一种特殊的 BIBTEX 格式，使用class： splncs.bst。调用代码 <code>\bibliographystyle{splncs}</code>。<br>如果打算使用 author BIBTEX style，请指定 <code>[oribibl]</code> 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[oribibl]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Letter-Number_或_Number_Only">Letter-Number 或 Number Only</h4><p>在文章中使用 <code>\cite</code> 命令来引用文章，会得到形如：[1]，[E1, S2], [P1] 中之一的格式，这取决于  thebibliography 环境中 <code>\bibitem</code> 的使用。</p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;[MT1]&#125; </span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[CE1]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>会产生类似的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CE1] Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">[CE2] Clarke, F., Ekeland, I.: Solutions p´eriodiques, du p´eriode donn´ee, des ´equations hamiltoniennes. Note CRAS Paris <span class="number">287</span>, <span class="number">1013</span>–<span class="number">1015</span> (<span class="number">1978</span>)</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of \cite&#123;clar:eke&#125;;</span><br></pre></td></tr></table></figure>
<p>会得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of [CE1];</span><br></pre></td></tr></table></figure>
<p><strong>Number-Only System</strong></p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;<span class="number">1</span>&#125; </span><br><span class="line">\bibitem &#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\cite&#123;n1,n3,n2,n3,n4,n5,foo,n1,n2,n3,?,n4,n5&#125;</span><br></pre></td></tr></table></figure>
<p>能够得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>-<span class="number">5</span>,foo,<span class="number">1</span>-<span class="number">3</span>,?,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Author-Year_System">Author-Year System</h4><p>效果就像这样：<code>(Smith 1970,1980),(Ekelandetal.1985,Theorem2),(JonesandJffe 1986; Farrow 1988, Chap.2)</code>。如果名字作为句子的一部分，那么括号内就可能只出现年份，如，<code>Ekeland et al. (1985, Sect.2.1)</code>。</p>
<p>如果有几个文章属于同一（多）个作者，引用时应列在适当的顺序，表示如下：</p>
<ol>
<li>一个作者：按文章时间排序；</li>
<li>相同的合作作者：按文章时间排序；</li>
<li>和不同的合作作者：按合作作者名字进行字母排序；</li>
</ol>
<p>如果，有多个同样的作者同样的时间的文章，用 “a”, “b”, “c”, etc 区分。</p>
<p><strong>How to Code Author-Year System</strong></p>
<p>要使用这个系统，则需指定 <code>[citeauthoryear]</code> 参数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[citeauthoryear]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;&#125; % (<span class="keyword">do</span> not forget &#123;&#125;)</span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[<span class="number">1982</span>]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>产生样例：<br>cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>)</span><br></pre></td></tr></table></figure></p>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(\cite&#123;clar:eke&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>产生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(<span class="number">1982</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>END. </p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="LLNCS" scheme="http://bluestein.github.io/tags/LLNCS/"/>
    
      <category term="LaTeX" scheme="http://bluestein.github.io/tags/LaTeX/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="LaTex" scheme="http://bluestein.github.io/categories/Odds-Ends/LaTex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[顺序容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-sequential_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-sequential_container/</id>
    <published>2016-01-02T10:46:49.000Z</published>
    <updated>2016-03-05T02:37:36.895Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>顺序容器</strong></td>
<td>-</td>
</tr>
<tr>
<td>vector</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td>list</td>
<td>支持快速插入删除</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列</td>
</tr>
<tr>
<td><strong>顺序容器适配器</strong></td>
<td>-</td>
</tr>
<tr>
<td>stack</td>
<td>后进先出（LIFO）</td>
</tr>
<tr>
<td>queue</td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td>priority_queue</td>
<td>有优先级管理的队列</td>
</tr>
</tbody>
</table>
<h3 id="顺序容器的定义">顺序容器的定义</h3><p>首先必须包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>所有顺序容器都是类模板</strong>。要定义某种特殊的容器，必须在容器名后添加一对尖括号，尖括号内提供容器将要存放元素的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="built_in">deque</span>&lt;Sales_item&gt; item;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有容器都有默认构造函数，该构造函数不带任何参数</p>
</blockquote>
<h4 id="初始化">初始化</h4><p>除了默认构造函数，容器类型还提供了其他的构造函数，可以指定其元素的初值</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C<t> c;</t></td>
<td>创建名为 c 的容器。<br>C 为容器名，如 vector。<br>T为元素类型，如string，int。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c2(c1)</td>
<td>创建容器 c1 的副本。<br>c2 和 c1 必须是相同类型的容器，并存放相同类型的元素。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(begin, end)</td>
<td>使用迭代器 begin 和 end 范围内的元素创建 c。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(n, t)</td>
<td>用 n 个值为 t 的元素创建容器。<br>t 必须与容器存放的类型匹配，或者可以转化为该类型的值。<br><strong>只适用于顺序容器</strong></td>
</tr>
<tr>
<td>C c(n)</td>
<td>创建 n 个默认初始值的容器。<br><strong>只适用于顺序容器</strong></td>
</tr>
</tbody>
</table>
<p><strong>初始化为另一个容器的副本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(ivec1); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(ivec1); <span class="comment">// error: ivec is not list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dvec(ivec); <span class="comment">// error: ivec holds int not double</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化为另一容器的部分元素</strong></p>
<p>允许通过传递一对迭代器来初始化容器。使用迭代器时，不需要容器类型相同，容器内的元素类型可以不同，只要相容即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator mid = svec.begin() + svec.size() / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; front(svec.begin(), mid);</span><br></pre></td></tr></table></figure>
<p>因为指针就是迭代器，所以可以用数组中的值对容器进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *words1[] = &#123;<span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(words1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; words2(words1, words1 + sz);</span><br></pre></td></tr></table></figure>
<p><strong>初始化指定数目的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>都是 10 个元素的 list，<code>slist</code> 的每个值初始化为 <strong>hi</strong>， <code>ilist</code> 每个值初始化为 <strong>0</strong>。</p>
<blockquote>
<p>只有当元素类型有默认构造函数时才可以使用 <code>C c(n)</code> 的方式初始化。例如上面的 int 默认初始化为 0。</p>
</blockquote>
<p><strong>容器的容器</strong></p>
<p>支持容器的容器，不过要注意使用空格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; lines; <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; lines; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>否则被认为是右移操作。</p>
<h3 id="迭代器和迭代器的范围">迭代器和迭代器的范围</h3><p>标准库为所有容器类提供的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>解引用</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>解引用，获取指定名为 member 的成员，等价于 (*iter).member</td>
</tr>
<tr>
<td>++iter<br>iter++</td>
<td>使iter指向后一个元素</td>
</tr>
<tr>
<td>–iter<br>iter–</td>
<td>使iter指向前一个元素</td>
</tr>
<tr>
<td>iter1 == iter2<br>iter1 != iter2</td>
<td>比较是否相等</td>
</tr>
</tbody>
</table>
<h4 id="vector,_deque额外的操作">vector, deque额外的操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n<br>iter - n</td>
<td>使iter指向后（前） n 个元素</td>
</tr>
<tr>
<td>iter1 += iter2<br>iter1 -= iter2<br>iter1 - iter2</td>
<td>迭代器运算</td>
</tr>
<tr>
<td>&gt;, &gt;=, &lt;, &lt;=</td>
<td>关系操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只适用于 vector 和 deque</p>
</blockquote>
<h3 id="顺序容器的操作">顺序容器的操作</h3><p>每种顺序容器都有以下操作</p>
<ol>
<li>向容器添加元素</li>
<li>删除元素</li>
<li>设置容器大小</li>
<li>获取容器第一个或最后一个元素（如果有的话）</li>
</ol>
<h4 id="为容器定义的类型别名">为容器定义的类型别名</h4><table>
<thead>
<tr>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>无符号整型，足以存储此容器类型的最大可能长度</td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器</td>
</tr>
<tr>
<td>const_iterator</td>
<td>只读类型迭代器</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>逆序寻址的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>只读逆序寻址的迭代器</td>
</tr>
<tr>
<td>difference_type</td>
<td>足够存储两迭代器差值的有符号整型，可为负值</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型，是 value_type&amp; 的同义词</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的常量左值类型，等价于 const value_type&amp;</td>
</tr>
</tbody>
</table>
<h4 id="begin_和_end_成员">begin 和 end 成员</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.begin()</td>
<td>返回一个迭代器，指向容器的第一个元素</td>
</tr>
<tr>
<td>c.end()</td>
<td>返回一个迭代器，指向容器最后一个元素的后面一个位置</td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>逆序迭代器，指向容器的最后一个元素</td>
</tr>
<tr>
<td>c.rend()</td>
<td>返回一个逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
</tbody>
</table>
<h4 id="添加元素">添加元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)</td>
<td>在容器尾部添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.push_front(t)</td>
<td>在容器前端添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, t)</td>
<td>在迭代器p所指元素的前面插入一个值为 t 的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p, n, t)</td>
<td>在迭代器p所指元素的前面插入 n 个值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, begin, end)</td>
<td>在迭代器p所指元素的前面插入迭代器 begin 和 end 范围内的元素，返回 void 类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>迭代器可能会失效。指向新加入元素后面的那个元素的迭代器会失效</p>
</blockquote>
<h4 id="关系操作符">关系操作符</h4><p>要使用类型相同的进行比较</p>
<ol>
<li>如果两容器有相同长度并且所有元素相等，则两个容器相等；</li>
<li>如果两容器有不同长度，但较短容器的元素等于较长容器的子序列，则短容器小于长容器；</li>
<li>如果不存在子序列，则比较第一个不同的元素；</li>
</ol>
<h4 id="容器大小">容器大小</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.size()</td>
<td>返回容器 c 中的元素个数，类型为 c::size_type</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>最多可容纳个数</td>
</tr>
<tr>
<td>c.empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>c.resize(n)</td>
<td>调整 c 的大小，容量为 n</td>
</tr>
<tr>
<td>c.resize(n, t</td>
<td>调整 c 的大小，容量为 n，所有新添加的元素值为 t</td>
</tr>
</tbody>
</table>
<h4 id="访问元素">访问元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回 c 的最后一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回 c 的第一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
<tr>
<td>c.at(n)</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
</tbody>
</table>
<p>back 和 front 同样可以用 end 和 begin 迭代器的解引用完成。</p>
<h4 id="删除元素">删除元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器 p 所指元素。<br>返回被删除元素的后一个位置，或最后一个元素的下一个位置</td>
</tr>
<tr>
<td>c.erase(begin, end)</td>
<td>不越界的情况下，删除 begin 和 end 范围内的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 内所有元素，返回 void</td>
</tr>
<tr>
<td>c.pop_back()</td>
<td>删除最后一个元素，返回 void</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除第一个元素，返回 void<br><strong>只适用于 list 和 deque 类型</strong></td>
</tr>
</tbody>
</table>
<h4 id="赋值和交换">赋值和交换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>将 c2 的内容赋值给 c1。会删除 c1 的内容</td>
</tr>
<tr>
<td>c1.swap(c2)</td>
<td>交换 c1 和 c2 的内容</td>
</tr>
<tr>
<td>c.assign(begin, end)</td>
<td>重设 c，把 begin 和 end 范围内的元素赋给 c</td>
</tr>
<tr>
<td>c.assign(n, t)</td>
<td>重设 c 为 n 个值为 t 的元素</td>
</tr>
</tbody>
</table>
<p>assign 会删除原容器中的元素，然后将所指定的新元素插入到该容器中。如果两个容器类型相同，就可以使用赋值操作符将一个容器赋值给另一个容器。如果在不同容器中，元素类型不同但相互兼容，那么必须使用 assign 函数。</p>
<h3 id="vector容器的自增长">vector容器的自增长</h3><p>vector 以连续的方式存储每一个元素，一个挨着一个。所以当在超过预申请内存时再插入元素时，必须重新申请空间，然后将旧元素赋值到新空间中。此时就要用到 capacity 和 reserve，capacity 表示在必须重新非配空间之前可以存储元素的个数，一般由标准库定义，至少等于容器的大小，但一般来说会更大一些；而 reserve 表示人工预留存储空间（类似于数组大小的声明），当使用过程中超过人工预留空间后，vector会自己重新分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.push_back(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="容器的选择">容器的选择</h3><p>元素是否连续存储会显著的影响：</p>
<ol>
<li>在容器内部位置添加或删除元素；</li>
<li>执行元素的随机访问的代价；</li>
</ol>
<h4 id="插入操作影响容器的选择">插入操作影响容器的选择</h4><ol>
<li>list 存储在不连续的空间，允许向前向后逐个遍历，<strong>在任何位置可以高效的 insert 和 erase</strong>。不过它不支持随机访问，必须遍历涉及到的元素。</li>
<li>vector 存储在连续区域，除了在尾部插入（删除），其他任何位置插入（删除）时都必须移动其后面的元素。</li>
<li>deque 更加复杂，在两段插入和删除都非常快，但在内部差入或删除时代价会更高。它还同时提供了 list 和 vector 的性质：<ol>
<li>与 vector 一样，在容器内部 insert 和 erase 效率较低；</li>
<li>不同于 vector，deque 可以高效的实现首尾的 insert 和 erase；</li>
<li>deque 支持所有元素的随机访问；</li>
<li>deque 首尾插入不会使任何迭代器失效，而在首尾删除元素时，会使指向被删除元素的迭代器失效。在其他位置插入或删除都会使所有迭代器失效；</li>
</ol>
</li>
</ol>
<h4 id="访问影响">访问影响</h4><p>vector 和 deque 都支持高效的随机访问，而 list 只能顺序的跟随指针，一直遍历。</p>
<h4 id="建议">建议</h4><ol>
<li>要求随机访问，使用 vector 或 deque；</li>
<li>要求内部插入（删除）元素，选择 list；</li>
<li>如果在首部或尾部插入（删除），则选择 deque；</li>
<li>如果只需在输入时在容器中间插入元素，然后需要随机访问。可以考虑输入时存放到 list 中，接着对其排序，然后将其复制到 vector 中；</li>
<li>如果既需要中间插入元素又要随机访问，则选择容器时，考虑下面两种操作的相对代价：<ol>
<li>随机访问 list 的代价；</li>
<li>在 vector 或 deque 内部插入（删除）元素的代价；</li>
</ol>
</li>
</ol>
<h3 id="深入string类型">深入string类型</h3><p>除了前面用过的操作外，string 类型还支持大多数顺序容器操作。在某些方面可将 string 类型视为字符容器，操作也与 vector 类似，不过 string 不支持以栈方式操作容器：即 string 不能使用 front, back, pop_back等操作。下表扼要的介绍了一些 string 的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s;</td>
<td>定义一个空对象</td>
</tr>
<tr>
<td>string s(cp);</td>
<td>定义一个对象，并用 cp 指向的 c 风格的字符串初始化</td>
</tr>
<tr>
<td>string s2(s1);</td>
<td>初始化为s1的副本</td>
</tr>
<tr>
<td>is &gt;&gt; s;</td>
<td>从输入流 is 中读取一个以空白符分隔的字符串，存入 s</td>
</tr>
<tr>
<td>os &lt;&lt; s;</td>
<td>将 s 写到输出流 os</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从输入流 is 中读取一行字符，写入 s</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>将 s1 和 s2 串接起来，产生一个新的 string 对象</td>
</tr>
<tr>
<td>s1 += s2</td>
<td>将 s2 拼接到 s1 后面</td>
</tr>
<tr>
<td>关系操作符</td>
<td>相等运算（== 和 !=）及关系运算（&lt;, &lt;=, &gt;, &gt;=）都可用于 string 对象的比较。等效于（区分大小写）字典次序的比较</td>
</tr>
</tbody>
</table>
<p>string 支持的容器操作有：</p>
<ol>
<li>迭代器类型；</li>
<li>容器的构造函数（参考<a href="#初始化">前面</a>），但是不包含只需一个长度参数的构造函数；</li>
<li>跟 vector 一样的添加元素的操作。无论是 vector 还是 string 都不支持 push_front；</li>
<li>支持长度操作。resize, size, reserve 等；</li>
<li>支持下标和 at 操作；</li>
<li>支持 begin 和 end 操作；</li>
<li>支持 erase 和 clear 操作。但是不支持 pop_back 或 pop_front 操作；</li>
<li>支持<a href="#赋值和交换">前面</a>表中的赋值操作；</li>
<li>与vector容器一样，string也是连续存储的，因此也支持 capacity 和 reserve 操作；</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hey!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::iterator iter = s.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != s.end()) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造_string_对象">构造 string 对象</h4><p>string 几乎支持<a href="#初始化">前面</a>所有的构造函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2(5, 'a'); // s2 == "aaaaa"</span><br><span class="line">string s3(s2); // s3 是 s2 的副本</span><br><span class="line">string s4(s3.begin(),</span><br><span class="line">		s3.begin() + s3.size() / 2); // s4 == "aa"</span><br><span class="line"></span><br><span class="line">char *cp = "hey!";</span><br><span class="line">char carr[] = "Hello!";</span><br><span class="line">char no_null[] = &#123;'H', 'i'&#125;;</span><br><span class="line">string ss1(cp); // ss1 == "hey!"</span><br><span class="line">string ss2(carr,5); // ss2 == "Hello"</span><br><span class="line">string ss3(carr + 2, 3); // ss3 == "llo"</span><br><span class="line">string ss4(no_null); // runtime_error: 没有 null 结束符</span><br><span class="line">string ss5(no_null, 2); // ok</span><br></pre></td></tr></table></figure>
<p>构造 string 对象的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td>创建用 cp 所指数组的前 n 个字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos)</td>
<td>创建从 s1 的 pos 位置开始的字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos, len)</td>
<td>创建 s1 的 pos 位置开始长为 len 的字符的副本</td>
</tr>
</tbody>
</table>
<blockquote>
<p>n, len, pos 都是 unsigned 值。</p>
</blockquote>
<h4 id="修改string对象">修改string对象</h4><p><strong>与容器共有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, t)</td>
<td>在迭代器 pos 前插入一个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, n, t)</td>
<td>在迭代器 pos 前插入 n 个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, begin, end)</td>
<td>在迭代器 pos 前插入迭代器 begin 到 end 之间的值</td>
</tr>
<tr>
<td>s.assign(begin, end)</td>
<td>用迭代器 begin 到 end 之间的值重新初始化 s</td>
</tr>
<tr>
<td>s.assign(n, t)</td>
<td>用 n 个 t 值重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos)</td>
<td>删除迭代器 pos 所指元素</td>
</tr>
<tr>
<td>s.erase(begin, end)</td>
<td>删除迭代器 begin 到 end 之间的值</td>
</tr>
</tbody>
</table>
<p><strong>string 特有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, n, c)</td>
<td>在下标 pos 前插入 n 个值为 c 的字符</td>
</tr>
<tr>
<td>s.insert(pos, s1)</td>
<td>在下标 pos 前插入一个 s1 的副本</td>
</tr>
<tr>
<td>s.insert(pos, s1, pos1, len)</td>
<td>在下标 pos 前插入 s1 中从 pos1 开始长为 len 的子字符串</td>
</tr>
<tr>
<td>s.insert(pos, cp, len)</td>
<td>在下标 pos 前插入 cp 所指的数组前 n 个字符</td>
</tr>
<tr>
<td>s.insert(pos, cp)</td>
<td>在下标 pos 前插入 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>s.assign(s1)</td>
<td>用 s1 重新初始化 s</td>
</tr>
<tr>
<td>s.assign(s1, pos1, len)</td>
<td>用 s1 中下标 pos1 开始长为 len 的子串重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp, len)</td>
<td>用 cp 所指的数组前 len 个元素重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp)</td>
<td>用 cp 所指以 null 结束的字符数组重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除从下标 pos 开始 len 个字符</td>
</tr>
</tbody>
</table>
<h3 id="只适用于_string_的操作">只适用于 string 的操作</h3><ol>
<li>substr 函数；</li>
<li>append 和 replace</li>
<li>find</li>
</ol>
<h4 id="substr">substr</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos, n)</td>
<td>返回从 pos 开始的 n 个字符</td>
</tr>
<tr>
<td>s.substr(pos)</td>
<td>返回从位置 pos 开始到结尾的字符</td>
</tr>
<tr>
<td>s.substr()</td>
<td>返回 s 的副本</td>
</tr>
</tbody>
</table>
<h4 id="append_和_replace">append 和 replace</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.append(args)</td>
<td>将 args 拼接在 s 后。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(pos, len, args)</td>
<td>删除 pos 开始的 len 个字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(begin, end, args)</td>
<td>删除 begin 到 end 之间的字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1</td>
<td>字符串 s1</td>
</tr>
<tr>
<td>s1, pos1, len1</td>
<td>s1 子串</td>
</tr>
<tr>
<td>cp</td>
<td>cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, len1</td>
<td>cp 所指以 null 结束的字符数组前 len1 个元素</td>
</tr>
<tr>
<td>n, c</td>
<td>n 个 字符 c</td>
</tr>
<tr>
<td>begin1, end1</td>
<td>迭代器 begin1 和 end1 间的字符</td>
</tr>
</tbody>
</table>
<h4 id="find">find</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找 s 中 args 第一次出现</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找 s 中 args 最后一次出现</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>查找 s 中 args 的任意字符第一次出现</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>查找 s 中 args 的任意字符最后一次出现</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找 s 中第一个不属于 args 的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>查找 s 中最后一个不属于 args 的字符</td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c, pos</td>
<td>在 s 中从 pos 开始查找字符 c</td>
</tr>
<tr>
<td>s1, pos</td>
<td>在 s 中从 pos 开始查找 string 对象 s1</td>
</tr>
<tr>
<td>cp, pos</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, pos, n</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组前 n 个字符</td>
</tr>
</tbody>
</table>
<h4 id="string_对象的比较">string 对象的比较</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.compare(s1)</td>
<td>s 与 s1比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1, pos1, n1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 从 pos1 开始长为 n1 的子串比较</td>
</tr>
<tr>
<td>s.compare(cp)</td>
<td>s 与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp)</td>
<td>s 从 pos 开始长为 n 的子串与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp, n1)</td>
<td>s  从 pos 开始长为 n 的子串与 cp 所指数组前 n1 的子串比较</td>
</tr>
</tbody>
</table>
<h3 id="容器适配器">容器适配器</h3><p>标准库提供三种顺序容器适配器：queue, priority_queue, stack。</p>
<p><strong>初始化</strong></p>
<p>肯定需要包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deq 是 deque&lt;int&gt; 类型</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk(deq);</span><br></pre></td></tr></table></figure>
<p><strong>覆盖适配器的基础容器类型</strong></p>
<p>默认情况下，stack 和 queue 都基于 deque 实现，priority_queue 则基于 vector 实现。通过将一个顺序容器指定为适配器的第二个实参，可以覆盖基础容器类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on vector</span></span><br><span class="line"><span class="built_in">stack</span>&lt; <span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str_stk;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两个相同类型的适配器可以做关系运算，第一个不对等的元素决定大于或小于关系。</p>
</blockquote>
<h4 id="栈适配器">栈适配器</h4><p>栈的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stk.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>stk.size()</td>
<td>返回栈中元素个数</td>
</tr>
<tr>
<td>stk.pop()</td>
<td>删除栈顶元素，但不返回其值</td>
</tr>
<tr>
<td>stk.top()</td>
<td>返回栈顶元素，但不删除其值</td>
</tr>
<tr>
<td>stk.push(item)</td>
<td>将 item 压入栈</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;::size_type sz = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; istk;</span><br><span class="line">	<span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.size() != sz)</span><br><span class="line">	&#123;</span><br><span class="line">		istk.push(ix++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> error_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = istk.top();</span><br><span class="line">		<span class="keyword">if</span> (value != --ix)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; <span class="string">"expected "</span> &lt;&lt; ix &lt;&lt; <span class="string">"recieved "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">			++error_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		istk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"errors: "</span> &lt;&lt; error_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">errors: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="queue_和_priority_queue">queue 和 priority_queue</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>q.size()</td>
<td>返回队列中元素个数</td>
</tr>
<tr>
<td>q.pop()</td>
<td>删除队首元素，但不返回其值</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回队首元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.back()</td>
<td>返回队尾元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.top()</td>
<td>返回优先级最高的元素，但不删除其值。<strong>只适用于priority_queue</strong></td>
</tr>
<tr>
<td>q.push(item)</td>
<td>queue： 将 item 压入队尾<br>priority_queue：基于优先级压入队列</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex9.9]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-11/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-11/</id>
    <published>2016-01-02T06:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.942Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s[] = &#123; <span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span> &#125;;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(s, s + <span class="number">3</span>); </span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = --slist.end();</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cnt &lt; sz) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (++cnt &lt; sz) &#123;</span><br><span class="line">			--iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hey</span></span><br><span class="line"><span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IO库]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-IO-library/"/>
    <id>http://bluestein.github.io/2016/01/cpp-IO-library/</id>
    <published>2016-01-01T07:11:49.000Z</published>
    <updated>2016-03-05T02:40:48.439Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br>ostream 写到流中去；<br>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br>ofstream 写到文件对象中去，由 ostream 派生而来；<br>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><strong>国际字符的支持</strong></p>
<p>前面所说的流类（stream class）读写均是 char 类型组成的流，不过，标准库还定义了一套支持 wchar_t 的类型。每个类加上 <strong>w</strong> 前缀，表示宽字符，如 wostream, wistream, wiostream。</p>
<p><strong>IO 对象不可复制或赋值</strong></p>
<p>处于一些原因，标准库不允许赋值或复制操作，原因在后面阐明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// function func: parameter is copied</span></span><br><span class="line"><span class="function">ofstream <span class="title">func</span><span class="params">(ofstream)</span></span>;</span><br><span class="line">out2 = func(out2); <span class="comment">//error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure>
<ol>
<li>由于不能复制，因此不能存储在 vector 等容器中</li>
<li>形参或返回类型也不能为流类型。如果需要传递或返回 IO 类型，则必须使用<strong>指针或引用</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream &amp;<span class="title">func</span><span class="params">(ofstream&amp;)</span></span>; <span class="comment">// ok: takes a reference, no copy</span></span><br><span class="line"><span class="keyword">while</span> (func(out2)) &#123; <span class="comment">/*...*/</span> &#125; <span class="comment">// ok: pass reference to out2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="条件状态">条件状态</h3><p>IO 标准库管理一系列的<strong>条件状态（condition state）</strong>成员，用来标记给定的 IO 对象是否处于可用状态，或者碰到了哪种特定的错误。</p>
<table>
<thead>
<tr>
<th>IO 标准库的条件状态</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm::iostate</td>
<td>机器相关的整型名，由各个 iostream 类定义，用于定义条件状态</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>strm::iostate类型的值，用于指出被破坏的流</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>strm::iostate类型的值，用于指出失败的 IO 操作</td>
</tr>
<tr>
<td>strm::eofbit</td>
<td>strm::iostate类型的值，用于指出流已经达到文件的结束符</td>
</tr>
<tr>
<td>s.eof()</td>
<td>如果设置了流 s 的 eofbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>如果设置了流 s 的 failbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>如果设置了流 s 的 badbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>如果设置了流 s 处于有效状态，该函数返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流 s 的所有状态值重设为有效状态</td>
</tr>
<tr>
<td>s.clear(flag)</td>
<td>将流 s 中某个指定的条件状态设置为有效。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.setstate(flag)</td>
<td>给流 s 添加指定条件。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流 s 当前条件。返回值类型为 strm::iostate</td>
</tr>
</tbody>
</table>
<p>流的状态由 bad、fail、eof 或 good 操作揭示。badbit 标志着系统级的错误，如无法读写的错误。其他都设置了 failbit 标志，通常可修正。</p>
<p><strong>流状态的查询和控制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="comment">// read cin and test only for EOF; loop is executed even if there are IO failures</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ival, !<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"IO stream corrupted"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bad data, try again"</span>;</span><br><span class="line">		<span class="built_in">cin</span>.clear(istream::failbit);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件状态的访问</strong></p>
<p>rdstate 成员函数返回一个 iostate 类型的值，该值对应于流当前的整个条件状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream::iostate old_state = <span class="built_in">cin</span>.rdstate();</span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line">process_input(); <span class="comment">// use cin</span></span><br><span class="line"><span class="built_in">cin</span>.clear(old_state); <span class="comment">// reset cin to old state</span></span><br></pre></td></tr></table></figure>
<h3 id="输出缓冲区的管理">输出缓冲区的管理</h3><p>每个IO对象管理一个缓冲区，用于存储程序读写的数据。如有下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">"Plz enter a value:"</span>;</span><br></pre></td></tr></table></figure>
<p>系统会将字符串字面值存储在与流 os 关联的缓冲区中。</p>
<p>下面情况将导致缓冲区的内容被刷新，即写入到真实的输出设备或文件中：</p>
<ol>
<li>程序正常结束。作为 main 返回工作的一部分，将清空所有输出缓冲区；</li>
<li>缓冲区已满，写入下一个值时；</li>
<li>用操纵符显示刷新缓冲区，如行结束符 endl；</li>
<li>每次输出操作完成后，用 unitbuf 操纵符设置流内部的状态，从而清空缓冲区；</li>
<li>将输出流与输入流关联起来。在读入流时将刷新其关联的输出缓冲区；</li>
</ol>
<p><strong>输出缓冲区的刷新</strong></p>
<p>除了 <code>endl</code> 之外，还有其他两个类似的操纵符： <code>flush</code>, <code>ends</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; flush; <span class="comment">// flushes the buffer, adds no data;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; ends; <span class="comment">// inserts a null, then flushes the buffer; </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; endl; <span class="comment">// inserts a newline, then flushes the buffer;</span></span><br></pre></td></tr></table></figure>
<p><strong>unitbuf</strong></p>
<p>如果需要刷新所有输出，最好使用 unitbuf 操纵符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; flush &lt;&lt; <span class="string">"second"</span> &lt;&lt; flush;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序崩溃了，则不刷新缓冲区。</p>
</blockquote>
<p><strong>输入与输出绑定</strong></p>
<p>将 cout 与 cin 绑定，则任何读输入流的操作都将刷新其输出流关联的缓冲区。使用 tie 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);</span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie();</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="comment">// 终止绑定</span></span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>); <span class="comment">// cin 与 cerr 绑定，但不推荐</span></span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie); <span class="comment">// cin 与 cout 重新绑定</span></span><br></pre></td></tr></table></figure>
<h3 id="文件的输入输出">文件的输入输出</h3><h4 id="文件流对象的使用">文件流对象的使用</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// construct an ifstream and bind it to the file named ifile </span><br><span class="line">ifstream infile(ifile.c_str());</span><br><span class="line">// ofstream output file object to write file named ofile</span><br><span class="line">ofstream outfile(ofile.c_str());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>open需要使用C风格字符串</p>
</blockquote>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile; <span class="comment">// input file stream</span></span><br><span class="line">ofstream outfile; <span class="comment">// output file stream</span></span><br><span class="line">infile.open(<span class="string">"in"</span>); <span class="comment">// open file named "in" in current directory</span></span><br><span class="line">outfile.open(<span class="string">"out"</span>); <span class="comment">// open file named "out" in current directory</span></span><br></pre></td></tr></table></figure>
<p><strong>检查文件打开是否成功</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"error: unable to open input file:"</span> &lt;&lt; ifle &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与其他文件绑定</strong></p>
<p>如果把现有 fstream 对象与另一个不同的文件关联，则必须先关闭现有文件，然后打开另一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">infile.close();</span><br><span class="line">infile.open(<span class="string">"next"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>清楚文件流的状态</strong></p>
<p>使用 clear() 函数即可。比如有一个vector对象，存放了一些要打开的文件名，程序要对这些文件处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ifstream input;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line"><span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">	input.open(it-&gt;c_str());</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">		process(s);</span><br><span class="line">	input.close();</span><br><span class="line">	input.clear();</span><br><span class="line">	++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果忽略 <code>input.clear()</code> 则循环只能读入一个文件，因为读取文件到达文件的结束或出错时，input 的状态都是 failbit，此时任何尝试读取 input 都会失败。</p>
<h4 id="文件模式">文件模式</h4><table>
<thead>
<tr>
<th>文件模式</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>打开文件作读操作</td>
</tr>
<tr>
<td>out</td>
<td>打开文件作写操作</td>
</tr>
<tr>
<td>app</td>
<td>每次写之前找到文件尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件尾</td>
</tr>
<tr>
<td>trunc</td>
<td>打开文件时，清空已存在的文件流</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制模式进行IO操作</td>
</tr>
</tbody>
</table>
<ul>
<li>out, trunc, app 模式只能用于指定与 ofstream 或 fstream 对象关联的文件；</li>
<li>in 模式只能用于指定与 ifstream 或 fstream 对象关联的文件；</li>
<li>ate, binary 模式可用于所有文件；</li>
</ul>
<p>默认时，与 ifstream 流对象关联的文件以 in 模式打开；与 ofstream 流对象关联的文件以 out 模式打开；<strong>以out模式打开文件原内容会被清空</strong>，若要保留，则以 app 模式打开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会清空file1</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等价上面，显式清空</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile2</span><span class="params">(<span class="string">"file1"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 在末尾添加内容</span></span><br><span class="line"><span class="function">ofstream <span class="title">appfile</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，fstream 以 in 和 out 模式同时打开。此时，文件不会被清空。</li>
<li>如果打开 fstream 所关联的文件，只使用 out 模式，而不指定 in 模式，则会被清空。</li>
<li>如果指定了 trunc 模式，则无论如何都会被清空；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open for input and output</span></span><br><span class="line"><span class="function">fstream <span class="title">inOut</span><span class="params">(<span class="string">"copyOut"</span>, fstream::in | fstream::out)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>有效的文件模式组合</strong></p>
<table>
<thead>
<tr>
<th>模式组合</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>打开文件做写，清空已有数据</td>
</tr>
<tr>
<td>out &#124; app</td>
<td>打开文件做写，文件尾写入</td>
</tr>
<tr>
<td>out &#124; trunc</td>
<td>同out模式</td>
</tr>
<tr>
<td>in</td>
<td>打开文件做读</td>
</tr>
<tr>
<td>in &#124; out</td>
<td>打开文件做读、写，定位在文件开头</td>
</tr>
<tr>
<td>in &#124; out &#124; trunc</td>
<td>打开文件做读、写，清空已有数据</td>
</tr>
</tbody>
</table>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream&amp; <span class="title">open_file</span><span class="params">(ifstream &amp;in, <span class="keyword">const</span> <span class="built_in">string</span> &amp;file)</span> </span>&#123;</span><br><span class="line">	in.close();</span><br><span class="line">	in.clear();</span><br><span class="line">	in.open(file.c_str());</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不清楚流 in 的状态，则先调用 close 和 clear 设置为有效状态。然后尝试打开文件，最后返回流 in 对象。此时，in 要么与文件绑定，要么处于错误状态。</p>
<h3 id="字符串流">字符串流</h3><p>标准库定义了三个类型的字符串流：</p>
<ul>
<li>istringstream，由 istream 派生而来，提供读 string 的功能。</li>
<li>ostringstream，由 ostream 派生而来，提供写 string 的功能。</li>
<li>stringstream，由 iostream 派生而来，提供读写 string 的功能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> strm; <span class="comment">// 创建 stringstream 对象</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">//存储 s 的副本 stringstream 对象，其中 s 是 string 类型的对象</span></span><br><span class="line">strm.str(); <span class="comment">// 返回 strm 中存储的 string 对象</span></span><br><span class="line">strm.str(s); <span class="comment">// 将 string 对象 s 复制给 strm，返回 void</span></span><br></pre></td></tr></table></figure>
<p><strong>操纵每行中的每个单词</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, line)) <span class="comment">// 读取一行到 line 中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(line)</span></span>; <span class="comment">// bind strem to the line</span></span><br><span class="line">	<span class="keyword">while</span> (stream &gt;&gt; word) <span class="comment">// 从 line 读取一个单词</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl; <span class="comment">// 可以操纵这句话中的每个单词，这里是输出它</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>stringstream提供转换的格式化</strong></p>
<p>把一些数据转换成它们的 string 表示形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">512</span>, v2 = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">ostringstream</span> format_msg;</span><br><span class="line">format_msg &lt;&lt; <span class="string">"v1: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", v2: "</span> &lt;&lt; v2 ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; format_msg.str();</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// v1: 512, v2: 1024</span></span><br></pre></td></tr></table></figure>
<p>或者反过来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int v1 = 512, v2 = 1024;</span><br><span class="line">ostringstream format_msg;</span><br><span class="line">format_msg &lt;&lt; "v1: " &lt;&lt; v1 &lt;&lt; ", v2: " &lt;&lt; v2 &lt;&lt; "\n";</span><br><span class="line">cout &lt;&lt; format_msg.str();</span><br><span class="line">istringstream istring(format_msg.str());</span><br><span class="line">string dump;</span><br><span class="line">int new_v1, new_v2;</span><br><span class="line">istring &gt;&gt; dump &gt;&gt; new_v1 &gt;&gt; dump &gt;&gt; dump &gt;&gt; new_v2;</span><br><span class="line">cout &lt;&lt; new_v1 &lt;&lt; " " &lt;&lt; new_v2 &lt;&lt; " " &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dump &lt;&lt; endl;</span><br><span class="line">// prints:</span><br><span class="line">// v1: 512, v2: 1024</span><br><span class="line">// 512 1024</span><br><span class="line">// v2:</span><br></pre></td></tr></table></figure>
<p>可以发现 istringstream 可以将 string 对象按原来的位置恢复到对应的变量位置。上面程序中 <code>dump</code> 在此过程中相当于一个临时变量，在不断的变化。从输出来看，最后一次 <code>dump</code> 的值为 <code>v2:</code>，前面两次的值依次是：<code>v1:</code>, <code>,</code>（string类型，不带空格）。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br/>ostream 写到流中去；<br/>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br/>ofstream 写到文件对象中去，由 ostream 派生而来；<br/>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br/>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br/>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex8.3, 8.7, 8.8]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-10/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-10/</id>
    <published>2016-01-01T06:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.945Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">input</span><span class="params">(istream &amp;in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">while</span> (in &gt;&gt; val, !in.eof())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	in.clear();</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use cin for test</span></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 1↙</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2↙</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ^Z↙</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-7">Exercise 8.7</h3><p>vector 容器中存放了将要处理的文件名，当打开失败时，输出警告信息，然后取下一个文件处理。假设当前文件夹下有一个名为 <code>test.txt</code> 的文件，内容是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test!</span><br></pre></td></tr></table></figure>
<p>则程序及运行测试如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">			++it;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">char</span> s;</span><br><span class="line">		<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">		input.close();</span><br><span class="line">		input.clear();</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-8">Exercise 8.8</h3><p>不用 continue 实现 ex8.7</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">char</span> s;</span><br><span class="line">			<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">			input.close();</span><br><span class="line">			input.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
</feed>
