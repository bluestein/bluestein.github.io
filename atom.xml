<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo]]></title>
  <subtitle><![CDATA[Humooo's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2016-01-03T09:45:36.341Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[顺序容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-sequential_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-sequential_container/</id>
    <published>2016-01-02T10:46:49.000Z</published>
    <updated>2016-01-03T09:45:36.341Z</updated>
    <content type="html"><![CDATA[<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>顺序容器</strong></td>
<td>-</td>
</tr>
<tr>
<td>vector</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td>list</td>
<td>支持快速插入删除</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列</td>
</tr>
<tr>
<td><strong>顺序容器适配器</strong></td>
<td>-</td>
</tr>
<tr>
<td>stack</td>
<td>后进先出（LIFO）</td>
</tr>
<tr>
<td>queue</td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td>priority_queue</td>
<td>有优先级管理的队列</td>
</tr>
</tbody>
</table>
<h3 id="顺序容器的定义">顺序容器的定义</h3><p>首先必须包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>所有顺序容器都是类模板</strong>。要定义某种特殊的容器，必须在容器名后添加一对尖括号，尖括号内提供容器将要存放元素的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="built_in">deque</span>&lt;Sales_item&gt; item;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有容器都有默认构造函数，该构造函数不带任何参数</p>
</blockquote>
<h4 id="初始化">初始化</h4><p>除了默认构造函数，容器类型还提供了其他的构造函数，可以指定其元素的初值</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C<t> c;</t></td>
<td>创建名为 c 的容器。<br>C 为容器名，如 vector。<br>T为元素类型，如string，int。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c2(c1)</td>
<td>创建容器 c1 的副本。<br>c2 和 c1 必须是相同类型的容器，并存放相同类型的元素。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(begin, end)</td>
<td>使用迭代器 begin 和 end 范围内的元素创建 c。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(n, t)</td>
<td>用 n 个值为 t 的元素创建容器。<br>t 必须与容器存放的类型匹配，或者可以转化为该类型的值。<br><strong>只适用于顺序容器</strong></td>
</tr>
<tr>
<td>C c(n)</td>
<td>创建 n 个默认初始值的容器。<br><strong>只适用于顺序容器</strong></td>
</tr>
</tbody>
</table>
<p><strong>初始化为另一个容器的副本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(ivec1); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(ivec1); <span class="comment">// error: ivec is not list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dvec(ivec); <span class="comment">// error: ivec holds int not double</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化为另一容器的部分元素</strong></p>
<p>允许通过传递一对迭代器来初始化容器。使用迭代器时，不需要容器类型相同，容器内的元素类型可以不同，只要相容即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator mid = svec.begin() + svec.size() / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; front(svec.begin(), mid);</span><br></pre></td></tr></table></figure>
<p>因为指针就是迭代器，所以可以用数组中的值对容器进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *words1[] = &#123;<span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(words1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; words2(words1, words1 + sz);</span><br></pre></td></tr></table></figure>
<p><strong>初始化指定数目的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>都是 10 个元素的 list，<code>slist</code> 的每个值初始化为 <strong>hi</strong>， <code>ilist</code> 每个值初始化为 <strong>0</strong>。</p>
<blockquote>
<p>只有当元素类型有默认构造函数时才可以使用 <code>C c(n)</code> 的方式初始化。例如上面的 int 默认初始化为 0。</p>
</blockquote>
<p><strong>容器的容器</strong></p>
<p>支持容器的容器，不过要注意使用空格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; lines; <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; lines; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>否则被认为是右移操作。</p>
<h3 id="迭代器和迭代器的范围">迭代器和迭代器的范围</h3><p>标准库为所有容器类提供的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>解引用</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>解引用，获取指定名为 member 的成员，等价于 (*iter).member</td>
</tr>
<tr>
<td>++iter<br>iter++</td>
<td>使iter指向后一个元素</td>
</tr>
<tr>
<td>–iter<br>iter–</td>
<td>使iter指向前一个元素</td>
</tr>
<tr>
<td>iter1 == iter2<br>iter1 != iter2</td>
<td>比较是否相等</td>
</tr>
</tbody>
</table>
<h4 id="vector,_deque额外的操作">vector, deque额外的操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n<br>iter - n</td>
<td>使iter指向后（前） n 个元素</td>
</tr>
<tr>
<td>iter1 += iter2<br>iter1 -= iter2<br>iter1 - iter2</td>
<td>迭代器运算</td>
</tr>
<tr>
<td>&gt;, &gt;=, &lt;, &lt;=</td>
<td>关系操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只适用于 vector 和 deque</p>
</blockquote>
<h3 id="顺序容器的操作">顺序容器的操作</h3><p>每种顺序容器都有以下操作</p>
<ol>
<li>向容器添加元素</li>
<li>删除元素</li>
<li>设置容器大小</li>
<li>获取容器第一个或最后一个元素（如果有的话）</li>
</ol>
<h4 id="为容器定义的类型别名">为容器定义的类型别名</h4><table>
<thead>
<tr>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>无符号整型，足以存储此容器类型的最大可能长度</td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器</td>
</tr>
<tr>
<td>const_iterator</td>
<td>只读类型迭代器</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>逆序寻址的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>只读逆序寻址的迭代器</td>
</tr>
<tr>
<td>difference_type</td>
<td>足够存储两迭代器差值的有符号整型，可为负值</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型，是 value_type&amp; 的同义词</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的常量左值类型，等价于 const value_type&amp;</td>
</tr>
</tbody>
</table>
<h4 id="begin_和_end_成员">begin 和 end 成员</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.begin()</td>
<td>返回一个迭代器，指向容器的第一个元素</td>
</tr>
<tr>
<td>c.end()</td>
<td>返回一个迭代器，指向容器最后一个元素的后面一个位置</td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>逆序迭代器，指向容器的最后一个元素</td>
</tr>
<tr>
<td>c.rend()</td>
<td>返回一个逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
</tbody>
</table>
<h4 id="添加元素">添加元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)</td>
<td>在容器尾部添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.push_front(t)</td>
<td>在容器前端添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, t)</td>
<td>在迭代器p所指元素的前面插入一个值为 t 的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p, n, t)</td>
<td>在迭代器p所指元素的前面插入 n 个值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, begin, end)</td>
<td>在迭代器p所指元素的前面插入迭代器 begin 和 end 范围内的元素，返回 void 类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>迭代器可能会失效。指向新加入元素后面的那个元素的迭代器会失效</p>
</blockquote>
<h4 id="关系操作符">关系操作符</h4><p>要使用类型相同的进行比较</p>
<ol>
<li>如果两容器有相同长度并且所有元素相等，则两个容器相等；</li>
<li>如果两容器有不同长度，但较短容器的元素等于较长容器的子序列，则短容器小于长容器；</li>
<li>如果不存在子序列，则比较第一个不同的元素；</li>
</ol>
<h4 id="容器大小">容器大小</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.size()</td>
<td>返回容器 c 中的元素个数，类型为 c::size_type</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>最多可容纳个数</td>
</tr>
<tr>
<td>c.empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>c.resize(n)</td>
<td>调整 c 的大小，容量为 n</td>
</tr>
<tr>
<td>c.resize(n, t</td>
<td>调整 c 的大小，容量为 n，所有新添加的元素值为 t</td>
</tr>
</tbody>
</table>
<h4 id="访问元素">访问元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回 c 的最后一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回 c 的第一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
<tr>
<td>c.at(n)</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
</tbody>
</table>
<p>back 和 front 同样可以用 end 和 begin 迭代器的解引用完成。</p>
<h4 id="删除元素">删除元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器 p 所指元素。<br>返回被删除元素的后一个位置，或最后一个元素的下一个位置</td>
</tr>
<tr>
<td>c.erase(begin, end)</td>
<td>不越界的情况下，删除 begin 和 end 范围内的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 内所有元素，返回 void</td>
</tr>
<tr>
<td>c.pop_back()</td>
<td>删除最后一个元素，返回 void</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除第一个元素，返回 void<br><strong>只适用于 list 和 deque 类型</strong></td>
</tr>
</tbody>
</table>
<h4 id="赋值和交换">赋值和交换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>将 c2 的内容赋值给 c1。会删除 c1 的内容</td>
</tr>
<tr>
<td>c1.swap(c2)</td>
<td>交换 c1 和 c2 的内容</td>
</tr>
<tr>
<td>c.assign(begin, end)</td>
<td>重设 c，把 begin 和 end 范围内的元素赋给 c</td>
</tr>
<tr>
<td>c.assign(n, t)</td>
<td>重设 c 为 n 个值为 t 的元素</td>
</tr>
</tbody>
</table>
<p>assign 会删除原容器中的元素，然后将所指定的新元素插入到该容器中。如果两个容器类型相同，就可以使用赋值操作符将一个容器赋值给另一个容器。如果在不同容器中，元素类型不同但相互兼容，那么必须使用 assign 函数。</p>
<h3 id="vector容器的自增长">vector容器的自增长</h3><p>vector 以连续的方式存储每一个元素，一个挨着一个。所以当在超过预申请内存时再插入元素时，必须重新申请空间，然后将旧元素赋值到新空间中。此时就要用到 capacity 和 reserve，capacity 表示在必须重新非配空间之前可以存储元素的个数，一般由标准库定义，至少等于容器的大小，但一般来说会更大一些；而 reserve 表示人工预留存储空间（类似于数组大小的声明），当使用过程中超过人工预留空间后，vector会自己重新分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.push_back(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="容器的选择">容器的选择</h3><p>元素是否连续存储会显著的影响：</p>
<ol>
<li>在容器内部位置添加或删除元素；</li>
<li>执行元素的随机访问的代价；</li>
</ol>
<h4 id="插入操作影响容器的选择">插入操作影响容器的选择</h4><ol>
<li>list 存储在不连续的空间，允许向前向后逐个遍历，<strong>在任何位置可以高效的 insert 和 erase</strong>。不过它不支持随机访问，必须遍历涉及到的元素。</li>
<li>vector 存储在连续区域，除了在尾部插入（删除），其他任何位置插入（删除）时都必须移动其后面的元素。</li>
<li>deque 更加复杂，在两段插入和删除都非常快，但在内部差入或删除时代价会更高。它还同时提供了 list 和 vector 的性质：<ol>
<li>与 vector 一样，在容器内部 insert 和 erase 效率较低；</li>
<li>不同于 vector，deque 可以高效的实现首尾的 insert 和 erase；</li>
<li>deque 支持所有元素的随机访问；</li>
<li>deque 首尾插入不会使任何迭代器失效，而在首尾删除元素时，会使指向被删除元素的迭代器失效。在其他位置插入或删除都会使所有迭代器失效；</li>
</ol>
</li>
</ol>
<h4 id="访问影响">访问影响</h4><p>vector 和 deque 都支持高效的随机访问，而 list 只能顺序的跟随指针，一直遍历。</p>
<h4 id="建议">建议</h4><ol>
<li>要求随机访问，使用 vector 或 deque；</li>
<li>要求内部插入（删除）元素，选择 list；</li>
<li>如果在首部或尾部插入（删除），则选择 deque；</li>
<li>如果只需在输入时在容器中间插入元素，然后需要随机访问。可以考虑输入时存放到 list 中，接着对其排序，然后将其复制到 vector 中；</li>
<li>如果既需要中间插入元素又要随机访问，则选择容器时，考虑下面两种操作的相对代价：<ol>
<li>随机访问 list 的代价；</li>
<li>在 vector 或 deque 内部插入（删除）元素的代价；</li>
</ol>
</li>
</ol>
<h3 id="深入string类型">深入string类型</h3><p>除了前面用过的操作外，string 类型还支持大多数顺序容器操作。在某些方面可将 string 类型视为字符容器，操作也与 vector 类似，不过 string 不支持以栈方式操作容器：即 string 不能使用 front, back, pop_back等操作。下表扼要的介绍了一些 string 的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s;</td>
<td>定义一个空对象</td>
</tr>
<tr>
<td>string s(cp);</td>
<td>定义一个对象，并用 cp 指向的 c 风格的字符串初始化</td>
</tr>
<tr>
<td>string s2(s1);</td>
<td>初始化为s1的副本</td>
</tr>
<tr>
<td>is &gt;&gt; s;</td>
<td>从输入流 is 中读取一个以空白符分隔的字符串，存入 s</td>
</tr>
<tr>
<td>os &lt;&lt; s;</td>
<td>将 s 写到输出流 os</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从输入流 is 中读取一行字符，写入 s</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>将 s1 和 s2 串接起来，产生一个新的 string 对象</td>
</tr>
<tr>
<td>s1 += s2</td>
<td>将 s2 拼接到 s1 后面</td>
</tr>
<tr>
<td>关系操作符</td>
<td>相等运算（== 和 !=）及关系运算（&lt;, &lt;=, &gt;, &gt;=）都可用于 string 对象的比较。等效于（区分大小写）字典次序的比较</td>
</tr>
</tbody>
</table>
<p>string 支持的容器操作有：</p>
<ol>
<li>迭代器类型；</li>
<li>容器的构造函数（参考<a href="#初始化">前面</a>），但是不包含只需一个长度参数的构造函数；</li>
<li>跟 vector 一样的添加元素的操作。无论是 vector 还是 string 都不支持 push_front；</li>
<li>支持长度操作。resize, size, reserve 等；</li>
<li>支持下标和 at 操作；</li>
<li>支持 begin 和 end 操作；</li>
<li>支持 erase 和 clear 操作。但是不支持 pop_back 或 pop_front 操作；</li>
<li>支持<a href="#赋值和交换">前面</a>表中的赋值操作；</li>
<li>与vector容器一样，string也是连续存储的，因此也支持 capacity 和 reserve 操作；</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hey!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::iterator iter = s.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != s.end()) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造_string_对象">构造 string 对象</h4><p>string 几乎支持<a href="#初始化">前面</a>所有的构造函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2(5, 'a'); // s2 == "aaaaa"</span><br><span class="line">string s3(s2); // s3 是 s2 的副本</span><br><span class="line">string s4(s3.begin(),</span><br><span class="line">		s3.begin() + s3.size() / 2); // s4 == "aa"</span><br><span class="line"></span><br><span class="line">char *cp = "hey!";</span><br><span class="line">char carr[] = "Hello!";</span><br><span class="line">char no_null[] = &#123;'H', 'i'&#125;;</span><br><span class="line">string ss1(cp); // ss1 == "hey!"</span><br><span class="line">string ss2(carr,5); // ss2 == "Hello"</span><br><span class="line">string ss3(carr + 2, 3); // ss3 == "llo"</span><br><span class="line">string ss4(no_null); // runtime_error: 没有 null 结束符</span><br><span class="line">string ss5(no_null, 2); // ok</span><br></pre></td></tr></table></figure>
<p>构造 string 对象的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td>创建用 cp 所指数组的前 n 个字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos)</td>
<td>创建从 s1 的 pos 位置开始的字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos, len)</td>
<td>创建 s1 的 pos 位置开始长为 len 的字符的副本</td>
</tr>
</tbody>
</table>
<blockquote>
<p>n, len, pos 都是 unsigned 值。</p>
</blockquote>
<h4 id="修改string对象">修改string对象</h4><p><strong>与容器共有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, t)</td>
<td>在迭代器 pos 前插入一个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, n, t)</td>
<td>在迭代器 pos 前插入 n 个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, begin, end)</td>
<td>在迭代器 pos 前插入迭代器 begin 到 end 之间的值</td>
</tr>
<tr>
<td>s.assign(begin, end)</td>
<td>用迭代器 begin 到 end 之间的值重新初始化 s</td>
</tr>
<tr>
<td>s.assign(n, t)</td>
<td>用 n 个 t 值重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos)</td>
<td>删除迭代器 pos 所指元素</td>
</tr>
<tr>
<td>s.erase(begin, end)</td>
<td>删除迭代器 begin 到 end 之间的值</td>
</tr>
</tbody>
</table>
<p><strong>string 特有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, n, c)</td>
<td>在下标 pos 前插入 n 个值为 c 的字符</td>
</tr>
<tr>
<td>s.insert(pos, s1)</td>
<td>在下标 pos 前插入一个 s1 的副本</td>
</tr>
<tr>
<td>s.insert(pos, s1, pos1, len)</td>
<td>在下标 pos 前插入 s1 中从 pos1 开始长为 len 的子字符串</td>
</tr>
<tr>
<td>s.insert(pos, cp, len)</td>
<td>在下标 pos 前插入 cp 所指的数组前 n 个字符</td>
</tr>
<tr>
<td>s.insert(pos, cp)</td>
<td>在下标 pos 前插入 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>s.assign(s1)</td>
<td>用 s1 重新初始化 s</td>
</tr>
<tr>
<td>s.assign(s1, pos1, len)</td>
<td>用 s1 中下标 pos1 开始长为 len 的子串重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp, len)</td>
<td>用 cp 所指的数组前 len 个元素重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp)</td>
<td>用 cp 所指以 null 结束的字符数组重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除从下标 pos 开始 len 个字符</td>
</tr>
</tbody>
</table>
<h3 id="只适用于_string_的操作">只适用于 string 的操作</h3><ol>
<li>substr 函数；</li>
<li>append 和 replace</li>
<li>find</li>
</ol>
<h4 id="substr">substr</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos, n)</td>
<td>返回从 pos 开始的 n 个字符</td>
</tr>
<tr>
<td>s.substr(pos)</td>
<td>返回从位置 pos 开始到结尾的字符</td>
</tr>
<tr>
<td>s.substr()</td>
<td>返回 s 的副本</td>
</tr>
</tbody>
</table>
<h4 id="append_和_replace">append 和 replace</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.append(args)</td>
<td>将 args 拼接在 s 后。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(pos, len, args)</td>
<td>删除 pos 开始的 len 个字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(begin, end, args)</td>
<td>删除 begin 到 end 之间的字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1</td>
<td>字符串 s1</td>
</tr>
<tr>
<td>s1, pos1, len1</td>
<td>s1 子串</td>
</tr>
<tr>
<td>cp</td>
<td>cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, len1</td>
<td>cp 所指以 null 结束的字符数组前 len1 个元素</td>
</tr>
<tr>
<td>n, c</td>
<td>n 个 字符 c</td>
</tr>
<tr>
<td>begin1, end1</td>
<td>迭代器 begin1 和 end1 间的字符</td>
</tr>
</tbody>
</table>
<h4 id="find">find</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找 s 中 args 第一次出现</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找 s 中 args 最后一次出现</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>查找 s 中 args 的任意字符第一次出现</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>查找 s 中 args 的任意字符最后一次出现</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找 s 中第一个不属于 args 的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>查找 s 中最后一个不属于 args 的字符</td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c, pos</td>
<td>在 s 中从 pos 开始查找字符 c</td>
</tr>
<tr>
<td>s1, pos</td>
<td>在 s 中从 pos 开始查找 string 对象 s1</td>
</tr>
<tr>
<td>cp, pos</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, pos, n</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组前 n 个字符</td>
</tr>
</tbody>
</table>
<h4 id="string_对象的比较">string 对象的比较</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.compare(s1)</td>
<td>s 与 s1比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1, pos1, n1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 从 pos1 开始长为 n1 的子串比较</td>
</tr>
<tr>
<td>s.compare(cp)</td>
<td>s 与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp)</td>
<td>s 从 pos 开始长为 n 的子串与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp, n1)</td>
<td>s  从 pos 开始长为 n 的子串与 cp 所指数组前 n1 的子串比较</td>
</tr>
</tbody>
</table>
<h3 id="容器适配器">容器适配器</h3><p>标准库提供三种顺序容器适配器：queue, priority_queue, stack。</p>
<p><strong>初始化</strong></p>
<p>肯定需要包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deq 是 deque&lt;int&gt; 类型</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk(deq);</span><br></pre></td></tr></table></figure>
<p><strong>覆盖适配器的基础容器类型</strong></p>
<p>默认情况下，stack 和 queue 都基于 deque 实现，priority_queue 则基于 vector 实现。通过将一个顺序容器指定为适配器的第二个实参，可以覆盖基础容器类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on vector</span></span><br><span class="line"><span class="built_in">stack</span>&lt; <span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str_stk;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两个相同类型的适配器可以做关系运算，第一个不对等的元素决定大于或小于关系。</p>
</blockquote>
<h4 id="栈适配器">栈适配器</h4><p>栈的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stk.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>stk.size()</td>
<td>返回栈中元素个数</td>
</tr>
<tr>
<td>stk.pop()</td>
<td>删除栈顶元素，但不返回其值</td>
</tr>
<tr>
<td>stk.top()</td>
<td>返回栈顶元素，但不删除其值</td>
</tr>
<tr>
<td>stk.push(item)</td>
<td>将 item 压入栈</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;::size_type sz = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; istk;</span><br><span class="line">	<span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.size() != sz)</span><br><span class="line">	&#123;</span><br><span class="line">		istk.push(ix++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> error_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = istk.top();</span><br><span class="line">		<span class="keyword">if</span> (value != --ix)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; <span class="string">"expected "</span> &lt;&lt; ix &lt;&lt; <span class="string">"recieved "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">			++error_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		istk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"errors: "</span> &lt;&lt; error_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">errors: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="queue_和_priority_queue">queue 和 priority_queue</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>q.size()</td>
<td>返回队列中元素个数</td>
</tr>
<tr>
<td>q.pop()</td>
<td>删除队首元素，但不返回其值</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回队首元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.back()</td>
<td>返回队尾元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.top()</td>
<td>返回优先级最高的元素，但不删除其值。<strong>只适用于priority_queue</strong></td>
</tr>
<tr>
<td>q.push(item)</td>
<td>queue： 将 item 压入队尾<br>priority_queue：基于优先级压入队列</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex9.9]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-11/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-11/</id>
    <published>2016-01-02T06:03:42.000Z</published>
    <updated>2016-01-02T15:14:10.181Z</updated>
    <content type="html"><![CDATA[<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s[] = &#123; <span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span> &#125;;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(s, s + <span class="number">3</span>); </span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = --slist.end();</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cnt &lt; sz) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (++cnt &lt; sz) &#123;</span><br><span class="line">			--iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hey</span></span><br><span class="line"><span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
<p>待续。。。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span clas]]>
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IO库]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-IO_library/"/>
    <id>http://bluestein.github.io/2016/01/cpp-IO_library/</id>
    <published>2016-01-01T07:11:49.000Z</published>
    <updated>2016-01-01T13:17:55.438Z</updated>
    <content type="html"><![CDATA[<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br>ostream 写到流中去；<br>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br>ofstream 写到文件对象中去，由 ostream 派生而来；<br>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><strong>国际字符的支持</strong></p>
<p>前面所说的流类（stream class）读写均是 char 类型组成的流，不过，标准库还定义了一套支持 wchar_t 的类型。每个类加上 <strong>w</strong> 前缀，表示宽字符，如 wostream, wistream, wiostream。</p>
<p><strong>IO 对象不可复制或赋值</strong></p>
<p>处于一些原因，标准库不允许赋值或复制操作，原因在后面阐明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// function func: parameter is copied</span></span><br><span class="line"><span class="function">ofstream <span class="title">func</span><span class="params">(ofstream)</span></span>;</span><br><span class="line">out2 = func(out2); <span class="comment">//error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure>
<ol>
<li>由于不能复制，因此不能存储在 vector 等容器中</li>
<li>形参或返回类型也不能为流类型。如果需要传递或返回 IO 类型，则必须使用<strong>指针或引用</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream &amp;<span class="title">func</span><span class="params">(ofstream&amp;)</span></span>; <span class="comment">// ok: takes a reference, no copy</span></span><br><span class="line"><span class="keyword">while</span> (func(out2)) &#123; <span class="comment">/*...*/</span> &#125; <span class="comment">// ok: pass reference to out2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="条件状态">条件状态</h3><p>IO 标准库管理一系列的<strong>条件状态（condition state）</strong>成员，用来标记给定的 IO 对象是否处于可用状态，或者碰到了哪种特定的错误。</p>
<table>
<thead>
<tr>
<th>IO 标准库的条件状态</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm::iostate</td>
<td>机器相关的整型名，由各个 iostream 类定义，用于定义条件状态</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>strm::iostate类型的值，用于指出被破坏的流</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>strm::iostate类型的值，用于指出失败的 IO 操作</td>
</tr>
<tr>
<td>strm::eofbit</td>
<td>strm::iostate类型的值，用于指出流已经达到文件的结束符</td>
</tr>
<tr>
<td>s.eof()</td>
<td>如果设置了流 s 的 eofbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>如果设置了流 s 的 failbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>如果设置了流 s 的 badbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>如果设置了流 s 处于有效状态，该函数返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流 s 的所有状态值重设为有效状态</td>
</tr>
<tr>
<td>s.clear(flag)</td>
<td>将流 s 中某个指定的条件状态设置为有效。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.setstate(flag)</td>
<td>给流 s 添加指定条件。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流 s 当前条件。返回值类型为 strm::iostate</td>
</tr>
</tbody>
</table>
<p>流的状态由 bad、fail、eof 或 good 操作揭示。badbit 标志着系统级的错误，如无法读写的错误。其他都设置了 failbit 标志，通常可修正。</p>
<p><strong>流状态的查询和控制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="comment">// read cin and test only for EOF; loop is executed even if there are IO failures</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ival, !<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"IO stream corrupted"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bad data, try again"</span>;</span><br><span class="line">		<span class="built_in">cin</span>.clear(istream::failbit);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件状态的访问</strong></p>
<p>rdstate 成员函数返回一个 iostate 类型的值，该值对应于流当前的整个条件状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream::iostate old_state = <span class="built_in">cin</span>.rdstate();</span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line">process_input(); <span class="comment">// use cin</span></span><br><span class="line"><span class="built_in">cin</span>.clear(old_state); <span class="comment">// reset cin to old state</span></span><br></pre></td></tr></table></figure>
<h3 id="输出缓冲区的管理">输出缓冲区的管理</h3><p>每个IO对象管理一个缓冲区，用于存储程序读写的数据。如有下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">"Plz enter a value:"</span>;</span><br></pre></td></tr></table></figure>
<p>系统会将字符串字面值存储在与流 os 关联的缓冲区中。</p>
<p>下面情况将导致缓冲区的内容被刷新，即写入到真实的输出设备或文件中：</p>
<ol>
<li>程序正常结束。作为 main 返回工作的一部分，将清空所有输出缓冲区；</li>
<li>缓冲区已满，写入下一个值时；</li>
<li>用操纵符显示刷新缓冲区，如行结束符 endl；</li>
<li>每次输出操作完成后，用 unitbuf 操纵符设置流内部的状态，从而清空缓冲区；</li>
<li>将输出流与输入流关联起来。在读入流时将刷新其关联的输出缓冲区；</li>
</ol>
<p><strong>输出缓冲区的刷新</strong></p>
<p>除了 <code>endl</code> 之外，还有其他两个类似的操纵符： <code>flush</code>, <code>ends</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; flush; <span class="comment">// flushes the buffer, adds no data;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; ends; <span class="comment">// inserts a null, then flushes the buffer; </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; endl; <span class="comment">// inserts a newline, then flushes the buffer;</span></span><br></pre></td></tr></table></figure>
<p><strong>unitbuf</strong></p>
<p>如果需要刷新所有输出，最好使用 unitbuf 操纵符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; flush &lt;&lt; <span class="string">"second"</span> &lt;&lt; flush;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序崩溃了，则不刷新缓冲区。</p>
</blockquote>
<p><strong>输入与输出绑定</strong></p>
<p>将 cout 与 cin 绑定，则任何读输入流的操作都将刷新其输出流关联的缓冲区。使用 tie 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);</span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie();</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="comment">// 终止绑定</span></span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>); <span class="comment">// cin 与 cerr 绑定，但不推荐</span></span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie); <span class="comment">// cin 与 cout 重新绑定</span></span><br></pre></td></tr></table></figure>
<h3 id="文件的输入输出">文件的输入输出</h3><h4 id="文件流对象的使用">文件流对象的使用</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// construct an ifstream and bind it to the file named ifile </span><br><span class="line">ifstream infile(ifile.c_str());</span><br><span class="line">// ofstream output file object to write file named ofile</span><br><span class="line">ofstream outfile(ofile.c_str());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>open需要使用C风格字符串</p>
</blockquote>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile; <span class="comment">// input file stream</span></span><br><span class="line">ofstream outfile; <span class="comment">// output file stream</span></span><br><span class="line">infile.open(<span class="string">"in"</span>); <span class="comment">// open file named "in" in current directory</span></span><br><span class="line">outfile.open(<span class="string">"out"</span>); <span class="comment">// open file named "out" in current directory</span></span><br></pre></td></tr></table></figure>
<p><strong>检查文件打开是否成功</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"error: unable to open input file:"</span> &lt;&lt; ifle &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与其他文件绑定</strong></p>
<p>如果把现有 fstream 对象与另一个不同的文件关联，则必须先关闭现有文件，然后打开另一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">infile.close();</span><br><span class="line">infile.open(<span class="string">"next"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>清楚文件流的状态</strong></p>
<p>使用 clear() 函数即可。比如有一个vector对象，存放了一些要打开的文件名，程序要对这些文件处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ifstream input;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line"><span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">	input.open(it-&gt;c_str());</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">		process(s);</span><br><span class="line">	input.close();</span><br><span class="line">	input.clear();</span><br><span class="line">	++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果忽略 <code>input.clear()</code> 则循环只能读入一个文件，因为读取文件到达文件的结束或出错时，input 的状态都是 failbit，此时任何尝试读取 input 都会失败。</p>
<h4 id="文件模式">文件模式</h4><table>
<thead>
<tr>
<th>文件模式</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>打开文件作读操作</td>
</tr>
<tr>
<td>out</td>
<td>打开文件作写操作</td>
</tr>
<tr>
<td>app</td>
<td>每次写之前找到文件尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件尾</td>
</tr>
<tr>
<td>trunc</td>
<td>打开文件时，清空已存在的文件流</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制模式进行IO操作</td>
</tr>
</tbody>
</table>
<ul>
<li>out, trunc, app 模式只能用于指定与 ofstream 或 fstream 对象关联的文件；</li>
<li>in 模式只能用于指定与 ifstream 或 fstream 对象关联的文件；</li>
<li>ate, binary 模式可用于所有文件；</li>
</ul>
<p>默认时，与 ifstream 流对象关联的文件以 in 模式打开；与 ofstream 流对象关联的文件以 out 模式打开；<strong>以out模式打开文件原内容会被清空</strong>，若要保留，则以 app 模式打开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会清空file1</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等价上面，显式清空</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile2</span><span class="params">(<span class="string">"file1"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 在末尾添加内容</span></span><br><span class="line"><span class="function">ofstream <span class="title">appfile</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，fstream 以 in 和 out 模式同时打开。此时，文件不会被清空。</li>
<li>如果打开 fstream 所关联的文件，只使用 out 模式，而不指定 in 模式，则会被清空。</li>
<li>如果指定了 trunc 模式，则无论如何都会被清空；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open for input and output</span></span><br><span class="line"><span class="function">fstream <span class="title">inOut</span><span class="params">(<span class="string">"copyOut"</span>, fstream::in | fstream::out)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>有效的文件模式组合</strong></p>
<table>
<thead>
<tr>
<th>模式组合</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>打开文件做写，清空已有数据</td>
</tr>
<tr>
<td>out &#124; app</td>
<td>打开文件做写，文件尾写入</td>
</tr>
<tr>
<td>out &#124; trunc</td>
<td>同out模式</td>
</tr>
<tr>
<td>in</td>
<td>打开文件做读</td>
</tr>
<tr>
<td>in &#124; out</td>
<td>打开文件做读、写，定位在文件开头</td>
</tr>
<tr>
<td>in &#124; out &#124; trunc</td>
<td>打开文件做读、写，清空已有数据</td>
</tr>
</tbody>
</table>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream&amp; <span class="title">open_file</span><span class="params">(ifstream &amp;in, <span class="keyword">const</span> <span class="built_in">string</span> &amp;file)</span> </span>&#123;</span><br><span class="line">	in.close();</span><br><span class="line">	in.clear();</span><br><span class="line">	in.open(file.c_str());</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不清楚流 in 的状态，则先调用 close 和 clear 设置为有效状态。然后尝试打开文件，最后返回流 in 对象。此时，in 要么与文件绑定，要么处于错误状态。</p>
<h3 id="字符串流">字符串流</h3><p>标准库定义了三个类型的字符串流：</p>
<ul>
<li>istringstream，由 istream 派生而来，提供读 string 的功能。</li>
<li>ostringstream，由 ostream 派生而来，提供写 string 的功能。</li>
<li>stringstream，由 iostream 派生而来，提供读写 string 的功能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> strm; <span class="comment">// 创建 stringstream 对象</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">//存储 s 的副本 stringstream 对象，其中 s 是 string 类型的对象</span></span><br><span class="line">strm.str(); <span class="comment">// 返回 strm 中存储的 string 对象</span></span><br><span class="line">strm.str(s); <span class="comment">// 将 string 对象 s 复制给 strm，返回 void</span></span><br></pre></td></tr></table></figure>
<p><strong>操纵每行中的每个单词</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, line)) <span class="comment">// 读取一行到 line 中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(line)</span></span>; <span class="comment">// bind strem to the line</span></span><br><span class="line">	<span class="keyword">while</span> (stream &gt;&gt; word) <span class="comment">// 从 line 读取一个单词</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl; <span class="comment">// 可以操纵这句话中的每个单词，这里是输出它</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>stringstream提供转换的格式化</strong></p>
<p>把一些数据转换成它们的 string 表示形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">512</span>, v2 = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">ostringstream</span> format_msg;</span><br><span class="line">format_msg &lt;&lt; <span class="string">"v1: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", v2: "</span> &lt;&lt; v2 ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; format_msg.str();</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// v1: 512, v2: 1024</span></span><br></pre></td></tr></table></figure>
<p>或者反过来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int v1 = 512, v2 = 1024;</span><br><span class="line">ostringstream format_msg;</span><br><span class="line">format_msg &lt;&lt; "v1: " &lt;&lt; v1 &lt;&lt; ", v2: " &lt;&lt; v2 &lt;&lt; "\n";</span><br><span class="line">cout &lt;&lt; format_msg.str();</span><br><span class="line">istringstream istring(format_msg.str());</span><br><span class="line">string dump;</span><br><span class="line">int new_v1, new_v2;</span><br><span class="line">istring &gt;&gt; dump &gt;&gt; new_v1 &gt;&gt; dump &gt;&gt; dump &gt;&gt; new_v2;</span><br><span class="line">cout &lt;&lt; new_v1 &lt;&lt; " " &lt;&lt; new_v2 &lt;&lt; " " &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dump &lt;&lt; endl;</span><br><span class="line">// prints:</span><br><span class="line">// v1: 512, v2: 1024</span><br><span class="line">// 512 1024</span><br><span class="line">// v2:</span><br></pre></td></tr></table></figure>
<p>可以发现 istringstream 可以将 string 对象按原来的位置恢复到对应的变量位置。上面程序中 <code>dump</code> 在此过程中相当于一个临时变量，在不断的变化。从输出来看，最后一次 <code>dump</code> 的值为 <code>v2:</code>，前面两次的值依次是：<code>v1:</code>, <code>,</code>（string类型，不带空格）。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br/>ostream 写到流中去；<br/>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br/>ofstream 写到文件对象中去，由 ostream 派生而来；<br/>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br/>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br/>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex8.3, 8.7, 8.8]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-10/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-10/</id>
    <published>2016-01-01T06:03:42.000Z</published>
    <updated>2016-01-01T13:08:20.896Z</updated>
    <content type="html"><![CDATA[<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">input</span><span class="params">(istream &amp;in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">while</span> (in &gt;&gt; val, !in.eof())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	in.clear();</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use cin for test</span></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 1↙</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2↙</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ^Z↙</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-7">Exercise 8.7</h3><p>vector 容器中存放了将要处理的文件名，当打开失败时，输出警告信息，然后取下一个文件处理。假设当前文件夹下有一个名为 <code>test.txt</code> 的文件，内容是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test!</span><br></pre></td></tr></table></figure>
<p>则程序及运行测试如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">			++it;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">char</span> s;</span><br><span class="line">		<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">		input.close();</span><br><span class="line">		input.clear();</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-8">Exercise 8.8</h3><p>不用 continue 实现 ex8.7</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">char</span> s;</span><br><span class="line">			<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">			input.close();</span><br><span class="line">			input.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数的声明]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-function_declaration/"/>
    <id>http://bluestein.github.io/2015/12/cpp-function_declaration/</id>
    <published>2015-12-31T07:11:49.000Z</published>
    <updated>2015-12-31T05:29:53.370Z</updated>
    <content type="html"><![CDATA[<p>跟变量一样，函数也需要先声明再使用。同样的，函数的定义和函数的声明也可以分离：一个函数只能定义一次，但可以声明多次。</p>
<p>函数声明必须包含：<strong>返回类型、函数名和形参列表</strong>。形参列表必须包含形参类型，但没强调要包含形参名。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="默认实参">默认实参</h3><p>调用函数时，可以省略有默认值的实参。如果一个参数有默认值，那么它后面的实参都必须有默认值。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screenInit</span><span class="params">(<span class="built_in">string</span>::size_type height = <span class="number">24</span>,</span><br><span class="line">				<span class="built_in">string</span>::size_type width = <span class="number">80</span>,</span><br><span class="line">				<span class="keyword">char</span> background = <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="comment">// 下面调用均正确</span></span><br><span class="line"><span class="built_in">string</span> screen;</span><br><span class="line">screen = screenInit();</span><br><span class="line">screen = screenInit(<span class="number">66</span>);</span><br><span class="line">screen = screenInit(<span class="number">66</span>, <span class="number">256</span>);</span><br><span class="line">screen = screenInit(<span class="number">66</span>, <span class="number">256</span>, <span class="string">'#'</span>);</span><br></pre></td></tr></table></figure>
<p>设置默认形参时，最少使用的默认值放在最前，最多使用的放在最后。</p>
<blockquote>
<p>函数在声明时可以指定默认实参，但是在一个文件中，只能为形参指定一次默认参数。所以可以将声明放在头文件中。</p>
</blockquote>
<h3 id="静态局部对象">静态局部对象</h3><p>上面的形参都会在定义它们的快语句结束时被撤销，如果需要跨越多个作用域，定义为 <strong>static</strong>，它能保证在程序结束前不被撤销：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> count() &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i!= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3><p>一般的函数调用要比求解表达式慢得多，<strong>内联函数可以避免函数调用的开销</strong>。使用 <strong>inline</strong> 关键字定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &gt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则在调用 <code>cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;</code> 时， 编译时展开为 <code>cout &lt;&lt; (s1.size() &gt; s2.size() ? s1 : s2) &lt;&lt; endl;</code>。</p>
<p>内联机制适用于优化小的、几行的且经常调用的函数。</p>
<h3 id="类的成员函数">类的成员函数</h3><p>和任何函数一样，包含下面四个部分：</p>
<ol>
<li>返回类型</li>
<li>函数名</li>
<li>逗号分隔的形参列表（可为空）</li>
<li>花括号内的函数体</li>
</ol>
<p>1,2,3 组成的是函数原型，<strong>函数的原型必须在类中定义</strong>，函数体则可以在类外。假设 Sales_item 类有两个成员函数 avgPrice() 和 sameIsbn(const Sales_item &amp;):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">avgPrice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现形参的后面有 <code>const</code>，在解释之前，说明成员函数如何定义：</p>
<h4 id="成员函数的函数体">成员函数的函数体</h4><p>类的所有成员必须在<strong>定义类的花括号中声明</strong>，并且<strong>编译器隐式地将类内定义的成员函数当作是内联函数</strong>。</p>
<blockquote>
<p>类的成员函数可以访问 private 成员，如 isbn。</p>
</blockquote>
<p><strong>this 指针的引入</strong></p>
<p>每个成员函数都有一个额外的、隐式的形参 <strong>this</strong>，在调用成员函数时，形参 this 初始化为调用函数的对象的地址。可以这样理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.sameIsbn(otherItem);</span><br></pre></td></tr></table></figure>
<p>编译器会重写这个函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item::sameIsbn(&amp;item, otherItem);</span><br></pre></td></tr></table></figure>
<p><strong>const 成员函数的引入</strong></p>
<p>也就是上面提到的形参后面 <strong>const</strong>，<strong>它改变了隐式形参 this 的类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item *<span class="keyword">const</span> <span class="keyword">this</span>,</span><br><span class="line">			<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;isbn == rhs.isbn);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用 const 的函数称为<strong>常量成员函数</strong>（const member function）。由于 this 指向 const 对象，const 成员函数不能修改调用该函数的对象。</p>
<h4 id="类外定义成员函数">类外定义成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Sales_item::avgPrice() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (units_sold)&#123;</span><br><span class="line">		<span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了域操作符 <code>::</code> 及类名 <code>Sales_item</code>。</p>
<h4 id="Sale_item_的构造函数">Sale_item 的构造函数</h4><p>构造函数是特殊的成员函数，<strong>构造函数名与类名相同，而且无返回类型</strong>。可以有多个构造函数，相互之间的具有不同数目或类型的形参。</p>
<p>跟普通成员函数一样，必须在类内声明，类内或类外定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">avgPrice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">	&#125;</span><br><span class="line">	Sales_item(): units_sold(<span class="number">0</span>), revenue(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数的初始化列表</strong></p>
<p><strong>在冒号与花括号之间的代码称为构造函数的初始化列表</strong>，即 <code>units_sold(0), revenue(0.0)</code> 为成员指定初值，括号内是初值。<strong>构造函数的形参表为空说明此为默认调用的</strong></p>
<p><strong>类代码的组织</strong></p>
<p>通常将类的声明放置在头文件中，在类外定义的成员函数则置于源文件中。</p>
<h3 id="重载函数">重载函数</h3><p>在相同作用域中，出现相同名字而形参表不同的函数，称为重载函数。如电话本的查找：基于姓名、基于号码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Name&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>重载与重复声明的区别</strong></p>
<p>如果两个函数声明的返回类型和参数表完全匹配，叫重复声明；<strong>如果形参表完全相同，返回类型不同，则第二个错误</strong>。</p>
<p>在函数中局部声明的名字会屏蔽全局名，即使是变量名对函数名也同样成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> init = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> s = init(); <span class="comment">// error: global init is hidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指向函数的指针">指向函数的指针</h3><p>函数指针是指指向函数而非对象的指针，像其他指针一样，函数指针指向的是函数类型，<strong>函数类型由其返回类型和形参表确定，与函数名无关</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>
<h4 id="用typedef简化定义">用typedef简化定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则 <code>cmpFcn</code> 表示<strong>指向返回类型为 bool 类型并带有两个 const string 引用形参的函数的指针</strong>。若要定义此类型的函数指针，则直接使用 <code>cmpFcn</code> 即可。</p>
<h4 id="初始化和赋值">初始化和赋值</h4><p>在引用函数名又没调用该函数，函数名将被自动解释为指向函数的指针。假设有函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCpmpare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>会被解释为如下类型的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>
<p>可以做如下初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = <span class="number">0</span>;				<span class="comment">// ok：不指向任何函数</span></span><br><span class="line">cmpFcn pf2 = lengthCompare;	<span class="comment">// ok：指向类型匹配的函数</span></span><br><span class="line">pf1 = lengthCompare;		<span class="comment">// ok：同上</span></span><br><span class="line">pf2 = pf1;					<span class="comment">// ok：同上</span></span><br></pre></td></tr></table></figure>
<p>此时，直接饮用函数名等效于在函数名上应用取地址操作符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = lengthCompare;</span><br><span class="line">cmpFcn pf2 = &amp;lengthCompare;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值</p>
</blockquote>
<h4 id="通过指针调用函数">通过指针调用函数</h4><p>不需要解引用操作符，直接通过指针调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf = lengthcompare;</span><br><span class="line">lengthCompare(<span class="string">"hi"</span>, <span class="string">"bye"</span>);	<span class="comment">// 直接调用</span></span><br><span class="line">pf(<span class="string">"hi"</span>, <span class="string">"bye"</span>);			<span class="comment">// 等价调用：pf隐式解引用</span></span><br><span class="line">(*pf)(<span class="string">"hi"</span>, <span class="string">"bye"</span>);			<span class="comment">// 等价调用：pf显式解引用</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针形参">函数指针形参</h4><p>函数的形参可以是指向函数的指针，这种形参可以用以下两种形式编写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string &amp;, const string &amp;,</span><br><span class="line">			bool (const string &amp;, const string &amp;));</span><br><span class="line">void useBigger(const string &amp;, const string &amp;,</span><br><span class="line">			bool (*)(const string &amp;, const string &amp;));</span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针">返回指向函数的指针</h4><p>函数可以返回指向函数的指针，但是，这并不简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ff is a function taking an int and returing a function pointer</span></span><br><span class="line"><span class="comment">// the function pointed to returns an int and takes an int* and an int</span></span><br><span class="line"><span class="keyword">int</span> (*ff(<span class="keyword">int</span>)) (<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>这样理解： <code>ff(int)</code> 表明 ff 为一个函数，它带有一个 int 型形参，该参数返回 <code>int (*)(int*, int)</code>，它是指向一个函数的指针。用 typedef 可以更加明白：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PF is a pointer to a function returing an int, taking an int* and an int</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>跟变量一样，函数也需要先声明再使用。同样的，函数的定义和函数的声明也可以分离：一个函数只能定义一次，但可以声明多次。</p>
<p>函数声明必须包含：<strong>返回类型、函数名和形参列表</strong>。形参列表必须包含形参类型，但没强调要包含形参名。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[return]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-return/"/>
    <id>http://bluestein.github.io/2015/12/cpp-return/</id>
    <published>2015-12-30T06:11:49.000Z</published>
    <updated>2015-12-30T08:19:19.076Z</updated>
    <content type="html"><![CDATA[<p>return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="没有返回值的函数">没有返回值的函数</h3><p>不带返回值的return语句用于 void 类型的函数。在 void 类型的函数中，return 语句不是必须的，它会在函数的最后一个语句隐式的完成。</p>
<p><strong>隐式的return</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">	<span class="comment">// 隐式的return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>return</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 == v2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 不带返回值的return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">	<span class="comment">// 隐式的return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有返回值的函数">有返回值的函数</h3><p>使用第二种形式，即 <code>return expression;</code> 返回值给非 void 函数。</p>
<h4 id="主函数_main_的返回值">主函数 main 的返回值</h4><p>可将 main 函数的返回值作为状态指示器，0 表示运行成功，其他返回值则因机器的不同而不同，因此 cstdlib 头文件定义了两个预定于变量 <code>EXIT_FAILURE</code> <code>EXIT_SUCCESS</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sctdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (some_failure)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回非引用类型">返回非引用类型</h4><p>此时可以返回局部对象，或表达式的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">makePlural</span><span class="params">(size_t ctr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ctr == <span class="number">1</span>) ? word : word + ending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回引用">返回引用</h4><p>返回的是对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &gt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不能返回局部变量的引用">不能返回局部变量的引用</h4><p>因为程序执行完毕时，将释放该对象的存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">mainp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret = s;</span><br><span class="line">	<span class="keyword">return</span> ret; <span class="comment">// wrong: local object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样不要返回局部变量的指针</p>
</blockquote>
<h4 id="引用返回左值">引用返回左值</h4><p>可以使用在要求使用左值的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">getVal</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a string"</span>)</span></span>;</span><br><span class="line">	getVal(s, <span class="number">0</span>) = <span class="string">'A'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints: </span></span><br><span class="line"><span class="comment">// A string</span></span><br></pre></td></tr></table></figure>
<p>如果不想引用返回值被修改，则返回值应声明为const： <code>const char &amp;getVal(...</code>。</p>
<h3 id="递归">递归</h3><p>间接或直接调用子集的函数称为递归函数（recursion function）。例如阶乘运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> fact(val - <span class="number">1</span>) * val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或最大公约数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rgcd</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v2 != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> rgcd(v2, v1 % v2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>fact</code> 与 <code>rgcd</code> 它们的终止条件分别是： <code>val = 1</code>; 余数等于零。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[参数传递]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-parameter_passing/"/>
    <id>http://bluestein.github.io/2015/12/cpp-parameter_passing/</id>
    <published>2015-12-29T12:49:49.000Z</published>
    <updated>2015-12-30T06:10:49.921Z</updated>
    <content type="html"><![CDATA[<h3 id="引用型形参">引用型形参</h3><p>利用引用形参，交换两个数的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>利用引用型的形参，可以解决函数只能返回一个值得情况</p>
</blockquote>
<p>比如，在某个vector中寻找某个特定的值，然后返回它出现的位置及出现的次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">const_iterator <span class="title">findValue</span><span class="params">(</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator begin,</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end,</span><br><span class="line">	<span class="keyword">int</span> value,</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type &amp;occurs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator result_iter = end;</span><br><span class="line">	occurs = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; begin != end; ++begin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*begin == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// remember first occurrence of value</span></span><br><span class="line">			<span class="keyword">if</span> (result_iter == end)</span><br><span class="line">			&#123;</span><br><span class="line">				result_iter = begin;</span><br><span class="line">			&#125;</span><br><span class="line">			++occurs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用const引用避免复制">利用const引用避免复制</h3><p>一般的形参传递时需要复制，引用不需要。当使用大型引用形参时，为了避免复制实参，使用const引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参是引用，所以不需要复制实参；形参是const，所以不能通过该引用形参来修改实参的值。</p>
<h3 id="传递指针的引用">传递指针的引用</h3><p>交换指向数值的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prSwap</span><span class="params">(<span class="keyword">int</span> *&amp;v1, <span class="keyword">int</span> *&amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector或其他容器作为形参">vector或其他容器作为形参</h3><p>为避免直接使用vector等类型做形参，一般使用它们的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator begin,</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(begin != end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *begin++;</span><br><span class="line">		<span class="keyword">if</span> (begin != end) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组作为形参">数组作为形参</h3><p>肯定不能直接传递数组，通常使用指针进行操作。而下面三种是等价的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是后两种很容易引起误解。下面可以看出是否真的等价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[<span class="number">10</span>])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v1 = <span class="number">32</span>, arr[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">0</span>&#125;;</span><br><span class="line">printv(&amp;v1); <span class="comment">//编译ok, 但会输出其他9个其他的值或者运行时错误</span></span><br><span class="line">printv(arr); <span class="comment">//编译ok, 但会输出其他8个其他的值或者运行时错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器不会检查形参数组的大小。</p>
</blockquote>
<h3 id="通过引用传递数组">通过引用传递数组</h3><p>一般来讲，将数组作为形参传递给函数都会被转换为指针，但是数组的引用不会。此时，传递的是数组的引用本身，编译器会检查形参数组的大小。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void print(int (&amp;arr)[3]);</span><br><span class="line">int i = 0, j[2] = &#123;0, 1&#125;;</span><br><span class="line">int k[3] = &#123;0, 1, 2&#125;;</span><br><span class="line">print(&amp;i); // error</span><br><span class="line">print(j); // error</span><br><span class="line">print(k); // ok</span><br></pre></td></tr></table></figure>
<h3 id="多维数组的传递">多维数组的传递</h3><p>所谓多维数组，就是数组的数组。它的每个元素就是一个数组，第二维必须指定</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void print(int (matrix*)[10], int row_size);</span><br><span class="line">// 或者</span><br><span class="line">void print(int matrix[][10], int row_size);</span><br></pre></td></tr></table></figure>
<p><code>matrix</code> 是指向含10个int值的数组的指针。</p>
<h3 id="在函数内处理数组">在函数内处理数组</h3><p>任何数组的操作都必须保持在数组的边界内。</p>
<p>有三种常见的方法可以保证这一点：</p>
<ol>
<li>第一种是在数组的本身放置一个标记进行检测数组的结束。如C风格的字符串，使用 <code>\0</code> 标记表示结束；</li>
<li>第二种是传递指向数组的第一个和最后一个元素的下一个位置的指针；</li>
<li>显式地传递数组的大小。意思是告诉函数，我的大小是多少；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="引用型形参">引用型形参</h3><p>利用引用形参，交换两个数的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex7.3 - 7.6]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-9/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-9/</id>
    <published>2015-12-25T11:03:42.000Z</published>
    <updated>2015-12-30T06:16:34.240Z</updated>
    <content type="html"><![CDATA[<h3 id="Exercise_7-3">Exercise 7.3</h3><p>产生第一个参数的第二个参数次幂的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> power)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; power) </span><br><span class="line">	&#123;</span><br><span class="line">		result *= base;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="Exercise_7-4">Exercise 7.4</h3><p>返回一个数的绝对值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> v)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_7-5">Exercise 7.5</h3><p>两个形参，一个int型，另一个int型指针，返回值较大的数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biggerOne</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">const</span> <span class="keyword">int</span> *ip)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> biggerOne = v &gt; *ip ? v : *ip;</span><br><span class="line">	ip = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> biggerOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_7-6">Exercise 7.6</h3><p>交换两个int指针所指对象的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pSwap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bonus">Bonus</h3><p>利用引用交换两个数的值（跟ex 7.6一样的效果）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用引用型的形参，可以解决函数只能返回一个值得情况</p>
</blockquote>
<h3 id="Bonus-1">Bonus</h3><p>交换指向数值的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prSwap</span><span class="params">(<span class="keyword">int</span> *&amp;v1, <span class="keyword">int</span> *&amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Exercise_7-3">Exercise 7.3</h3><p>产生第一个参数的第二个参数次幂的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> power)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; power) </span><br><span class="line">	&#123;</span><br><span class="line">		result *= base;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex6.18, 6.20, 6.21]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-8/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-8/</id>
    <published>2015-12-24T12:03:42.000Z</published>
    <updated>2015-12-30T06:16:34.243Z</updated>
    <content type="html"><![CDATA[<h3 id="Exercise_6-18">Exercise 6.18</h3><p>输入两个string对象，比较哪个按字典序靠前。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dictOrder</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp1 = a.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp2 = b.c_str();</span><br><span class="line">	<span class="keyword">while</span> (*cp1 &amp;&amp; *cp2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*cp1 != *cp2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *cp1 &gt; *cp2 ? <span class="string">"First bigger"</span> : <span class="string">"First smaller"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cp1++;</span><br><span class="line">		cp2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Same"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str1, str2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input two strings.\nIf you want to quit, input two 'q'."</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nTwo strings:\n"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; dictOrder(str1, str2) &lt;&lt; endl;</span><br><span class="line">	&#125; <span class="keyword">while</span> (str1 != <span class="string">"q"</span> &amp;&amp; str2 != <span class="string">"q"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Please input two strings.</span><br><span class="line">If you want to quit, input two <span class="string">'q'</span>.</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">ab↙</span><br><span class="line">ac↙</span><br><span class="line">First smaller</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">b↙</span><br><span class="line">a↙</span><br><span class="line">First bigger</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">q↙</span><br><span class="line">q↙</span><br><span class="line">Same</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-20">Exercise 6.20</h3><p>读入一系列string，直到出现重复的单词时停止，或者没有重复时请说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ( !found &amp;&amp; <span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str == v[i]) </span><br><span class="line">			&#123;</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		v.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (found ? <span class="string">"Repeat found"</span> : <span class="string">"No repeated"</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1</span></span><br><span class="line">hi↙</span><br><span class="line">hey↙</span><br><span class="line">hello↙</span><br><span class="line">hi↙</span><br><span class="line">Repeat found</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line">hi↙</span><br><span class="line">hey↙</span><br><span class="line">hello↙</span><br><span class="line">^Z↙</span><br><span class="line">No repeated</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-21">Exercise 6.21</h3><p>读入一系列string，直到出现重复的以大写字母开头的单词时停止，或者没有重复时请说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUpper</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ( !found &amp;&amp; <span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str == v[i]) </span><br><span class="line">			&#123;</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isUpper(str[<span class="number">0</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			v.push_back(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (found ? <span class="string">"Repeat found"</span> : <span class="string">"No repeated"</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1</span></span><br><span class="line">hi↙</span><br><span class="line">hI↙</span><br><span class="line">Hi↙</span><br><span class="line">HI↙</span><br><span class="line">Hi↙</span><br><span class="line">Repeat found</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line">hi↙</span><br><span class="line">hI↙</span><br><span class="line">Hi↙</span><br><span class="line">HI↙</span><br><span class="line">^Z↙</span><br><span class="line">No repeated</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Exercise_6-18">Exercise 6.18</h3><p>输入两个string对象，比较哪个按字典序靠前。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex6.16]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-7/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-7/</id>
    <published>2015-12-22T12:03:42.000Z</published>
    <updated>2015-12-30T06:16:34.247Z</updated>
    <content type="html"><![CDATA[<h3 id="Exercise_6-16">Exercise 6.16</h3><p>比较两个int型vector对象，判断一个是否是另一个的前缀。<br>即，假设有{ 0, 1, 1, 2 } 和 { 0, 1, 1, 2, 3, 5, 8 }则应返回true。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz1 = a.size(), sz2 = b.size();</span><br><span class="line">	<span class="keyword">int</span> sz = sz1 &gt; sz2 ? sz2 : sz1;</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == b[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			++matched;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sz == matched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">7</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sz1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line">	<span class="keyword">int</span> sz2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(*arr2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1(arr1, arr1 + sz1);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2(arr2, arr2 + sz2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; isPrefix(vec1, vec2) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Exercise_6-16">Exercise 6.16</h3><p>比较两个int型vector对象，判断一个是否是另一个的前缀。<br>即，假设有{ 0, 1, 1, 2 } 和 { 0, 1, 1, 2, 3, 5, 8 }则应返回true。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[while, ex6.12]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-6/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-6/</id>
    <published>2015-12-22T07:03:42.000Z</published>
    <updated>2015-12-30T06:16:48.424Z</updated>
    <content type="html"><![CDATA[<h3 id="Example">Example</h3><p>将一个数组拷贝到另一个数组</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> *source = arr;</span><br><span class="line">	<span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">	<span class="keyword">int</span> *dest = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">	<span class="keyword">while</span> (source != arr + sz) </span><br><span class="line">	&#123;</span><br><span class="line">		*dest++ = *source++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test</span></span><br><span class="line">	<span class="keyword">int</span> *dp = dest - sz;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *dp &lt;&lt; endl;</span><br><span class="line">		dp++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-12">Exercise 6.12</h3><p>输入一些单词，统计里面单词出现的次数。</p>
<p>如：how, now now now brown cow cow<br>则需输出: how 1次，now 3次，brown 1次，cow 2次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCharacter</span><span class="params">(<span class="keyword">char</span> ch)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 把单词存入vector，并忽略非字母</span></span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	getline(<span class="built_in">cin</span>, str);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp = str.c_str();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; raw;</span><br><span class="line">	<span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isCharacter(*cp)) </span><br><span class="line">		&#123;</span><br><span class="line">			tmp += *cp++;</span><br><span class="line">			<span class="keyword">if</span> (*cp != <span class="string">'\0'</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!tmp.empty()) </span><br><span class="line">		&#123;</span><br><span class="line">			raw.push_back(tmp);</span><br><span class="line">			tmp = <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++cp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计各单词出现的次数</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; unique;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">	unique.push_back(raw[<span class="number">0</span>]);</span><br><span class="line">	cnt.push_back(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type i = <span class="number">0</span>; i != raw.size(); ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type j = <span class="number">0</span>; j != unique.size(); ++j) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (raw[i] == unique[j]) </span><br><span class="line">			&#123;</span><br><span class="line">				++cnt[j];</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!found) </span><br><span class="line">		&#123;</span><br><span class="line">			unique.push_back(raw[i]);</span><br><span class="line">			cnt.push_back(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出</span></span><br><span class="line">	<span class="keyword">int</span> max = cnt[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i != cnt.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"单词："</span> &lt;&lt; unique[i] &lt;&lt; <span class="string">",出现次数为："</span> &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (max &lt; cnt[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			max = cnt[i];</span><br><span class="line">			max_index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl &lt;&lt;<span class="string">"出现最多的是："</span>&lt;&lt; unique[max_index] &lt;&lt; <span class="string">",次数为："</span> &lt;&lt; cnt[max_index] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">how, now now now brown cow cow↙</span><br><span class="line">单词：how,出现次数为：<span class="number">1</span></span><br><span class="line">单词：now,出现次数为：<span class="number">3</span></span><br><span class="line">单词：brown,出现次数为：<span class="number">1</span></span><br><span class="line">单词：cow,出现次数为：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">出现最多的是：now,次数为：<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Example">Example</h3><p>将一个数组拷贝到另一个数组</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[switch, ex6.9]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-5/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-5/</id>
    <published>2015-12-22T01:42:42.000Z</published>
    <updated>2015-12-30T06:17:31.503Z</updated>
    <content type="html"><![CDATA[<h3 id="Example">Example</h3><p>统计输入的一句话中元音出现的次数。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>, otherCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ch)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">			++aCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">			++eCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">			++iCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">			++oCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">			++uCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			++otherCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of vowel a/A:\t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel e/E:\t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel i/I:\t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel o/O:\t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel u/U:\t"</span> &lt;&lt; uCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of other characters:\t"</span> &lt;&lt; otherCnt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sorry! Who Are You Again?↙</span><br><span class="line">^Z↙</span><br><span class="line">Number of vowel a/A:    <span class="number">3</span></span><br><span class="line">Number of vowel e/E:    <span class="number">1</span></span><br><span class="line">Number of vowel i/I:    <span class="number">1</span></span><br><span class="line">Number of vowel o/O:    <span class="number">3</span></span><br><span class="line">Number of vowel u/U:    <span class="number">1</span></span><br><span class="line">Number of other characters:     <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-9">Exercise 6.9</h3><p>统计下列字符序列出现的次数：ff、fl以及fi。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> pre_ch = <span class="string">'\0'</span>, cur_ch;</span><br><span class="line">	<span class="keyword">int</span> ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>, otherCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((cur_ch = getchar()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pre_ch == <span class="string">'f'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (cur_ch)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">				++ffCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">				++flCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">				++fiCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				++otherCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pre_ch = cur_ch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"Number of ff:\t"</span> &lt;&lt; ffCnt &lt;&lt;<span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of fl:\t"</span> &lt;&lt; flCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of fi:\t"</span> &lt;&lt; fiCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of other:\t"</span> &lt;&lt; otherCnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flfmffi↙</span><br><span class="line">^Z↙</span><br><span class="line">Number of ff:   <span class="number">1</span></span><br><span class="line">Number of fl:   <span class="number">1</span></span><br><span class="line">Number of fi:   <span class="number">1</span></span><br><span class="line">Number of other:        <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Example">Example</h3><p>统计输入的一句话中元音出现的次数。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Classes and Structures]]></title>
    <link href="http://bluestein.github.io/2015/12/swift-classesAndStructures/"/>
    <id>http://bluestein.github.io/2015/12/swift-classesAndStructures/</id>
    <published>2015-12-21T12:42:42.000Z</published>
    <updated>2015-12-30T06:12:01.571Z</updated>
    <content type="html"><![CDATA[<h3 id="comparing_classes_and_structures">comparing classes and structures</h3><p>都可以：</p>
<ul>
<li>定义 property 来存储值</li>
<li>定义函数</li>
<li>定义下标，以供下表式调用</li>
<li>定义初始化函数</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li>Conform to protocols to provide standard functionality of a certain kind</li>
</ul>
<a id="more"></a>
<p>class可以但structure不行：</p>
<ul>
<li>Inheritance enables one class to inherit the characteristics of another.（继承另一个类）</li>
<li><p>Type casting enables you to check and interpret the type of a class instance at runtime.（类型转换）</p>
</li>
<li><p>Deinitializers enable an instance of a class to free up any resources it has assigned.（析构函数）</p>
</li>
<li>Reference counting allows more than one reference to a class instance.（引用计数）</li>
</ul>
<blockquote>
<p>Structures are always copied when they are passed around in your code, and do not use reference counting.</p>
</blockquote>
<h3 id="syntax">syntax</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// class definition goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructrue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// structure definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个 class 或 struct 实际上是定义了一种类型，跟 String，Int 等类似。一般来说 class 和 struct 的名字用 UpperCamelCase，属性和方法名则用 lowerCamelCase。例如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Resolution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> width = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> height = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VideoMode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> resolution = <span class="type">Resolution</span>()</span><br><span class="line">    <span class="keyword">var</span> interlaced = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> frameRate = <span class="number">0.0</span></span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span>?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 struct 有两个属性，class 有四个属性，其中一个是 struct 类型，name 属性会有一个默认值是 <code>nil</code>，因为它是 optional。</p>
<h3 id="class_and_structure_instances">class and structure instances</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someResolution = <span class="type">Resolution</span>()</span><br><span class="line"><span class="keyword">let</span> someVideoMode = <span class="type">VideoMode</span>()</span><br></pre></td></tr></table></figure>
<p>上面都使用初始化函数的方式声明对象。</p>
<p><strong>accessing properties</strong></p>
<p>使用 <code>.</code> 来访问属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"The width of resolution is <span class="subst">\(someResolution.width)</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>除了访问，也可以赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">someVideoMode.resolution.width = <span class="number">1280</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The width of someVideoMode is <span class="subst">\(someVideoMode.resolution.width)</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>可以直接设定 struct 的属性值。</p>
<p><strong>memberwise initializers for structure types</strong></p>
<p>struct 按成员的初始化函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vga = <span class="type">Resolution</span>(width: <span class="number">640</span>, height: <span class="number">480</span>)</span><br></pre></td></tr></table></figure>
<p>上面的方式，class 不支持。</p>
<h3 id="structures_and_enumerations_are_value_types">structures and enumerations are value types</h3><p>原话：A value type is a type whose value is copied when it is assigned to a variable or constant, or when it is passed to a function.</p>
<p>其实swift中所有的基本类型——integers, floating-point, Booleans, strings, arrays and dictionaries——都是 value type。</p>
<p>也就是说，当你创建 struct 或 enumeration 类型的实例时，都是拷贝。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">et hd = <span class="type">Resolution</span>(width: <span class="number">1920</span>, height: <span class="number">1080</span>)</span><br><span class="line"><span class="keyword">var</span> cinema = hd</span><br></pre></td></tr></table></figure>
<p>此时，<code>cinema</code> 就是 <code>hd</code> 的一份拷贝，尽管现在它们两者有相同的长和宽，它们是完全独立的两个实例。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cinema.width = <span class="number">2048</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"cinema is now <span class="subst">\(cinema.width)</span> pixels wide."</span>)</span><br><span class="line"><span class="comment">// prints "cinema is now 2048 pixels wide."</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"hd is still <span class="subst">\(hd.width)</span> pixels wide."</span>)</span><br><span class="line"><span class="comment">// prints "hd is still 1920 pixels wide."</span></span><br></pre></td></tr></table></figure>
<p>类似的，enumeration 也有：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> currentDirection = <span class="type">CompassPoint</span>.<span class="type">West</span></span><br><span class="line"><span class="keyword">let</span> rememberDirection = currentDirection</span><br><span class="line">currentDirection = .<span class="type">East</span></span><br><span class="line"><span class="keyword">if</span> rememberDirection == .<span class="type">West</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"The remembered direction is still .west"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="classes_are_reference_types">classes are reference types</h3><p>与 value type 不同，reference type 会取代现有的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tenEighty = <span class="type">VideoMode</span>()</span><br><span class="line">tenEighty.resolution = hd</span><br><span class="line">tenEighty.interlaced = <span class="literal">true</span></span><br><span class="line">tenEighty.name = <span class="string">"1080i"</span></span><br><span class="line">tenEighty.frameRate = <span class="number">25.0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> alsoTenEighty = tenEighty</span><br><span class="line">alsoTenEighty.frameRate = <span class="number">30.0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The frameRate property of tenEighty is now <span class="subst">\(tenEighty.frameRate)</span>"</span>)</span><br><span class="line"><span class="comment">// prints "The frameRate property of tenEighty is now 30.0"</span></span><br></pre></td></tr></table></figure>
<h3 id="identity_operators">identity operators</h3><p>因为 class 是 reference type，所以有必要比较两个常量或变量是否 refer 到同一个类的实例上，有两个操作符可以完成这件事：</p>
<ul>
<li>Identical to (===)</li>
<li>Not identitcal to (!==)</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> tenEighty === alsoTenEighty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"tenEight and alsoTenEight refer to the same VideoMode instance."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "tenEight and alsoTenEight refer to the same VideoMode instance."</span></span><br></pre></td></tr></table></figure>
<ul>
<li>“Identical to”: means that two constants or variables of class type refer to exactly the same class instance.</li>
<li>“Equal to”: means that two instances are considered “equal” or “equivalent” in value, for some appropriate meaning of “equal”, as defined by the type’s designer.</li>
</ul>
<p><strong>Pointers</strong></p>
<p>swift 中的 refer 到某个 reference type 的实例跟 C，C++ 中的指针是类似的，但不需要 <code>*</code> 来定义。</p>
<h3 id="choose_structure_or_class">choose structure or class</h3><p>structure instances are always passed by value, and class instances are always passed by reference.</p>
<p>如果满足下面一个或多个条件，考虑使用 structure：</p>
<ul>
<li>The structure’s primary purpose is to encapsulate a few relatively simple data values.（为了概括一些数据）</li>
<li>It is reasonable to expect that the encapsulated values will be copied rather than referenced when you assign or pass around an instance of that structure.（如果数据一般是拷贝而不是refer）</li>
<li>Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced.（value types）</li>
<li>The structure does not need to inherit properties or behavior from another existing type.（不需要继承性）</li>
</ul>
<p>一些可以使用 structure 的例子：</p>
<ul>
<li>The size of a geometric shape, perhaps encapsulating a width property and a height property, both of type Double.（几何形状的大小）</li>
<li>A way to refer to ranges within a series, perhaps encapsulating a start property and a length property, both of type Int.（一系列的范围）</li>
<li>A point in a 3D coordinate system, perhaps encapsulating x, y and z properties, each of type Double.（坐标系统）</li>
</ul>
<p><strong>Assignment and Copy Behavior for Strings, Arrays, and Dictionaries</strong></p>
<p>In Swift, many basic data types such as String, Array, and Dictionary are implemented as structures.意思是说，当这些类型赋给一个新的 constant 或 variable ，或传递给函数时，都是原始数据的拷贝。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="comparing_classes_and_structures">comparing classes and structures</h3><p>都可以：</p>
<ul>
<li>定义 property 来存储值</li>
<li>定义函数</li>
<li>定义下标，以供下表式调用</li>
<li>定义初始化函数</li>
<li>Be extended to expand their functionality beyond a default implementation</li>
<li>Conform to protocols to provide standard functionality of a certain kind</li>
</ul>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://bluestein.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://bluestein.github.io/tags/iOS/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Swift" scheme="http://bluestein.github.io/categories/Dev/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[enumerations]]></title>
    <link href="http://bluestein.github.io/2015/12/swift-enumerations/"/>
    <id>http://bluestein.github.io/2015/12/swift-enumerations/</id>
    <published>2015-12-21T09:53:33.000Z</published>
    <updated>2015-12-30T06:11:55.386Z</updated>
    <content type="html"><![CDATA[<h3 id="Syntax">Syntax</h3><p>使用 <code>enum</code> 关键字引出 enumeration 的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">	<span class="comment">// enumeration definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>下面是一个 compass 的例子，使用 <code>case</code> 来引出 enumeration 的各项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span> </span>&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="type">North</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">South</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">East</span></span><br><span class="line">	<span class="keyword">case</span> <span class="type">West</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>跟C或C++不同的是，上面例子中的 <code>North</code>, <code>South</code>, <code>East</code>, <code>Weat</code> 并不会隐式地声明为 0, 1, 2, 3，需要 <code>CompassPoint</code> 显示的定义。</p>
</blockquote>
<p>当有多个时，如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> planet = <span class="type">Planet</span>.<span class="type">Mercury</span></span><br><span class="line">planet = .<span class="type">Saturn</span></span><br></pre></td></tr></table></figure>
<p>使用enum定义后都是一种类型。<br><code>planet</code> 被一个 <code>Planet</code> 初始化之后，它就可以被赋以该类型的其他值而不需要重新标明该类型。</p>
<h3 id="matching_enumeration_with_a_switch_statement">matching enumeration with a switch statement</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> direction = <span class="type">CompassPoint</span>.<span class="type">South</span></span><br><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Where the sun rise"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">West</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Where skies are blue"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch 必须是详尽彻底的，即 <code>case</code> 必须包含所有的情况，不然应该加上 <code>default</code> 分支：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> direction &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">North</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Lots of planets have a north"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">South</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Watch out for penguins"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">East</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Where the sun rise"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="associated_values">associated values</h3><p>可以给枚举来存放任何类型的值，例如条形码的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Barcode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">UPCA</span>(<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">QRCode</span>(<span class="type">String</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UPCA</code> 存放的是包含四个 Int 型的元组，<code>QRCode</code> 则为 String。可以给它们赋值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> productBarcode = <span class="type">Barcode</span>.<span class="type">UPCA</span>(<span class="number">8</span>, <span class="number">8590</span>, <span class="number">51226</span>, <span class="number">3</span>)</span><br><span class="line">productBarcode = .<span class="type">QRCode</span>(<span class="string">"ABCDEFGHIJKLMN"</span>)</span><br></pre></td></tr></table></figure>
<p>还可以将枚举中的相关值取出来作为一个 constant (let) 或 variable (var)：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="type">UPCA</span>(<span class="keyword">let</span> numberSystem, <span class="keyword">let</span> manufacturer, <span class="keyword">let</span> product, <span class="keyword">let</span> check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> .<span class="type">QRCode</span>(<span class="keyword">let</span> productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当取出的值均为同一类型时，可以将 let 或 var 提出来，下面代码与上面等价：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> productBarcode &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span>  .<span class="type">UPCA</span>(numberSystem, manufacturer, product, check):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"UPC-A: <span class="subst">\(numberSystem)</span>, <span class="subst">\(manufacturer)</span>, <span class="subst">\(product)</span>, <span class="subst">\(check)</span>"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">QRCode</span>(productCode):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"QR code: <span class="subst">\(productCode)</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="raw_values">raw values</h3><p>一个叫 <code>ASCIIControlCharacter</code> 的枚举存放的是 Character 类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ASCIIControlCharacter</span>: <span class="title">Character</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Tab</span> = <span class="string">"\t"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">LineFeed</span> = <span class="string">"\n"</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">CarriageReturn</span> = <span class="string">"\r"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>raw value 可以是 string，character，int，float，每个 raw value 必须唯一。</p>
<blockquote>
<p>raw value 与 associated value 不同，raw value 是预设的值。</p>
</blockquote>
<h3 id="Implicitly_Assigned_raw_value">Implicitly Assigned raw value</h3><p>隐式指定的 raw value 是指当指定了 raw type 时，每个值会比前一个大1，如果第一个未指定时，则赋为 0 ，依次增加。还是前面的 <code>Planet</code> 例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Mercury</span> = <span class="number">1</span>, <span class="type">Venus</span>, <span class="type">Earth</span>, <span class="type">Mars</span>, <span class="type">Jupiter</span>, <span class="type">Saturn</span>, <span class="type">Uranus</span>, <span class="type">Neptune</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Planet</span>.<span class="type">Mercury</span>.rawValue <span class="comment">// prints "0"</span></span><br><span class="line"><span class="type">Planet</span>.<span class="type">Earth</span>.rawValue <span class="comment">// prints "4"</span></span><br></pre></td></tr></table></figure>
<p>如果 raw type 为 String 时，隐式值为 case name：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompassPoint</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">North</span>, <span class="type">South</span>, <span class="type">East</span>, <span class="type">West</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">CompassPoint</span>.<span class="type">North</span>.rawValue <span class="comment">// prints "North"</span></span><br></pre></td></tr></table></figure>
<h3 id="initializing_from_a_raw_value">initializing from a raw value</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblePlanet = <span class="type">Planet</span>(rawValue: <span class="number">7</span>)</span><br><span class="line"><span class="comment">// possiblePlanet 是 Planet? 类型，等于 Planet.Uranus</span></span><br></pre></td></tr></table></figure>
<p>因为初始化时，可能会超过界限，这就是为什么 <code>possiblePlanet</code> 为 <code>Planet?</code> 类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> positionToFind = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> somePlanet = <span class="type">Planet_raw</span>(rawValue: positionToFind) &#123;</span><br><span class="line">    <span class="keyword">switch</span> somePlanet &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Earth</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Mostly Harmless"</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Not a safe place for humans"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There isn't a planet at position <span class="subst">\(positionToFind)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints "There isn't a planet at position 9"</span></span><br></pre></td></tr></table></figure>
<h3 id="recursive_enumrarions">recursive enumrarions</h3><p>像算术表达式一样可以嵌套 (5 + 4) * 2 ，要枚举支持嵌套（递归），需要用 <code>indirect</code> 关键字标明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">indirect</span> <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以把 <code>indirect</code> 放在外面，使所有 case 都支持 recursive：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">indirect</span> <span class="class"><span class="keyword">enum</span> <span class="title">ArithmeticExpression</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Addition</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Multiplication</span>(<span class="type">ArithmeticExpression</span>, <span class="type">ArithmeticExpression</span>)</span><br></pre></td></tr></table></figure>
<p>这个枚举类型包含三个算术表达式：一个数字，两个数相加，两个数相乘。用法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(expression: ArithmeticExpression)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> expression &#123;</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Number</span>(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Addition</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) + evaluate(<span class="keyword">right</span>)</span><br><span class="line">    <span class="keyword">case</span> .<span class="type">Multiplication</span>(<span class="keyword">let</span> <span class="keyword">left</span>, <span class="keyword">let</span> <span class="keyword">right</span>):</span><br><span class="line">        <span class="keyword">return</span> evaluate(<span class="keyword">left</span>) * evaluate(<span class="keyword">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluate (5 + 4) * 2</span></span><br><span class="line"><span class="keyword">let</span> five = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">let</span> four = <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> sum = <span class="type">ArithmeticExpression</span>.<span class="type">Addition</span>(five, four)</span><br><span class="line"><span class="keyword">let</span> product = <span class="type">ArithmeticExpression</span>.<span class="type">Multiplication</span>(sum, <span class="type">ArithmeticExpression</span>.<span class="type">Number</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(evaluate(product))<span class="comment">// prints "18"</span></span><br></pre></td></tr></table></figure>
<p>这个函数将数字进行简单的返回，而“加法”和“乘法”则 evaluate <code>left</code> 和 <code>right</code>，然后相加或相乘。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Syntax">Syntax</h3><p>使用 <code>enum</code> 关键字引出 enumeration 的定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SomeEnumeration</span> </span>&#123;</span><br><span class="line">	<span class="comment">// enumeration definition goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://bluestein.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://bluestein.github.io/tags/iOS/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Swift" scheme="http://bluestein.github.io/categories/Dev/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[functions]]></title>
    <link href="http://bluestein.github.io/2015/12/swift-functions/"/>
    <id>http://bluestein.github.io/2015/12/swift-functions/</id>
    <published>2015-12-20T11:53:33.000Z</published>
    <updated>2015-12-30T06:11:50.020Z</updated>
    <content type="html"><![CDATA[<h3 id="defining_and_calling">defining and calling</h3><p>以定义一个 <code>sayHello(_:)</code> 函数作为例子：该函数将一个人的名字作为输入，以一句问候作为返回值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	<span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>输入类型: <code>String</code></li>
<li>返回值类型： <code>String</code><blockquote>
<p>说明： 函数的定义，以 <code>func</code> 作为关键字，后面跟该函数的名字，使用 <code>:</code> 指定参数的类型， <code>-&gt;</code> 指定返回值的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Anna!"</span></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Brian"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Brian!"</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>使用 <code>print(_:separator:terminator:)</code> 来打印输出。</p>
<h3 id="parameters_and_return_values">parameters and return values</h3><p>swift中的函数的参数和返回值可以是任何类型，甚至可以是函数类型（在swift中，函数也是一种类型，后面会讲到）。</p>
<p><strong>without parameters</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; string &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>multiple parameters</strong></p>
<p>多个参数时，用逗号隔开即可：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> already_greeted &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sayHello(personName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">false</span>))</span><br></pre></td></tr></table></figure></p>
<p>调用的形式是 <code>sayHello(_:alreadyGreeted:)</code>，通常第一个参数名后面的所有参数名需要标明。</p>
<p><strong>without return value</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sayBye(personName: String) &#123;</span><br><span class="line">	print("Goodbye, \(personName)!)</span><br><span class="line">&#125;</span><br><span class="line">sayBye("Dave")</span><br></pre></td></tr></table></figure>
<blockquote>
<p>严格地说，<code>sayBye(_:)</code> 还是有返回值的，为 <code>Void</code> 类型， 记作 <code>()</code>。</p>
</blockquote>
<p><strong>multiple return values</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">		<span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">			currentMin = value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">			currentMax = value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, -<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min: <span class="subst">\(bounds.<span class="built_in">min</span>)</span>, max: <span class="subst">\(bounds.<span class="built_in">max</span>)</span>."</span>)</span><br></pre></td></tr></table></figure>
<p>把多个返回值当成一个元组返回。<br>但如果，用户传入的数组为空则会出错，此时需要使用 <code>optional tuple</code>， 即 <code>(Int, Int)?</code>，上述程序改成：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">	<span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">		<span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">			currentMin = value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">			currentMax = value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, -<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min: <span class="subst">\(bounds.<span class="built_in">min</span>)</span>, max: <span class="subst">\(bounds.<span class="built_in">max</span>)</span>."</span>)</span><br><span class="line"><span class="comment">// as above</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(minMax(emptyArray))</span><br><span class="line"><span class="comment">// prints "nil"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="functon_names">functon names</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(fisrtParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，省略了第一个参数额外参数，其他则使用 <code>local name</code> 作为 <code>external name</code></p>
<p><strong>external parameter names</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(externalParameterName localParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(externalParameterName: <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>omitting external names</strong></p>
<p>使用下划线 <code>_</code> 来替代，则调用时不用标明external names：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(fisrtParameterName: Int, <span class="number">_</span> secondParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h3 id="default_parameter_values">default parameter values</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(localParameterName: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>)</span><br><span class="line">someFuction()</span><br></pre></td></tr></table></figure>
<p><strong>variadic parameters</strong></p>
<p>参数个数可变的情况，在参数的类型后面使用 <code>...</code> 来表示该类型的参数可以不确定：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">		total += number</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">1.5</span>, <span class="number">14.75</span>)</span><br></pre></td></tr></table></figure>
<p><strong>constant and variable parameter</strong></p>
<p>一般来说函数为常量参数，但也可以用变量参数。使用 <code>var</code> 来表明变量参数，这样就可以改变该变量的值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">alignRight</span><span class="params">(<span class="keyword">var</span> sting: String, totalLength: Int, pad: Character)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> amountToPad = totalLength - string.characters.<span class="built_in">count</span></span><br><span class="line">	<span class="keyword">if</span> amountToPad &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> string</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> padString = <span class="type">String</span>(pad)</span><br><span class="line">	<span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...amountToPad &#123;</span><br><span class="line">		string = padString + string</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> paddesString = alginRigth(originalString, totalLength: <span class="number">10</span>, pad: </span><br><span class="line"><span class="string">"-"</span>)</span><br><span class="line"><span class="comment">// prints "-----hello"</span></span><br></pre></td></tr></table></figure>
<p><strong>in-out parameters</strong></p>
<p>上面所说的变量参数，只能在当前函数内可以改变它的值，如果想要永久改变一个值则需要需用 <code>inout</code> 关键字标明。并且调用时需要在变量前加上 <code>&amp;</code> 符号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">	<span class="keyword">let</span> temporaryA = a</span><br><span class="line">	a = b</span><br><span class="line">	b = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">3</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br></pre></td></tr></table></figure></p>
<h3 id="Function_types">Function types</h3><p>swift把函数也当作一种类型看待，可以像 <code>Int</code> 那样进行操作：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a+ b</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数都可以记作为 <code>(Int, Int) -&gt; Int</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则可以看做 <code>() -&gt; Void</code>。</p>
<p><strong>using function type</strong></p>
<p>把 <code>addTwoInts</code> 函数当成是一种类型赋给 <code>mathFunction</code> 变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">1</span>, <span class="number">2</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 3"</span></span><br></pre></td></tr></table></figure>
<p>前面说到， <code>addTwoInts</code> 和 <code>multiplyTwoInts</code> 函数在形式上是一致的，则下面代码也成立：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathFunction = multiplyTwoInts</span><br></pre></td></tr></table></figure>
<p><strong>function types as parameter type</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; int, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">prints <span class="string">"Result: 8"</span></span><br></pre></td></tr></table></figure>
<p>很容易看懂， <code>printMathResult(_:_:_:)</code> 函数有三个参数，分别是：<code>(Int, Int) -&gt; int</code>, <code>Int</code> 和 <code>Int</code>。</p>
<p><strong>function types as return types</strong></p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStep</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然 <code>chooseStep(:)</code> 函数使用 <code>(Int) -&gt; Int</code> 类型的函数作为返回值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZearo = chooseStep(value &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="keyword">while</span> value != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>..."</span>)</span><br><span class="line">	value = moveNearerToZero(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
<h3 id="Nested_function">Nested function</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStep</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = -<span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZearo = chooseStep(value &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="keyword">while</span> value != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>..."</span>)</span><br><span class="line">	value = moveNearerToZero(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="defining_and_calling">defining and calling</h3><p>以定义一个 <code>sayHello(_:)</code> 函数作为例子：该函数将一个人的名字作为输入，以一句问候作为返回值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	<span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Swift" scheme="http://bluestein.github.io/tags/Swift/"/>
    
      <category term="iOS" scheme="http://bluestein.github.io/tags/iOS/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Swift" scheme="http://bluestein.github.io/categories/Dev/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[语句]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-primer4-19/"/>
    <id>http://bluestein.github.io/2015/12/cpp-primer4-19/</id>
    <published>2015-12-17T08:13:33.000Z</published>
    <updated>2015-12-30T06:13:20.882Z</updated>
    <content type="html"><![CDATA[<p>开始学习第六章《语句》</p>
<h3 id="1、简单语句">1、简单语句</h3><p><strong>空语句</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<p>只有一个分号。在某些条件下使用，如从输入流读入数据，而不需操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> （<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">	;	<span class="comment">// null statement</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用空语句时最好加上注释</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + <span class="number">1</span>;;</span><br></pre></td></tr></table></figure>
<p>看似非法的分号，其实是一个空语句。但并不意味着就能随便使用，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iter != vec.end()) ;	<span class="comment">// while循环体为空</span></span><br><span class="line">	++iter;	<span class="comment">// 不是循环体的一部分</span></span><br></pre></td></tr></table></figure>
<p>会无限循环。</p>
<p><strong>复合语句（块）</strong></p>
<p>用花括号括起来的语句序列（也可能为空）。如 for 和 while</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; trans)</span><br><span class="line">	<span class="keyword">if</span> (total.same_isbn(trans))</span><br><span class="line">		total = total + trans;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">		total = trans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>else</code> 分支需要用块语句。</p>
<blockquote>
<p>块语句并不是以分号结束</p>
</blockquote>
<p>也可以是 <strong>空块</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">&#123;&#125;	<span class="comment">// 空块</span></span><br></pre></td></tr></table></figure>
<p><strong>语句作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">int</span> i = get_num())</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="number">0</span>;	<span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><code>i</code> 超出了作用域。</p>
<p><strong>控制结构中引入的变量是局部变量</strong>，仅在块语句结束前有效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type index = <span class="number">0</span>;</span><br><span class="line">		index != vec.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> square = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (index % <span class="number">2</span>)</span><br><span class="line">		square = index * index;</span><br><span class="line">	vec[index] = square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != vec.size())	<span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>如果要在控制语句外访问，则需定义在控制语句外<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (; index != vec.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> square = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (index % <span class="number">2</span>)</span><br><span class="line">		square = index * index;</span><br><span class="line">	vec[index] = square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != vec.size())	<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、if语句">2、if语句</h3><p><strong>if语句</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">	statement1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">&#123;</span><br><span class="line">	staement2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	staement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前为止，除了 vector 和 string 类型一般不可作为条件外，均可作为if语句的条件，包括 IO 类型。</p>
<blockquote>
<p>各分支语句用 <code>{}</code> 括起来是一个好的习惯</p>
</blockquote>
<p><strong>if语句可以嵌套</strong></p>
<p>例如，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (condition2)</span><br><span class="line">	&#123;</span><br><span class="line">		statement1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		staement2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// use if statement here also valid</span></span><br><span class="line">	staement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始学习第六章《语句》</p>
<h3 id="1、简单语句">1、简单语句</h3><p><strong>空语句</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<p>只有一个分号。在某些条件下使用，如从输入流读入数据，而不需操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> （<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">	;	<span class="comment">// null statement</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用空语句时最好加上注释</p>
</blockquote>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[if语句]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-4/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-4/</id>
    <published>2015-12-17T07:32:42.000Z</published>
    <updated>2015-12-30T06:17:31.506Z</updated>
    <content type="html"><![CDATA[<h3 id="Example">Example</h3><p>寻找vector中的最小值，并记录这个最小值出现的次数。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ivec.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这两步是为了制造最小值</span></span><br><span class="line">	ivec[<span class="number">0</span>] = ivec[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">	ivec[<span class="number">5</span>] = ivec[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> min_val = ivec[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> min_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ivec.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (min_val == ivec[i])</span><br><span class="line">		&#123;</span><br><span class="line">			++min_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (min_val &gt; ivec[i])</span><br><span class="line">		&#123;</span><br><span class="line">			min_val = ivec[i];</span><br><span class="line">			min_cnt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"min value: "</span>&lt;&lt; min_val &lt;&lt;<span class="string">", count: "</span>&lt;&lt; min_cnt &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">min value: <span class="number">0</span>, count: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Example">Example</h3><p>寻找vector中的最小值，并记录这个最小值出现的次数。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: 账户的创建和配置]]></title>
    <link href="http://bluestein.github.io/2015/12/github-1/"/>
    <id>http://bluestein.github.io/2015/12/github-1/</id>
    <published>2015-12-04T04:54:49.000Z</published>
    <updated>2015-12-30T01:47:21.954Z</updated>
    <content type="html"><![CDATA[<p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p>
<a id="more"></a>
<h3 id="账户的创建和配置">账户的创建和配置</h3><p>你所需要做的第一件事是创建一个免费账户。 直接访问 <a href="https://github.com" target="_blank" rel="external">Github</a>，选择一个未被占用的用户名，提供一个电子邮件地址和密码，点击写着“Sign up for GitHub”的绿色大按钮即可。</p>
<blockquote>
<p>GitHub 为免费账户提供了完整功能，限制是你的项目都将被完全公开（每个人都具有读权限）。 GitHub 的付费计划可以让你拥有一定数目的私有项目。</p>
</blockquote>
<h3 id="SSH_访问">SSH 访问</h3><p>现在，你完全可以使用 https:// 协议，通过你刚刚创建的用户名和密码访问 Git 版本库。 但是，如果仅仅克隆公有项目，你甚至不需要注册——刚刚我们创建的账户是为了以后 fork 其它项目，以及推送我们自己的修改。</p>
<p>如果你习惯使用 SSH 远程，你需要配置一个公钥 (public key)。</p>
<p>SSH key 的生成过程请查看 <a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">github generating-ssh-keys</a>。</p>
<p>点击头像下得“Settings”，然后在左侧选择“SSH keys”部分。在这个页面点击“Add an SSH key”按钮，给你的公钥起一个名字，将你的 <code>~/.ssh/id_rsa.pub</code>（或者自定义的其它名字）公钥文件的内容粘贴到文本区，然后点击“Add key”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p>]]>
    
    </summary>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github + Hexo" scheme="http://bluestein.github.io/categories/Github-Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 分支]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-4/"/>
    <id>http://bluestein.github.io/2015/12/github-git-4/</id>
    <published>2015-12-03T07:54:49.000Z</published>
    <updated>2015-12-21T02:19:23.668Z</updated>
    <content type="html"><![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-3/">Github: Git的使用 - 撤销操作</a>，下面继续介绍git的更多用法。</p>
<h3 id="4、分支">4、分支</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="external">官网教程</a>。</p>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<a id="more"></a>
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了说得更加形象，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和使用 SHA-1 哈希算法，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m <span class="string">'The initial commit of my project'</span></span><br></pre></td></tr></table></figure>
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<blockquote>
<p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<p><strong>分支创建</strong></p>
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>
<p>这会在当前所在的提交对象上创建一个指针。</p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。</p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate</span><br></pre></td></tr></table></figure>
<p><strong>分支切换</strong></p>
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<p>这样 HEAD 就指向 <code>testing</code> 分支了。</p>
<h3 id="4、分支的新建与合并">4、分支的新建与合并</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="external">官网教程</a>。</p>
<p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p>
<ol>
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<p><strong>新建分支</strong></p>
<p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 <code>#53</code> 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch <span class="string">"iss53"</span></span><br></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>
<p>你继续在 <code>#53</code> 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="operator">-a</span> -m <span class="string">'added a new footer [issue 53]'</span></span><br></pre></td></tr></table></figure>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 <code>53#</code> 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>这个时候，你的工作目录和你在开始 <code>#53</code> 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch <span class="string">'hotfix'</span></span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit <span class="operator">-a</span> -m <span class="string">'fixed the broken email address'</span></span><br><span class="line">[hotfix <span class="number">1</span>fb7853] fixed the broken email address</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span><br></pre></td></tr></table></figure>
<p>你在 hotfix 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p>
<p><strong>分支的合并</strong></p>
<p>假设你已经修正了 <code>#53</code> 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line">index.html |    <span class="number">1</span> +</span><br><span class="line"><span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p><strong>遇到冲突时的分支合并</strong></p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure>
<p><strong>分支管理</strong></p>
<p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86" target="_blank" rel="external">官网教程</a>。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-3/">Github: Git的使用 - 撤销操作</a>，下面继续介绍git的更多用法。</p>
<h3 id="4、分支">4、分支</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">官网教程</a>。</p>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github + Hexo" scheme="http://bluestein.github.io/categories/Github-Hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 撤销操作]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-3/"/>
    <id>http://bluestein.github.io/2015/12/github-git-3/</id>
    <published>2015-12-03T06:54:49.000Z</published>
    <updated>2015-12-21T02:19:23.665Z</updated>
    <content type="html"><![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-2/">Github: Git的使用 - 历史记录</a>的第三小节，下面继续介绍git的更多用法。</p>
<h3 id="3-4、撤消操作">3.4、撤消操作</h3><p><strong>撤消操作</strong></p>
<p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<a id="more"></a>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'initial commit'</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<p><strong>取消暂存的文件</strong></p>
<p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。</p>
<p><strong>撤消对文件的修改</strong></p>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改: 使用 <code>git checkout -- &lt;file&gt;...</code>。</p>
<blockquote>
<p>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>
</blockquote>
<h3 id="3-5、远程仓库的使用">3.5、远程仓库的使用</h3><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/bluestein/hexo-theme-allgreen.git</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> hexo-theme-allgreen</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/bluestein/hexo-theme-allgreen.git (fetch)</span><br><span class="line">origin	https://github.com/bluestein/hexo-theme-allgreen.git (push)</span><br></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit.git (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit.git (push)</span><br><span class="line">cho45     https://github.com/cho45/grit.git (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit.git (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit.git (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit.git (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限。</p>
<p><strong>添加远程仓库</strong></p>
<p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/schacon/ticgit.git (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit.git (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit.git (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit.git (push)</span><br></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br></pre></td></tr></table></figure>
<p><strong>从远程仓库中抓取与拉取</strong></p>
<p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="http://bluestein.github.io/2015/12/github-git-4/">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<p><strong>推送到远程仓库</strong></p>
<p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure>
<p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p>
<p><strong>远程仓库的移除与重命名</strong></p>
<p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-2/">Github: Git的使用 - 历史记录</a>的第三小节，下面继续介绍git的更多用法。</p>
<h3 id="3-4、撤消操作">3.4、撤消操作</h3><p><strong>撤消操作</strong></p>
<p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github + Hexo" scheme="http://bluestein.github.io/categories/Github-Hexo/"/>
    
  </entry>
  
</feed>
