<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo's Blog]]></title>
  <subtitle><![CDATA[Everything will be ok]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2015-11-30T15:28:16.283Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hexo3.1.1 + github pages教程：添加多说评论系统]]></title>
    <link href="http://bluestein.github.io/2015/11/hexo-github-1/"/>
    <id>http://bluestein.github.io/2015/11/hexo-github-1/</id>
    <published>2015-11-30T07:54:49.000Z</published>
    <updated>2015-11-30T15:28:16.283Z</updated>
    <content type="html"><![CDATA[<h3 id="一、添加多说ID(必须)">一、添加多说ID(必须)</h3><p>在根目录的 <code>_config.yml</code> 中定义 <code>duoshuo_shortname: (你的多说ID)</code> 形如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comments</span><br><span class="line">duoshuo_shortname: (你的多说ID)</span><br></pre></td></tr></table></figure>
<h3 id="二、引入多说JS(必须)">二、引入多说JS(必须)</h3><a id="more"></a>
<p>将 <code>themes/(你的主题)/layout/_partial/after-footer.ejs</code> 中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (config.disqus_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">  <span class="keyword">var</span> disqus_shortname = <span class="string">'&lt;%= config.disqus_shortname %&gt;'</span>;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (page.permalink)&#123; %&gt;</span><br><span class="line">  <span class="keyword">var</span> disqus_url = <span class="string">'&lt;%= page.permalink %&gt;'</span>;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dsq = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    dsq.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    dsq.async = <span class="literal">true</span>;</span><br><span class="line">    dsq.src = <span class="string">'//'</span> + disqus_shortname + <span class="string">'.disqus.com/&lt;% if (page.comments) &#123; %&gt;embed.js&lt;% &#125; else &#123; %&gt;count.js&lt;% &#125; %&gt;'</span>;</span><br><span class="line">    (document.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>] || document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(dsq);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>部分修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> duoshuoQuery = &#123;short_name:<span class="string">"你的多说ID"</span>&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</span><br><span class="line">    ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</span><br><span class="line">    ds.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>] </span><br><span class="line">     || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这个步骤是全局引入多说js，后面就可以直接使用了。</p>
<h3 id="三、引入多说评论窗口(必须)">三、引入多说评论窗口(必须)</h3><p><strong>首先，</strong>将 <code>themes/(你的主题)/layout/_partial/article.ejs</code> 中的下面部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-footer"</span>&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span> <span class="attribute">data-id</span>=<span class="value">"&lt;%= post._id %&gt;"</span> <span class="attribute">class</span>=<span class="value">"article-share-link"</span>&gt;</span>Share<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">config.disqus_shortname</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"&lt;%- post.permalink %&gt;#disqus_thread"</span> <span class="attribute">class</span>=<span class="value">"article-comment-link"</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%-</span> <span class="attribute">partial</span>('<span class="attribute">post</span>/<span class="attribute">tag</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-footer"</span>&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span> <span class="attribute">data-id</span>=<span class="value">"&lt;%= post._id %&gt;"</span> <span class="attribute">class</span>=<span class="value">"article-share-link"</span>&gt;</span>Share<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">config.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"&lt;%- post.permalink %&gt;#duoshuo_thread"</span> <span class="attribute">class</span>=<span class="value">"article-comment-link"</span>&gt;</span>评论<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%-</span> <span class="attribute">partial</span>('<span class="attribute">post</span>/<span class="attribute">tag</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>其次，</strong>将同一文件，即 <code>article.ejs</code> 中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"disqus_thread"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"duoshuo_thread"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>至此，多说的评论功能基本可以用了。</p>
<h3 id="四、引入多说的分享插件(可选)">四、引入多说的分享插件(可选)</h3><p>在 <code>themes/(你的主题)/layout/_partial/article.ejs</code> 文件的末尾添加下列代码即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-images</span>=<span class="value">""</span> <span class="attribute">data-content</span>=<span class="value">"&lt;%= post.content %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-right"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-inner"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-toggle"</span>&gt;</span>分享<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：请注意替换 <code>你的多说ID</code> 和 <code>你的主题</code></p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、添加多说ID(必须)">一、添加多说ID(必须)</h3><p>在根目录的 <code>_config.yml</code> 中定义 <code>duoshuo_shortname: (你的多说ID)</code> 形如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comments</span><br><span class="line">duoshuo_shortname: (你的多说ID)</span><br></pre></td></tr></table></figure>
<h3 id="二、引入多说JS(必须)">二、引入多说JS(必须)</h3>]]>
    
    </summary>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="github pages" scheme="http://bluestein.github.io/tags/github-pages/"/>
    
      <category term="hexo" scheme="http://bluestein.github.io/tags/hexo/"/>
    
      <category term="Hexo" scheme="http://bluestein.github.io/categories/Hexo/"/>
    
      <category term="guide" scheme="http://bluestein.github.io/categories/Hexo/guide/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[18:类型转换]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-18/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-18/</id>
    <published>2015-11-28T08:50:29.000Z</published>
    <updated>2015-11-30T02:58:11.205Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[17:new & delete]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-17/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-17/</id>
    <published>2015-11-27T08:50:24.000Z</published>
    <updated>2015-11-30T02:57:58.047Z</updated>
    <content type="html"><![CDATA[<p><strong>1、动态创建对象的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>);	<span class="comment">//*ip = 1024</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">'9'</span>)</span></span>;	<span class="comment">//s = "9999999999"</span></span><br><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>);	<span class="comment">//*sp = "9999999999"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>2、动态创建对象的默认初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>;	<span class="comment">//空string</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>
<p>可以利用下列方式进行默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>();	<span class="comment">//空string</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>();	<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p><strong>3、撤销动态创建对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"str"</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">int</span> *ip0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s;	<span class="comment">//error: s是非动态对象</span></span><br><span class="line"><span class="keyword">delete</span> ip;	<span class="comment">//error: ip指向本地对象</span></span><br><span class="line"><span class="keyword">delete</span> dp;	<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ip0;	<span class="comment">//ok: 但没什么意义</span></span><br></pre></td></tr></table></figure>
<p>C++未明确定义如何释放非new分配的内存地址。</p>
<p><strong>4、delete后重设指针的值</strong></p>
<p>执行delete语句后，尽管指针变成未定义，但仍存放了之前所指对象的地址，称为 <strong>悬挂指针（dangling pointer）</strong> 。这种指针往往容易出错。</p>
<blockquote>
<p>一旦delete指针，立即将其置为0，就可以避免悬挂指针。</p>
</blockquote>
<p><strong>5、const对象的动态分配和回收</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cip = <span class="keyword">new</span> <span class="function"><span class="keyword">const</span> <span class="title">int</span><span class="params">(<span class="number">1024</span>)</span></span>;	<span class="comment">//必须初始化，且不能再修改</span></span><br></pre></td></tr></table></figure>
<p>如果有默认构造函数，则可以隐式初始化，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *csp = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>尽管不能改变const对象的值，但可撤销对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> cip;	<span class="comment">//ok</span></span><br><span class="line">cip = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、动态创建对象的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>);	<span class="comment">//*ip = 1024</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">'9'</span>)</span></span>;	<span class="comment">//s = "9999999999"</span></span><br><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>);	<span class="comment">//*sp = "9999999999"</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[16:赋值操作和自增自减]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-16/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-16/</id>
    <published>2015-11-26T08:50:15.000Z</published>
    <updated>2015-11-30T02:57:58.044Z</updated>
    <content type="html"><![CDATA[<p>本次内容是：复合表达式的求值。尤其是 <strong>优先级</strong> 和 <strong>结合性</strong> 部分可以作为字典查看。</p>
<h3 id="1、优先级">1、优先级</h3><p>在表达式求解过程中，优先级关系到表示如何分组，会影响整个表达式的值。其次是结合性，当优先级相同时，结合性决定求解次序。算术操作符具有左结合性，即从左至右结合</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">2</span> * <span class="number">3</span> / <span class="number">2</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = <span class="number">2</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> tmp3 = tmp2 + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> result = tmp3 - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>括号可以改变优先级，括号内的表达式先行计算。</p>
</blockquote>
<h3 id="2、结合性">2、结合性</h3><p>结合性规定了具有相同优先级的操作符如何分组。如 <strong>赋值操作符</strong> <code>=</code> 具有右结合性，所以允许将多个赋值操作串连起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 = val2 = val3;</span><br><span class="line">(val1 = (val2 = val3));	<span class="comment">//与上式等价</span></span><br></pre></td></tr></table></figure>
<p>而 <strong>算术操作符</strong> 具有右结合性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 * val2 / val3;</span><br><span class="line">((val1 * val2) / val3);	<span class="comment">//与上式等价</span></span><br></pre></td></tr></table></figure>
<p>下表是按照优先级顺序给出操作符，并用空行分成不同的段，每段内的优先级相同，且都高于后面各段的优先级。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>结合性</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>::</td>
<td>L</td>
<td>全局作用域</td>
<td>::name</td>
</tr>
<tr>
<td>::</td>
<td>L</td>
<td>类作用域</td>
<td>class::name</td>
</tr>
<tr>
<td>::</td>
<td>L</td>
<td>名字空间作用域</td>
<td>namespace::name</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>.</td>
<td>L</td>
<td>成员选择</td>
<td>object.member</td>
</tr>
<tr>
<td>-&gt;</td>
<td>L</td>
<td>成员选择</td>
<td>pointer-&gt;member</td>
</tr>
<tr>
<td>[]</td>
<td>L</td>
<td>下标</td>
<td>variable[expr]</td>
</tr>
<tr>
<td>()</td>
<td>L</td>
<td>函数调用</td>
<td>name(expr_list)</td>
</tr>
<tr>
<td>()</td>
<td>L</td>
<td>函数构造</td>
<td>type(expr_list)</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>++</td>
<td>R</td>
<td>后自增</td>
<td>lvalue++</td>
</tr>
<tr>
<td>–</td>
<td>R</td>
<td>后自减</td>
<td>lvalue–</td>
</tr>
<tr>
<td>typeid</td>
<td>R</td>
<td>类型ID</td>
<td>typeid(type)</td>
</tr>
<tr>
<td>typeid</td>
<td>R</td>
<td>运行时ID</td>
<td>typeid(expr)</td>
</tr>
<tr>
<td>显式强制类型转换</td>
<td>R</td>
<td>类型转换</td>
<td>cast_name<type>(expr)</type></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>sizeof</td>
<td>R</td>
<td>对象大小</td>
<td>sizeof expr</td>
</tr>
<tr>
<td>sizeof</td>
<td>R</td>
<td>类型大小</td>
<td>sizeof(type)</td>
</tr>
<tr>
<td>++</td>
<td>R</td>
<td>前自增</td>
<td>++lvalue</td>
</tr>
<tr>
<td>–</td>
<td>R</td>
<td>前自减</td>
<td>–lvalue</td>
</tr>
<tr>
<td>~</td>
<td>R</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>!</td>
<td>R</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>-</td>
<td>R</td>
<td>一元负号</td>
<td>-expr</td>
</tr>
<tr>
<td>+</td>
<td>R</td>
<td>一元正号</td>
<td>+expr</td>
</tr>
<tr>
<td>*</td>
<td>R</td>
<td>解引用</td>
<td>*expr</td>
</tr>
<tr>
<td>&amp;</td>
<td>R</td>
<td>取地址</td>
<td>&amp;expr</td>
</tr>
<tr>
<td>()</td>
<td>R</td>
<td>类型转换</td>
<td>(type)expr</td>
</tr>
<tr>
<td>new</td>
<td>R</td>
<td>创建对象</td>
<td>new type</td>
</tr>
<tr>
<td>delete</td>
<td>R</td>
<td>释放对象</td>
<td>delete expr</td>
</tr>
<tr>
<td>delete[]</td>
<td>R</td>
<td>释放数组</td>
<td>delete[] expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-&gt;*</td>
<td>L</td>
<td>指向成员操作的指针</td>
<td>ptr-&gt;*ptr_to_member</td>
</tr>
<tr>
<td>.*</td>
<td>L</td>
<td>指向成员操作的指针</td>
<td>obj.*ptr_to_member</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>L</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>/</td>
<td>L</td>
<td>除法</td>
<td>expr / expr</td>
</tr>
<tr>
<td>%</td>
<td>L</td>
<td>求模（求余）</td>
<td>expr % expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>L</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>L</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>L</td>
<td>位左移</td>
<td>expr &lt;&lt; expr</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>L</td>
<td>为右移</td>
<td>expr &gt;&gt; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&lt;</td>
<td>L</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>&lt;=</td>
<td>L</td>
<td>小等于</td>
<td>expr &lt;= expr</td>
</tr>
<tr>
<td>&gt;</td>
<td>L</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>&gt;=</td>
<td>L</td>
<td>大等于</td>
<td>expr &gt;= expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>==</td>
<td>L</td>
<td>等于</td>
<td>expr == expr</td>
</tr>
<tr>
<td>!=</td>
<td>L</td>
<td>不等于</td>
<td>expr != expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&amp;</td>
<td>L</td>
<td>位与</td>
<td>expr &amp; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>^</td>
<td>L</td>
<td>位异或</td>
<td>expr ^ expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&#124;</td>
<td>L</td>
<td>位或</td>
<td>expr &#124; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>L</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>L</td>
<td>逻辑或</td>
<td>expr &#124;&#124; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?:</td>
<td>R</td>
<td>条件操作</td>
<td>expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>=</td>
<td>R</td>
<td>赋值操作</td>
<td>lvalue = expr</td>
</tr>
<tr>
<td>*=, /=, %=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr *= expr等</td>
</tr>
<tr>
<td>+=, -=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr += expr等</td>
</tr>
<tr>
<td>&lt;&lt;=, &gt;&gt;=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr &lt;&lt;= expr等</td>
</tr>
<tr>
<td>&amp;=, &#124;=, ^=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr &amp;= expr等</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>throw</td>
<td>R</td>
<td>抛出异常</td>
<td>throw expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>,</td>
<td>R</td>
<td>逗号</td>
<td>expr, expr</td>
</tr>
</tbody>
</table>
<p><strong>举例</strong></p>
<p>考虑：如果字符串不是以’s’结尾则加上’s’，分析下列语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = s + s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>根据上表知道优先级为：<code>.</code> = <code>()</code> = <code>[]</code> &gt; <code>-</code> = <code>+</code> &gt; <code>==</code> &gt; <code>?:</code> &gt; <code>=</code>；可知上述语句的结合顺序是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">string</span> s = (((s + (s[(s.size()) - <span class="number">1</span>])) == <span class="string">'s'</span>) ? <span class="string">""</span> : <span class="string">"s"</span>));</span><br></pre></td></tr></table></figure>
<p>很明显不能得到想要的结果，改成如下形式即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = s + (s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>);</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本次内容是：复合表达式的求值。尤其是 <strong>优先级</strong> 和 <strong>结合性</strong> 部分可以作为字典查看。</p>
<h3 id="1、优先级">1、优先级</h3><p>在表达式求解过程中，优先级关系到表示如何分组，会影响整个表达式的值。其次是结合性，当优先级相同时，结合性决定求解次序。算术操作符具有左结合性，即从左至右结合</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[15:赋值操作和自增自减]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-15/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-15/</id>
    <published>2015-11-25T08:50:10.000Z</published>
    <updated>2015-11-30T02:57:58.041Z</updated>
    <content type="html"><![CDATA[<p><strong>1、赋值操作</strong></p>
<p>赋值的左操作数必须是非const左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;	<span class="comment">//ok</span></span><br><span class="line"><span class="number">1024</span> = val;		<span class="comment">//error: 字面值是右值</span></span><br><span class="line">i + j = val;	<span class="comment">//error: 算术运算结果是右值</span></span><br><span class="line">ci = val;		<span class="comment">//error: 不能赋值</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>右结合性</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val1, val2;</span><br><span class="line">val1 = val2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句将 val2 赋给 val1.但下面是错误的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val, *p;</span><br><span class="line">val = p = <span class="number">0</span>;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>上面: <code>p=0</code> 成立，但 <code>val = p</code> 出错。</p>
<p><strong>复合赋值操作符</strong></p>
<table>
<thead>
<tr>
<th>说明</th>
<th>操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术操作符</td>
<td>+= -= *= /= %=</td>
</tr>
<tr>
<td>位操作符</td>
<td>&lt;&lt;= &gt;&gt;= &amp;= ^= &#124;=</td>
</tr>
</tbody>
</table>
<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a op= b;	<span class="comment">//op表示操作符</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a op b;</span><br></pre></td></tr></table></figure>
<p><strong>2、自增自减</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;	<span class="comment">//j = 1, i = 1; ++i返回自增后的结果</span></span><br><span class="line">j = i++;	<span class="comment">//j = 1, i = 2; i++返回未自增的结果</span></span><br></pre></td></tr></table></figure>
<p><strong>组合使用解引用和自增</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = ivec.begin();</span><br><span class="line"><span class="keyword">while</span>(iter != ivec.end())&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++　&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自增的优先级高于解引用，即相当于 <code>*(iter++)</code>。</p>
<p><strong>箭头操作符</strong></p>
<p>C++为包含 <strong>点操作</strong> 和 <strong>解引用</strong> 的表达式提供 <strong>箭头操作符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Item *p = &amp;item1;</span><br><span class="line">(*p).func();	<span class="comment">//1</span></span><br><span class="line">p-&gt;func();		<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>1,2 等价。</p>
<p><strong>举例</strong></p>
<p>编写程序：定义vector对象，其每个元素指向string类型的指针；输出每个元素的内容及长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt; v;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(s);</span><br><span class="line">	v.push_back(sp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt;::iterator iter = v.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != v.end()) &#123;</span><br><span class="line">	<span class="built_in">string</span> *tmp = *iter;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tmp-&gt;size() &lt;&lt; <span class="string">", "</span> &lt;&lt; *tmp &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> tmp;</span><br><span class="line">	iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world!↙</span><br><span class="line">^Z↙</span><br><span class="line"><span class="number">5</span>, hello</span><br><span class="line"><span class="number">6</span>, world!</span><br></pre></td></tr></table></figure>
<p><strong>条件操作符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<p>先计算 <code>cond</code> 的值，如果为true，则计算 <code>expr1</code>，否则计算 <code>expr2</code>。可以嵌套使用，如：求三个数的最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = i &gt; j</span><br><span class="line">	? i &gt; k ? i : k</span><br><span class="line">	: j &gt; k ? j : k;</span><br></pre></td></tr></table></figure>
<p>但并不推荐这样做，可以换成下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = i;</span><br><span class="line"><span class="keyword">if</span> (j &gt; max)</span><br><span class="line">	max = j;</span><br><span class="line"><span class="keyword">if</span> (k &gt; max)</span><br><span class="line">	max = k;</span><br></pre></td></tr></table></figure>
<p>输出表达式中使用条件操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j?i:j) &lt;&lt;endl;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j)?i:j;	<span class="comment">//打印1或0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i&lt;j?i:j &lt;&lt;endl;		<span class="comment">//error: 将cout与int比较</span></span><br></pre></td></tr></table></figure>
<p>第二句相当于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j);	<span class="comment">//打印1或0，然后返回cout对象</span></span><br><span class="line"><span class="built_in">cout</span> ? i : j;	<span class="comment">//检测cout，然后计算i或j</span></span><br></pre></td></tr></table></figure>
<p><strong>sizeof操作符</strong></p>
<p>返回一个对象或类型名的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type_name);</span><br><span class="line"><span class="keyword">sizeof</span>(expr);</span><br><span class="line"><span class="keyword">sizeof</span> expr;</span><br></pre></td></tr></table></figure>
<ul>
<li>对char类型或char类型值做sizeof结果为1；</li>
<li>对指针，返回存放该指针所需的内存；若需要获得指针所指内容，需要解引用操作；</li>
<li>对数组，等价于对数组元素做sizeof再乘以元素的个数；</li>
</ul>
<p><strong>逗号操作符</strong></p>
<p>是一组由逗号分隔的表达式，这些表达式从左至右计算，结果是其最右边的表达式值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = vec.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != vec.size(); ++ix, --cnt)</span><br><span class="line">	vec[ix] = cnt;</span><br></pre></td></tr></table></figure>
<p>每次循环，ix自增1，cnt自减1.</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、赋值操作</strong></p>
<p>赋值的左操作数必须是非const左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;	<span class="comment">//ok</span></span><br><span class="line"><span class="number">1024</span> = val;		<span class="comment">//error: 字面值是右值</span></span><br><span class="line">i + j = val;	<span class="comment">//error: 算术运算结果是右值</span></span><br><span class="line">ci = val;		<span class="comment">//error: 不能赋值</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[14:位操作符]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-14/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-14/</id>
    <published>2015-11-24T08:50:05.000Z</published>
    <updated>2015-11-30T02:57:58.038Z</updated>
    <content type="html"><![CDATA[<p>位操作符：位操作符操作的整数可以是有符号或无符号数。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>求位反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>&#124;</td>
<td>位或</td>
<td>expr1 &#124; expr2</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>下面的例子，假设unsigned char有8位：</p>
<ul>
<li><p><code>~</code>: 类似于bitset的flip操作，即将操作数的每一个二进制位取反，将0置为1,1置为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">0227</span>;	<span class="comment">//八进制数，二进制形式：10010111</span></span><br><span class="line">bits = ~bits;	<span class="comment">//二进制形式：01101000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>: 向右或向左移动若干位，并丢弃移出去的位，一般来说空位补零</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">1</span>;	<span class="comment">//二进制形式：00000001</span></span><br><span class="line">bits = bits &lt;&lt; <span class="number">6</span>;	<span class="comment">//二进制形式：01000000；对应十进制：64</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt;endl;	<span class="comment">//64对应的字符为 bits = '@'</span></span><br><span class="line"><span class="keyword">int</span> n = bits;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; endl;	<span class="comment">//n = 64</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;</code>: 两操作数都为1时，结果为1，否则为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c1 = <span class="number">0145</span>;	<span class="comment">//八进制数，二进制形式：01100101</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c2 = <span class="number">0257</span>;	<span class="comment">//八进制数，二进制形式：10101111</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 &amp; c2;	<span class="comment">//二进制形式：00100101</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为37，字符为 '÷'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>^</code>: 两个操作数中只有一个位1时（不能同时两个为1），结果为1，否则为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 ^ c2;	<span class="comment">//二进制形式：11001010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为202</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>|</code>: 两个操作数都为0时，结果为0，否则为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 | c2;	<span class="comment">//二进制形式：11101011</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为239</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>bitset对象或整型值的使用</strong></p>
<p>unsigned long 有 32 位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;30&gt; bset;	<span class="comment">//大小为30的bitset，每一位默认值0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果要将第27位设为1，有如下两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bset.<span class="built_in">set</span>(<span class="number">27</span>);		<span class="comment">//法1</span></span><br><span class="line">val |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>;	<span class="comment">//法2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>法1简单明了；</li>
<li>法2：将val与另一个整数坐位或 <code>|</code> 比较。即需要一个只有第27位为1其他位为0的无符号长整型（unsigned long）整数，可以用下面方法生成<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1U</span>L &lt;&lt; <span class="number">27</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果要将第27位重新设为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= ~(<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p>而要测试第27位是否为1，则可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_1 = val &amp; (<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val1 = <span class="number">3</span>, val2 = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (val1 &amp; val2) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (val1 | val2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>因为unsigned long有32位，所以 3 对应二进制位为：<code>0(30个0)11</code>； 8 的二进制：<code>0(28个0)1000</code></p>
<ul>
<li><code>val1 &amp; val2</code>: 0(28个0)0000; 对应的十进制为 0</li>
<li><code>val1 | val2</code>: 0(28个0)1011; 对应的十进制为 11</li>
</ul>
<blockquote>
<p>通常来说，bitset更易阅读和理解。</p>
</blockquote>
<p><strong>将移位操作符用于IO</strong></p>
<p>一直再用的 <code>cout&lt;&lt;</code> 和 <code>cin&gt;&gt;</code> 就用到了移位操作符，IO操作符是左结合的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"he"</span> &lt;&lt; <span class="string">"llo"</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">cout</span> &lt;&lt; <span class="string">"he"</span>) &lt;&lt; <span class="string">"llo"</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span>+<span class="number">10</span>;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">10</span>&gt;<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> &gt; <span class="number">2</span>;	<span class="comment">//error: 试图将 cout 与 2 比较</span></span><br></pre></td></tr></table></figure>
<p>上例因为 <code>+</code> 优先级高于<code>&gt;&gt;</code>， 而  <code>&gt;</code> 低于 <code>&gt;&gt;</code>。 </p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>位操作符：位操作符操作的整数可以是有符号或无符号数。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>求位反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>&#124;</td>
<td>位或</td>
<td>expr1 &#124; expr2</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[13:算术操作符]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-13/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-13/</id>
    <published>2015-11-23T08:50:00.000Z</published>
    <updated>2015-11-30T02:57:58.035Z</updated>
    <content type="html"><![CDATA[<p>这里开始第五章《表达式》的内容。下面是 <strong>算术操作符</strong> 的内容</p>
<p>C++有丰富的操作符，并定义了当操作数是内置类型时操作符的含义。而且C++还支持操作符重载，标准库正是使用该功能定义。</p>
<a id="more"></a>
<p>表达式是由一个或多个 <strong>操作数（operand）</strong> 通过 <strong>操作符（operator）</strong> 组合而成。每个表达式会产生一个结果，如果表达式中无操作符，则表达式的结果就是操作数本身。如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val)</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>将 <code>val</code> 看作是if语句的条件表达式。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>expr / expr</td>
</tr>
<tr>
<td>%</td>
<td>求余（操作数只能为整型）</td>
<td>expr % expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注： expre 为表达式</p>
</blockquote>
<p>求模 <code>%</code> 符号：</p>
<ul>
<li>当两个操作数都是正数（或0）时，结果为正；</li>
<li>当两个操作数都是负数，结果为负（或0）</li>
<li>一正一负时，求模结果的符号取决于机器；</li>
</ul>
<p>在我的机器上有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">10</span> % -<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> % -<span class="number">3</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出：我的机器上，求模结果的符号随分子确定（除出来的值向负无穷一侧取整）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">30</span>/<span class="number">3</span>*<span class="number">21</span>%<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">30</span>/<span class="number">3</span>*<span class="number">21</span>%<span class="number">5</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>关系操作符和逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>! expr</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小等于</td>
<td>expr &lt;= expr</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大等于</td>
<td>expr &gt;= expr</td>
</tr>
<tr>
<td>==</td>
<td>相等</td>
<td>expr == expr</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>expr != expr</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>(两个竖线)</td>
<td>逻辑或</td>
<td>expr (两个竖线) expr</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注： 由于简书markdown格式问题，不能在表格中打出逻辑或 <code>||</code> 符号。</p>
</blockquote>
<p>上述操作符产生的结果均是bool值。</p>
<ul>
<li><code>!</code>: expr为真时， !expr为假；</li>
<li><code>&amp;&amp;</code>: expr1和expr2都为真时， expr1 &amp;&amp; expr2 结果为真，否则为假；</li>
<li><code>||</code>: expr1和expr2都为假时， expr1 &amp;&amp; expr2 结果为假，否则为真；</li>
</ul>
<p>其中，<code>&amp;&amp;</code> 与 <code>||</code> 操作符只有当 expr1的值不能确定整个表达式的值时，才会解第二个expr2的值，称为 <strong>短路求值（short-circuit evaluation）</strong>。</p>
<blockquote>
<p>不能串接使用关系操作符（逻辑操作符可以）： <code>if(i &lt; j &lt; k)</code> 是错误的。</p>
</blockquote>
<p>下面有一个很有趣的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">while</span> (cp &amp;&amp; *cp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cp &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">	++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">h</span><br><span class="line">ello</span><br><span class="line">e</span><br><span class="line">llo</span><br><span class="line">l</span><br><span class="line">lo</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong></p>
<p>编写程序：判断四个值a、b、c、d是否满足 a&gt;b、b&gt;c且c&gt;d。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &gt; b &amp;&amp; b &gt; c &amp;&amp; c &gt; d) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述 <code>&amp;&amp;</code> 表达式也会采用 <strong>短路求值</strong> 法求解</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里开始第五章《表达式》的内容。下面是 <strong>算术操作符</strong> 的内容</p>
<p>C++有丰富的操作符，并定义了当操作数是内置类型时操作符的含义。而且C++还支持操作符重载，标准库正是使用该功能定义。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[12:C风格字符串]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-12/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-12/</id>
    <published>2015-11-22T08:49:54.000Z</published>
    <updated>2015-11-30T02:57:58.033Z</updated>
    <content type="html"><![CDATA[<p>前面的内容我们使用过字符串字面值，并了解字符串字面值的类型是字符常量的数组，现在可以更加明确的认识到：<strong>字符串字面值的类型就是 const char 类型的数组</strong>。C++从C继承下来的一种通用的结构是<strong>C风格字符串（C-Style character string）</strong>，字符串字面值就是该类型的实例。实际上，C风格字符串既不能确切的归结为C语言类型，也不能归结为C++的类型，而是以空字符 <code>null</code> 结束的字符数组：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;		<span class="comment">//c1 维数为3，not c-style</span></span><br><span class="line"><span class="keyword">char</span> c2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;	<span class="comment">//c2 维数为4</span></span><br><span class="line"><span class="keyword">char</span> c3[] = <span class="string">"C++"</span>;					<span class="comment">//c3 维数为4，自动添加空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"C++"</span>;		<span class="comment">//自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> *cp1 = c1;		<span class="comment">//指向c1数组的第一个元素，not c-style</span></span><br><span class="line"><span class="keyword">char</span> *cp2 = c2;		<span class="comment">//指向c1数组的第一个元素，以空字符 `null` 结束的字符数组</span></span><br></pre></td></tr></table></figure>
<p><code>c1</code> 和 <code>cp1</code> 都不是C风格字符串：<code>c1</code> 是不带结束符 <code>null</code> 的字符数组。其他都是C风格字符串。</p>
<h3 id="1、C风格字符串的使用">1、C风格字符串的使用</h3><hr>
<p>C++通过 (const) char* 类型的指针来操作C风格的字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">	++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">+</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果cp指向的字符数组没有 null 结束符，作为循环会失败。这时循环继续进行，知道遇到内存中某处的 null 结束符。</p>
</blockquote>
<h3 id="2、C风格字符串的标准库函数">2、C风格字符串的标准库函数</h3><hr>
<p>下表类除了C语言标准库函数提供的一系列处理C风格字符串的库函数，这些库函数包含在 string.h 中。</p>
<table>
<thead>
<tr>
<th>库函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen(s)</td>
<td>返回s的长度，不包括null结束符</td>
</tr>
<tr>
<td>strcmp(s1, s2)</td>
<td>比较s1和s2是否相同。s1等于s2,返回0;s1大于s2，返回正数；s1小于s2，返回负数</td>
</tr>
<tr>
<td>strcat(s1, s2)</td>
<td>将字符串s2连接到s1后面，返回s1</td>
</tr>
<tr>
<td>strcpy(s1, s2)</td>
<td>将s2复制给s2，返回s1</td>
</tr>
<tr>
<td>strncat(s1, s2, n)</td>
<td>将s2的前n个字符连接到s1后面，并返回s1</td>
</tr>
<tr>
<td>strncpy(s1, s2, n</td>
<td>将s2的前n个字符赋给s1，并返回s1</td>
</tr>
</tbody>
</table>
<p>传递给这些函数的指针必须具有非零值，并且指向以null结束的字符数组中的第一个元素。并且要确保目标字符串必须有足够大的空间存放结果串。</p>
<p><strong>字符串的比较和比较结果都必须使用标准库函数 strcmp 进行</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp1 = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp2 = <span class="string">"C"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strcmp</span>(cp1, cp2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">i = <span class="built_in">strcmp</span>(cp2, cp1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="built_in">strcmp</span>(cp1, cp1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>不要忘记字符串结束符null</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123; <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出结果是不可预料的，因为会一直寻找null结束符，然后再输出。比如在我的电脑是输出是 <code>324</code>，这明显是错误的，在不同的电脑会输出不同的值。</p>
<p><strong>必须确保目标字符串有足够的大小</strong></p>
<p>库函数 strcat 和 strcpy 的第一个参数必须有足够大的空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp1 = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp2 = <span class="string">"C"</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, cp1);</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">" "</span>);</span><br><span class="line"><span class="built_in">strcat</span>(str, cp2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ C</span><br></pre></td></tr></table></figure>
<p>上述程序就目前来看是完全没问题的，但如果 cp1 和 cp2 指向的字符串大小发生了改变，str 所需的大小就不满足要求了。会导致严重的安全漏洞。</p>
<p><strong>strn函数处理C风格的字符串</strong></p>
<p>如果必须处理C风格字符串，strncat，strncpy会比strcat，strcpy更安全</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(str, cp1, <span class="number">4</span>);	<span class="comment">//1. 包含null</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">" "</span>, <span class="number">2</span>);	<span class="comment">//2. 包含null，看起来冗余，但是个好习惯</span></span><br><span class="line"><span class="built_in">strncat</span>(str, cp2, <span class="number">2</span>);	<span class="comment">//3. 要包含null</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>分步骤解释：</p>
<ul>
<li><ol>
<li>strncpy cp1 时需要复制 4 个字符：cp1 中所有字符，加上 null 结束符；此时 strlen(str) = 3.</li>
</ol>
</li>
<li><ol>
<li>strncat “ “ 时需要复制 2 个字符：一个空格字符，加上 null 结束符；此时空格符会把步骤1复制的 null 结束符覆盖。此时 strlen(str) = 4.</li>
</ol>
</li>
<li><ol>
<li>strncat cp2 时需要复制 2 个字符：cp2 中所有字符，加上 null 结束符；此时 strlen(str) = 6.</li>
</ol>
</li>
</ul>
<p>最后 str 的内容：cp1 和 cp2 中所有字符，一个空格，和一个null结束符。</p>
<p><strong>尽可能使用string类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = cp1;</span><br><span class="line">str += <span class="string">" "</span>;</span><br><span class="line">str += cp2;</span><br></pre></td></tr></table></figure>
<p>可以达到上面一样的效果。</p>
<h3 id="3、创建动态数组">3、创建动态数组</h3><hr>
<p>数组类型的限制：长度不变；编译时须知道长度；数组只在定义它的语句内存在。可以使用动态分配解决这一问题，跟C中的malloc和free类似，C++中使用 <strong>new</strong> 和 <strong>delete</strong> 实现。</p>
<h4 id="3-1、定义">3.1、定义</h4><p>数组变量需要指定类型、数组名和维数定义，而动态分配的数组只需指定类型和长度，不必为数组对象命名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h4 id="3-2、初始化">3.2、初始化</h4><p>动态分配的数组，如果有类型，则使用类型的默认构造函数初始化；如果是内置类型，则无初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];	<span class="comment">//初始化为10个空字符串</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];		<span class="comment">//不初始化</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]();	<span class="comment">//初始化为10个0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>圆括号要求编译器对数组进行初始化；<br>动态分配的数组，其元素只能初始化为默认值，而不能像变量一样提供初始化列表进行初始化</p>
</blockquote>
<h4 id="3-3、const对象的动态数组">3.3、const对象的动态数组</h4><p>必须为该数组提供初始化值，因为数组内都是const对象，无法赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *caip_bad = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>];	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *caip_ok = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>]();	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>也可以定义类类型的const数组，但该类型必须提供默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *csp = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>[<span class="number">10</span>];	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4、动态分配空数组">3.4、动态分配空数组</h4><p>有时候，编译时并不知道数组的长度，这时可以动态分配空数组。看如下程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = get_size();</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *q = p; q != p + n; ++q)</span><br><span class="line">	<span class="comment">//process the array</span></span><br></pre></td></tr></table></figure>
<p>即使 <code>get_size()</code> 返回 0 也是可以的。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>];	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];	<span class="comment">//ok，但不能被解引用</span></span><br></pre></td></tr></table></figure>
<p>上述 <code>cp</code> 指针 <strong>允许</strong> 的操作有：比较；本身加（减）0。</p>
<h4 id="3-5、动态空间释放">3.5、动态空间释放</h4><p>动态分配的空间必须释放，不然内存会被逐渐耗尽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] cp;</span><br></pre></td></tr></table></figure>
<p>该语句回收了 <code>cp</code> 所指向的数组。把相应的内存返还给自由存储区。</p>
<blockquote>
<p>理论上，如果少了 <code>[]</code> 应该会导致少释放空间，从而产生内存泄露，因此，释放动态数组时，不能忘记 <code>[]</code></p>
</blockquote>
<h4 id="3-6、动态数组的使用">3.6、动态数组的使用</h4><p>长度不一样的两个字符串，赋给同一个新的字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt1 = <span class="string">"HAHAHA"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt2 = <span class="string">"HEHEHEHEHEHE"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt;</span><br><span class="line"><span class="keyword">if</span>(condition)	<span class="comment">//condition表示某个条件</span></span><br><span class="line">	txt = txt1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	txt = txt2;</span><br><span class="line"><span class="keyword">size_t</span> demension = <span class="built_in">strlen</span>(txt) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> *msg = <span class="keyword">new</span> <span class="keyword">char</span>[demension];</span><br><span class="line"><span class="built_in">strncpy</span>(msg, txt, demension);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="4、新旧代码的兼容">4、新旧代码的兼容</h3><h4 id="4-1、混合使用string库和C风格字符串">4.1、混合使用string库和C风格字符串</h4><p>可用字符串字面值初始化string对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常，C风格字符串与字符串字面值有相同的数据类型，而且都是以空字符null结束，因此可以把C风格字符串用在任何可以使用字符串字面值的地方：</p>
<ul>
<li>C风格字符串对string对象进行赋值或初始化；</li>
<li>C风格字符串可以作为string类型的加法操作两个参数中的一个；</li>
</ul>
<p>但反之不成立，但可以通过名为 <code>c_str()</code> 的函数转化为C风格字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = str;	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str2 = str.c_str();	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2、使用数组初始化vector对象">4.2、使用数组初始化vector对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> int_arr[arr_size] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(int_arr, int_arr + arr_size);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//相当于用 int_arr[1], int_arr[2], int_arr[3] 初始化 ivec1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p><strong>举例1</strong></p>
<p>编写程序: 从标准输入设备读入字符串，并把字符串存放在字符数组中（输入的字符串长度不定）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> arry_size = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> *p_str = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//统计输入的字符数</span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//存放字符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter some chars:"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.get(c))<span class="comment">//每次读取一个字符赋给c</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count + <span class="number">1</span> &gt;= arry_size)<span class="comment">//超出预设长度</span></span><br><span class="line">		&#123;</span><br><span class="line">			arry_size += <span class="number">10</span>;<span class="comment">//长度增加10</span></span><br><span class="line">			<span class="keyword">char</span> *p_temp = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];<span class="comment">//申请新空间</span></span><br><span class="line">			<span class="built_in">strncpy</span>(p_temp, p_str, count);<span class="comment">//将就空间的内容拷贝到新空间</span></span><br><span class="line">			<span class="keyword">delete</span>[] p_str;<span class="comment">//销毁以前的p_str(p_temp)</span></span><br><span class="line">			p_str = p_temp;<span class="comment">//将新空间p_temp赋给p_str</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		p_str[count] = c;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	p_str[count] = <span class="string">'\0'</span>;<span class="comment">//添加null结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"outputs:"</span> &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="built_in">strlen</span>(p_str); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p_str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p_str &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] p_str;<span class="comment">//最后销毁p_str</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"end"</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter some chars:</span><br><span class="line">asdfghjklqwertyuiop↙</span><br><span class="line">^Z↙</span><br><span class="line">outputs:</span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>举例2</strong></p>
<p>编写程序：读入一组string类型数据，将它们存储在vector中，然后将vector中的对象复制给一个字符指针数组。即为vector中的每个元素创建一个新的字符数组，然后把vector元素的数据复制到相应的字符数组中，最后将指针插入到指针数组中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">		svec.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> **cp_arr = <span class="keyword">new</span> <span class="keyword">char</span>*[svec.size()];<span class="comment">//指针数组</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = svec.begin(); iter != svec.end(); ++iter) &#123;</span><br><span class="line">		<span class="built_in">string</span> s = *iter;</span><br><span class="line">		<span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[s.size()+<span class="number">1</span>];<span class="comment">//+1表示为null结束符预留空间</span></span><br><span class="line">		<span class="built_in">strncpy</span>(cp, s.c_str(), s.size()+<span class="number">1</span>);</span><br><span class="line">		cp_arr[cnt] = cp;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != cnt; ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cp_arr[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] cp_arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] cp_arr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world↙</span><br><span class="line">^Z↙</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h3 id="5、多维数组">5、多维数组</h3><blockquote>
<p>严格的讲，C++中没有多维数组，只有<strong>数组的数组</strong></p>
</blockquote>
<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>且等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>而下面情况只初始化第一个元素，则其余初始化为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>但不会等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//等价于int ia[3][2] = &#123;1, 2, 3, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>下标引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> rsz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> csz = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rsz][csz];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != rsz; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j != csz; ++j) &#123;</span><br><span class="line">		ia[i][j] = i + j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问特定元素时，必须提供行下标与列下标</p>
<p><strong>指针与多维数组</strong></p>
<p>与普通数组一样，多为数组名也是指向第一个元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123; <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">		&#123; <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">		&#123; <span class="number">4</span>, <span class="number">5</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> (*ip)[<span class="number">2</span>];	<span class="comment">//ok: 一个指向包含2个int值的数组的指针</span></span><br><span class="line">	ip = &amp;ia[<span class="number">1</span>];	<span class="comment">//ok: ia[1] 包含2个int值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*ip)[<span class="number">0</span>] &lt;&lt; <span class="string">","</span> &lt;&lt; (*ip)[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>int (<em>ip)[2];//指向数组的指针；即ip是指向包含两个int值的数组的指针<br>int </em>ip[2];//指针的数组；即ip是包含两个指针的数组</p>
</blockquote>
<p><strong>typedef简化多维数组指针</strong></p>
<p>指向 <code>ia</code> 的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">2</span>];</span><br><span class="line">int_arr *ip = ia;</span><br></pre></td></tr></table></figure>
<p>用 <code>int_arr</code> 输出 <code>ia</code> 的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">	&#123; <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (int_arr *p = ia; p != ia + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q != *p + <span class="number">2</span>; ++q)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面的内容我们使用过字符串字面值，并了解字符串字面值的类型是字符常量的数组，现在可以更加明确的认识到：<strong>字符串字面值的类型就是 const char 类型的数组</strong>。C++从C继承下来的一种通用的结构是<strong>C风格字符串（C-Style character string）</strong>，字符串字面值就是该类型的实例。实际上，C风格字符串既不能确切的归结为C语言类型，也不能归结为C++的类型，而是以空字符 <code>null</code> 结束的字符数组：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[11:指针]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-11/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-11/</id>
    <published>2015-11-21T08:49:49.000Z</published>
    <updated>2015-11-30T02:57:58.030Z</updated>
    <content type="html"><![CDATA[<p>指针跟迭代器类似，也可以对指针进行 <strong>解引用</strong>（<code>*</code>） 和 <strong>自增</strong>（<code>++</code>） 操作，其含义和迭代器类似。</p>
<p>指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;s;		<span class="comment">//指针 p 保存 s 的地址</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 是取地址符号，该符号只能用于左值。只有变量作为左值时，才能取其地址。</p>
<h3 id="1、指针的定义和初始化">1、指针的定义和初始化</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *vp;	<span class="comment">//指向 vector&lt;int&gt; 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *ip;			<span class="comment">//指向 int 对象的指针</span></span><br><span class="line"><span class="built_in">string</span> *sp; 		<span class="comment">//指向 string 对象的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>另一种风格的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip;</span><br></pre></td></tr></table></figure>
<p>但容易引起误解，会认为 <code>int*</code> 是一种类型。但下例只有 <code>ip1</code> 是指针，<code>ip2</code> 是普通的整型变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip1, ip2;</span><br></pre></td></tr></table></figure>
<p><strong>指针的取值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = <span class="number">0</span>;		<span class="comment">//ip1 不指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = &amp;val;	<span class="comment">//ip2 指向val</span></span><br><span class="line"><span class="keyword">int</span> *ip3;			<span class="comment">//ip3 未初始化</span></span><br><span class="line">ip1 = ip2;			<span class="comment">//ip1 指向 val</span></span><br><span class="line">ip2 = <span class="number">0</span>;			<span class="comment">//ip2 不指向任何对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免使用未初始化的指针</p>
</blockquote>
<p><strong>初始化的约束</strong></p>
<p>对指针初始化或赋值只能使用下列四种类型的值：</p>
<ul>
<li>0常量表达式(编译时能获得0值得const对象或字面值常量0)；</li>
<li>类型匹配的对象的地址；</li>
<li>另一对象之后的下一地址；</li>
<li>同一类型的另一有效指针；</li>
</ul>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> czero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">double</span> *dp;</span><br><span class="line"></span><br><span class="line">ip = ival;		<span class="comment">//error</span></span><br><span class="line">ip = zero;		<span class="comment">//error</span></span><br><span class="line">ip = czero;		<span class="comment">//ok：编译时可以获得 0</span></span><br><span class="line">ip = <span class="number">0</span>；			<span class="comment">//ok：字面值常量 0</span></span><br><span class="line">ip = &amp;ival;		<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">dp = ip;		<span class="comment">//error：类型不匹配</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">当然 <span class="number">0</span> 值还可以使用从C语言继承下来的预处理器变量 `<span class="literal">NULL</span>`，它在 cstdlib 头文件中定义，其值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="literal">NULL</span>;	<span class="comment">//相当于 int *ip = 0;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NULL</code> 不是标准库中定义的，所以不需要 <code>std::</code>。</p>
</blockquote>
<p><strong>void*指针</strong></p>
<p>void* 指针可以保存任何类型对象的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;</span><br><span class="line"><span class="keyword">void</span> *vp = &amp;dval;	<span class="comment">//ok</span></span><br><span class="line">vp = dp;			<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>但 void* 指针只允许有限的操作：</p>
<ul>
<li>与另一指针比较；</li>
<li>向函数传递 void<em> 指针，或函数返回 void</em> 指针；</li>
<li>给另一个 void* 指针赋值。</li>
</ul>
<blockquote>
<p>不允许 void* 指针操作所指向的对象。</p>
</blockquote>
<h3 id="3、指针的操作">3、指针的操作</h3><hr>
<p><strong>*操作符</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s1("hello");</span><br><span class="line">string s2("world")；</span><br><span class="line">string *sp = &amp;s1;</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">sp = &amp;s2;				//改变指针所指对象</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">*sp = "hello world";	//改变所指的内容</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>对 <code>sp</code> 的解引用可以获得 <code>s</code> 的值，因为 <code>sp</code> 指向 <code>s</code>，所以给 <code>*sp</code> 赋值可以改变 <code>s</code> 的值。</p>
<p><strong>指针和引用的比较</strong></p>
<p>虽然引用（reference）和指针都可以间接访问另一个值，但有区别：</p>
<ul>
<li>定义引用时没有初始化时错误的；</li>
<li>赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，并不是与另一个对象关联；</li>
<li>引用一经初始化，就始终指向同一个特定的对象</li>
</ul>
<p>指针的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival1 = <span class="number">1024</span>, ival2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = &amp;ival1, *ip2 = &amp;ival2;</span><br><span class="line">ip1 = ip2;		<span class="comment">//ip1 此时指向 ival2</span></span><br></pre></td></tr></table></figure>
<p>而引用的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;r1 = ival1; <span class="keyword">int</span> &amp;r2 = ival2;</span><br><span class="line">r1 = r2;		<span class="comment">//将 ival2 赋给 ival1</span></span><br></pre></td></tr></table></figure>
<p>上面的修改只会修改引用所关联的对象，并不会改变改变引用本身。并且修改后，两个引用还是指向原来关联的对象。</p>
<p><strong>指向指针的指针</strong></p>
<p>指针本身也是需要占内存的对象，所以指针也可以被指针访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> **ipp = &amp;ip;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; **ipp &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>可以用三种方式输出ival的值。</p>
<p>最后举一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i, *p2 = &amp;j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p2 = *p1 * *p2;			<span class="comment">//改变 p2 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p1 *= *p1;				<span class="comment">//改变 p1 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="4、使用指针访问数组">4、使用指针访问数组</h3><hr>
<p>指针与数组密切相关。特别是在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = val;	<span class="comment">//p 指向 val[0]</span></span><br><span class="line">p = &amp;val[<span class="number">3</span>];	<span class="comment">//p 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<p><strong>指针的算术运算</strong></p>
<p>上面的 <code>p = &amp;val[3];</code> 使用下标操作，也可以通过 <strong>指针的算术操作（pointer arithmetic）</strong> 来获取指定的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = val;			<span class="comment">//p 指向 val[0]</span></span><br><span class="line"><span class="keyword">int</span> *p2 = p + <span class="number">3</span>;	<span class="comment">//p2 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针的算术操作只有在计算过后的新指针还是指向同一数组的元素才算合法，且不能越界，比如上面 <code>int *p2 = p + 3;</code> 改成 <code>int *p2 = p + 4;</code> 就会出错，因为数组 <code>val</code> 的大小为 4，最大的下标为 3。</p>
</blockquote>
<p>两个指针之间还可以做减法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ptrdiff_t</span> n = p2 - p1;	<span class="comment">//n = 3</span></span><br></pre></td></tr></table></figure>
<p><code>p1</code> 和 <code>p2</code> 之间相差3个对象，所以 <code>n = 3</code>。 <code>n</code> 是标准库类型（library type） <strong>ptrdiff_t</strong> 类型。与 size_t 类型一样，ptrdiff_t 也是一种与机器相关类型，在cstddef头文件中定义。</p>
<p>允许在指针上加减 0，使指针保持不变。</p>
<p><strong>解引用和指针算术操作之间的相互作用</strong></p>
<p>在指针上加上一个整数值，其结果仍是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last = *(val + <span class="number">3</span>);	<span class="comment">//相当于 val[3]</span></span><br></pre></td></tr></table></figure>
<p>需要写括号，如果写成 <code>int last = *val + 3;</code> 则相当于 <code>val[0] + 3</code>。</p>
<p><strong>下标和指针</strong></p>
<p>使用下标访问数组时，它实际上是使用下标访问指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = val[<span class="number">0</span>]	<span class="comment">//val 指向数组 val[] 的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;val[<span class="number">2</span>];	<span class="comment">//ok: p 指向第二个元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];		<span class="comment">//ok: p[1] 相当于 *(p + 1), j = val[3]</span></span><br><span class="line"><span class="keyword">int</span> k = p[-<span class="number">2</span>];		<span class="comment">//ok: p[-2] 相当于 val[0]</span></span><br></pre></td></tr></table></figure>
<p><strong>计算数组的超出末端指针</strong></p>
<p>vector 类型提供的end操作将返回指向超出 vector 末端位置的一个迭代器。类似的，可以计算数组的超出末端指针的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">int</span> *p2 = p + arr_size;	<span class="comment">//ok:超出末端的指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端之后或数组首地址之前的地址都是不合法的。</p>
</blockquote>
<p><code>p2</code> 不能解引用操作，但能与其他指针比较，或者用作指针算术表达式的操作数。</p>
<p><strong>输出数组元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *begin = arr, *end = arr + arr_size; begin != end; ++begin)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *begin &lt;&lt; <span class="string">","</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针是数组的迭代器。上面的程序与迭代器程序非常相似，事实上，内置类型具有标准库容器的许多性质，指针就是数组的迭代器。</p>
</blockquote>
<h3 id="5、指针与const限定符">5、指针与const限定符</h3><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p><strong>指针和typedef</strong></p>
<p>在typedef中使用指针往往会带来意外的结果，下面是一个几乎所有初学者都会搞错的问题：请问 <code>cstr</code> 变量是什么类型？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="keyword">const</span> sp cstr;</span><br></pre></td></tr></table></figure>
<p>简单的回答是：const sp 类型的指针。进一步：const sp 所表示的真实类型是什么？可能会认为是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *cstr;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>但这是错误的，原因是：声明const sp时，const修饰的是 sp 类型，而 sp 是一个指针。所以等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解const声明：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1 和 s2 都是const</span></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">const</span> s1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> s2;</span><br></pre></td></tr></table></figure>
<p>用typedef写const类型定义时，const限定符加在类型前面容易引起误解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="comment">//下面三种定义时等价的</span></span><br><span class="line"><span class="keyword">const</span> sp cstr1 = &amp;s;	<span class="comment">//容易误解</span></span><br><span class="line">sp <span class="keyword">const</span> cstr2 = &amp;s;</span><br><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr3 = &amp;s;</span><br></pre></td></tr></table></figure>
<hr>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic = i;				<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pic = &amp;ic; 			<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> cpi = &amp;ic;			<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> cpic = &amp;ic;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>指针跟迭代器类似，也可以对指针进行 <strong>解引用</strong>（<code>*</code>） 和 <strong>自增</strong>（<code>++</code>） 操作，其含义和迭代器类似。</p>
<p>指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[10:数组]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-10/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-10/</id>
    <published>2015-11-20T08:49:44.000Z</published>
    <updated>2015-11-30T02:57:17.818Z</updated>
    <content type="html"><![CDATA[<p>现在开始学习第四章“数组和指针”。C++语言提供了两种类似于vector和迭代器类型的低级复合类型——<strong>数组和指针</strong>。数组与vector类似，区别在于：数组的长度是固定的，一经创建不允许添加新的元素，如果一定要增加元素，只能创建更大的数组；指针则可以像迭代器一样用于遍历和检查数组中的元素。</p>
<a id="more"></a>
<blockquote>
<p>现代的C++程序应尽量使用vector和迭代器类型，而避免使用低级的数组和指针。设计良好的程序只有在强调速度时才在类实现的内部使用数组和指针。</p>
</blockquote>
<h3 id="1、数组的定义及初始化">1、数组的定义及初始化</h3><hr>
<p>数组是由类型名、标识符和维数组成的复合数据类型，类型名规定了存放在数组中元素类型，而维数是指数组能存放的个数。</p>
<blockquote>
<p>数组定义中的类型名可以是内置数据类型或类类型；除引用之外，数组元素的类型还可以是任意的复合类型。没有所有元素都是引用的数组。</p>
</blockquote>
<p>数组维数必须用值大于等于 1 的常量表达式定义。此常量表达式只能是整型字面值常量、枚举常量或者用常量表达式初始化的整型const对象。<strong>非const变量或要到运行阶段才知道其值的const变量都不能用于定义数组的维数</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> buf_size = <span class="number">512</span>, max_files = <span class="number">20</span>;	<span class="comment">//const</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;	<span class="comment">//non const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> run_size = get_size();	<span class="comment">//const value unknown until run time</span></span><br><span class="line"><span class="keyword">char</span> input_buffer[buf_size];		<span class="comment">//ok：const</span></span><br><span class="line"><span class="built_in">string</span> file_table[max_files + <span class="number">1</span>];	<span class="comment">//ok：constant expression</span></span><br><span class="line"><span class="keyword">double</span> salaries[staff_size];		<span class="comment">//error:non const variable</span></span><br><span class="line"><span class="keyword">int</span> test[get_size()];				<span class="comment">//error:non const expression</span></span><br><span class="line"><span class="keyword">int</span> vals[run_size];					<span class="comment">//error:value unknown until run time</span></span><br></pre></td></tr></table></figure>
<p>虽然 <code>staff_size</code> 是用字面值常量进行初始化，但它本身是一个非const变量，<strong>只有在运行时才能获得它的值</strong>；<code>run_size</code> 虽然是 const 对象，但它的值要到运行时调用 get_size() 函数才能知道；因此这两种都不能用来初始化维数。</p>
<p>没有显式提供元素初值时，数组会跟普通的变量一样：</p>
<ul>
<li>在函数体 <strong>外</strong> 定义的内置数组，其元素均初始化为 0；</li>
<li>在函数体 <strong>内</strong> 定义的内置数组，其元素均无初始化值；</li>
<li>不管数组在哪定义，如富哦其元素是类类型，则自动调用默认构造函数进行初始化；如果无默认构造函数，则必须现实提供初始化值。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> array_size = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> vals1[array_size] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;	<span class="comment">//显式初始化</span></span><br><span class="line"><span class="keyword">int</span> vals2[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;			<span class="comment">//显示初始化，可以不提供维数</span></span><br><span class="line"><span class="keyword">int</span> vals3[array_size] = &#123;<span class="number">1</span>&#125;;		<span class="comment">//初始化列表的元素个数可以小于维数，但不能大于</span></span><br></pre></td></tr></table></figure>
<p>上面的数组初始化结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vals1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vals2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="comment">//对于vals3，若是内置类型，超出初始化列表的元素初始化为0；若是类类型，则使用默认构造函数初始化</span></span><br><span class="line">vals3 = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>字符数组</strong>： 既可以用花括号初始化，也可以用字符串字面值初始化。但不太相同，字符串字面值包含一个额外的空字符（null）用于结束字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;		<span class="comment">//c1 维数为3</span></span><br><span class="line"><span class="keyword">char</span> c2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;	<span class="comment">//c2 维数为4</span></span><br><span class="line"><span class="keyword">char</span> c3[] = <span class="string">"C++"</span>;					<span class="comment">//c3 维数为4，自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> c4[<span class="number">3</span>] = <span class="string">"C++"</span>;					<span class="comment">//error:自动添加空字符，所以 "C++" 维数为4</span></span><br></pre></td></tr></table></figure>
<p><strong>不允许数组直接复制和赋值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> vals1[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;	<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> vals2[](vals1);		<span class="comment">//error</span></span><br><span class="line"><span class="keyword">int</span> vals3[<span class="number">3</span>] = vals1;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<h3 id="2、数组的操作">2、数组的操作</h3><hr>
<p>与vector类似，用下标类访问元素；vector用vector::size_type作为下标类型，数组的下标正确类型则是 size_t。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> array_size = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> arr1[array_size], arr2[array_size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != array_size; ++i)&#123;</span><br><span class="line">	arr1[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制arr1数组到arr2</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != array_size; ++i)&#123;</span><br><span class="line">	arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意下标不能越界</p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在开始学习第四章“数组和指针”。C++语言提供了两种类似于vector和迭代器类型的低级复合类型——<strong>数组和指针</strong>。数组与vector类似，区别在于：数组的长度是固定的，一经创建不允许添加新的元素，如果一定要增加元素，只能创建更大的数组；指针则可以像迭代器一样用于遍历和检查数组中的元素。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[9:bitset类型]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-9/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-9/</id>
    <published>2015-11-19T08:49:39.000Z</published>
    <updated>2015-11-30T02:57:17.815Z</updated>
    <content type="html"><![CDATA[<p>有些程序需要处理二进制位的有序集，每位个能包含 0 或 1。 <strong>bitset</strong> 类型简化了位集的处理，使用时必须包含头文件</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">bitset</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1、bitset对象的初始化">1、bitset对象的初始化</h3><hr>
<p>类似于 vector，bitset也是一种类模板。bitset 类型之间的区别在于其长度而不是类型，在定义 bitset 类型时，要明确其含有多少位，<code>&lt;&gt;</code> 内指定它的长度：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; b;</span><br></pre></td></tr></table></figure>
<p>给出的长度也可以是 <strong>常量表达式</strong>，长度必须定义为整型字面值常量或已用常量值初始化的整型const对象。</p>
<p>上面的对象 <code>b</code> 含有32个位，每位都是 0。跟 vector 类似，<code>b</code> 中的位也没有命名，可以按位置来访问。位置： 0 ~ 31，以 0 开始的位串是 <strong>低阶位（low-order bit）</strong>，以 31 位结尾的位串是 <strong>高阶位（high-order bit）</strong>。</p>
<p>所有方法如下表</p>
<table>
<thead>
<tr>
<th>初始化方法</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>bitset<n> b;</n></td>
<td>b 有 n 位，每位为 0</td>
</tr>
<tr>
<td>bitset<n> b(u);</n></td>
<td>b 是 unsigned long 型 u 的一个副本</td>
</tr>
<tr>
<td>bitset<n> b(s);</n></td>
<td>b 是 string 对象 s 中含有的位串的副本</td>
</tr>
<tr>
<td>bitset<n> b(s, pos, n);</n></td>
<td>b 是 s 中从位置 pos 开始的 n 个位的副本</td>
</tr>
</tbody>
</table>
<h4 id="1-1、用unsigned值初始化bitset对象">1.1、用unsigned值初始化bitset对象</h4><p>用unsigned long值初始化bitset对象时，该值会转化为二进制位模式。bitset 作为这种位模式的副本，如果bitset类型的长度大于unsigned long值的二进制位数，则其余的高阶位将置为0；如果bitset类型的长度小于二进制位数，则只使用unsigned值中的低阶位，超过bitset类型长度的高阶位将被丢弃。</p>
<p>在32位unsigned long的机器上，十六进制 <code>0xffff</code> 表示为二进制位就是16个1和16个0（每个 <code>0xf</code> 可以表示 <code>1111</code>）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; b1(<span class="number">0xffff</span>);	<span class="comment">//0~15位为1</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;32&gt; b2(<span class="number">0xffff</span>);	<span class="comment">//0~15位为1；16~31位为0</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;128&gt; b3(<span class="number">0xffff</span>);	<span class="comment">//0~15位为1；16~31位为0；32~127位为0</span></span><br></pre></td></tr></table></figure>
<p><code>b1</code> 位数少于unsigned long的位数，所以高阶位被丢弃；<code>b2</code> 与unsigned long长度相同，所有位正好放初始值；<code>b3</code> 长度大于 32，31 位以上的高阶位就被置为 0.</p>
<h4 id="1-2、用string对象初始化">1.2、用string对象初始化</h4><p>当用string对象初始化bitset对象时，string对象直接使用位模式。从string对象读入位集的顺序是 <strong>从右至左</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str1</span><span class="params">(<span class="string">"1100"</span>)</span></span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;32&gt; b4(str1);</span><br></pre></td></tr></table></figure>
<p><code>b4</code> 的位模式中 2~3 位为 1，其余位置为 0。</p>
<blockquote>
<p>要注意，用 string 对象初始化 bitset 对象时，它们是反转的</p>
</blockquote>
<p>也可以使用 string 的子串初始 化bitset 对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str2</span><span class="params">(<span class="string">"11000001111100001011"</span>)</span></span>;</span><br><span class="line"><span class="built_in">bitset</span>&lt;16&gt; b5(str2, <span class="number">5</span>, <span class="number">4</span>);				<span class="comment">//从下标为5开始长度为4的子串 "0011"</span></span><br><span class="line"><span class="built_in">bitset</span>&lt;16&gt; b6(str2, str2.size() - <span class="number">4</span>);	<span class="comment">//使用最后4个位 "1011"</span></span><br></pre></td></tr></table></figure>
<p>详细的为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b5: <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span></span><br><span class="line">b6: <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure>
<h3 id="2、bitset对象的操作">2、bitset对象的操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>b.any()</td>
<td>b 中是存在为1的二进制位</td>
</tr>
<tr>
<td>b.none()</td>
<td>b 中二进制位是否全为0</td>
</tr>
<tr>
<td>b.count()</td>
<td>b 中为1的二进制位的个数</td>
</tr>
<tr>
<td>b.size()</td>
<td>b 中二进制位的个数</td>
</tr>
<tr>
<td>b[pos]</td>
<td>访问 b 中位置为 pos 的二进制位</td>
</tr>
<tr>
<td>b.test(pos)</td>
<td>b 中位置为 pos 的二进制位是否为 1</td>
</tr>
<tr>
<td>b.set()</td>
<td>把 b 中所有二进制位置为 1</td>
</tr>
<tr>
<td>b.set(pos)</td>
<td>b 中位置为 pos 的二进制位是设为 1</td>
</tr>
<tr>
<td>b.reset()</td>
<td>把 b 中所有二进制位置为 0</td>
</tr>
<tr>
<td>b.reset(pos)</td>
<td>b 中位置为 pos 的二进制位是设为 0</td>
</tr>
<tr>
<td>b.flip()</td>
<td>把 b 中所有二进制位逐位反转</td>
</tr>
<tr>
<td>b.flip(pos)</td>
<td>把 b 中位置为 pos 的二进制位反转</td>
</tr>
<tr>
<td>b.to_ulong()</td>
<td>用 b 中同样的二进制位返回一个 unsigned long 值</td>
</tr>
<tr>
<td>os &lt;&lt; b</td>
<td>把 b 中的位输出到os流</td>
</tr>
</tbody>
</table>
<p>举例</p>
<ul>
<li><p>测试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;32&gt; b;	<span class="comment">//32位，全0</span></span><br><span class="line"><span class="keyword">bool</span> is_set = b.any();		<span class="comment">//false</span></span><br><span class="line"><span class="keyword">bool</span> is_none = b.none();	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>count &amp; size：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = b.count();</span><br><span class="line"><span class="keyword">size_t</span> siz = b.size();</span><br></pre></td></tr></table></figure>
<p>  返回的类型 <strong>size_t</strong> 定义在 <strong>cstddef.h</strong> 中，对应于c语言的 <strong>stddef.h</strong>。</p>
</li>
<li><p>下标访问：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index != <span class="number">32</span>; index += <span class="number">2</span>) &#123;</span><br><span class="line">	b[index] = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//下面是等价方式</span></span><br><span class="line">	<span class="comment">//b.set(index);	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>把 <code>b</code> 中的偶数位置为 1。</p>
<ul>
<li><p>操作整个bitset对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b.reset();	<span class="comment">//set all bits to 0.</span></span><br><span class="line">b.<span class="built_in">set</span>();	<span class="comment">//set all bits to 1.</span></span><br><span class="line">b.flip();	<span class="comment">//reverse all bits</span></span><br><span class="line">b.flip(<span class="number">0</span>);	<span class="comment">//reverse the first bit</span></span><br><span class="line">b[<span class="number">0</span>].flip();<span class="comment">//as above</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>to_ulong &amp; cout</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;16&gt; b(<span class="number">0xffff</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulong = b.to_ulong();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b: "</span> &lt;&lt; b &lt;&lt; <span class="string">", ulong: "</span> &lt;&lt; ulong &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>  <strong>仅当bitset类型的长度小于或等于 unsigned long 的长度时</strong>，才可以使用 to_ulong 操作。上例结果</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b: <span class="number">1111111111111111</span>, ulong: <span class="number">65535</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>位操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span> 也支持内置的位操作符 `&lt;&lt;` 和 `&gt;&gt;`，后续介绍。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有些程序需要处理二进制位的有序集，每位个能包含 0 或 1。 <strong>bitset</strong> 类型简化了位集的处理，使用时必须包含头文件</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[8:迭代器iterator]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-8/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-8/</id>
    <published>2015-11-18T08:49:34.000Z</published>
    <updated>2015-11-30T02:57:17.813Z</updated>
    <content type="html"><![CDATA[<p>除了使用下标访问vector对象的元素外，还有另一种方式：<strong>迭代器（iterator）</strong>。标准库为每一种容器（包括 vector）定义了一种迭代器类型，现代的C++程序更倾向于使用迭代器，即使支持下标操作的容器也是如此，如 vector。在第11章会详细介绍迭代器。</p>
<a id="more"></a>
<h3 id="1、容器的iterator类型">1、容器的iterator类型</h3><hr>
<p>每种容器都定义了自己的迭代器类型，如vector：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同一术语 <code>iterator</code> 往往表示两个不同的事物，一般来说是指 <strong>迭代器</strong> 的概念；而具体而言时是指由容器定义的iterator类型，如vector<int>。</int></p>
</blockquote>
<h3 id="2、begin和end操作">2、begin和end操作</h3><hr>
<p>每种容器都定义了一对名为 begin 和 end 的函数，用于返回迭代器。容器不为空时，begin 返回的是容器的第一个元素：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = intv.begin();</span><br></pre></td></tr></table></figure>
<p><code>iter</code> 指向的是 <code>intv[0]</code>。</p>
<p>end 返回的迭代器指向的是vector的 <strong>末端的下一个</strong>，通常称为 <strong>超出末端迭代器（off-the-end iterator）</strong>，它指向一个不存在的元素，如果vector为空，则begin和end返回的迭代器相同。</p>
<blockquote>
<p>end只是起一个<strong>哨兵（sentinel）</strong>的作用，表示已处理完所有元素。</p>
</blockquote>
<h3 id="3、vector迭代器的自增和解引用运算等">3、vector迭代器的自增和解引用运算等</h3><hr>
<ul>
<li><p><strong>自增操作</strong> <code>++</code>：表示向前移动迭代器，指向下一个元素。可以结合 int 的自增理解：对于 int 类型来说，表示 “加1”，而对容器来说，是“下移一个位置”。如果当前迭代器指向第一个元素，则 <code>++iter</code> 表示指向第二个元素。</p>
</li>
<li><p><strong>解引用操作</strong> <code>*</code>：可以用来访问迭代器所指向的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*iter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>  如果迭代器当前指向第一个元素，则上述程序表示：<code>intv[0] = 0</code>。</p>
</li>
<li><p><code>==, !=</code> 可以用来比较两个迭代器</p>
</li>
</ul>
<h3 id="3、示例">3、示例</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv;	<span class="comment">//这是空vector，没有元素</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">		intv.push_back(i);	<span class="comment">//ok:动态增加</span></span><br><span class="line">	&#125;	<span class="comment">//添加元素 0-9</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = intv.begin(); iter != intv.end(); ++iter)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt;<span class="string">","</span>;</span><br><span class="line">		*iter = <span class="number">1</span>;	<span class="comment">//改变vector的值</span></span><br><span class="line">	&#125;	<span class="comment">//跟下面的可以达到相同的效果</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != intv.size(); ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; intv[i] &lt;&lt; <span class="string">","</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,</span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span><br></pre></td></tr></table></figure>
<h3 id="4、const_iterator">4、const_iterator</h3><hr>
<p>前面的 <code>vector::iterator</code> 可以用来改变元素的值，每个容器还定义了一种只能读取元素但不能改变值得iterator类型：<strong>const_iterator</strong>。</p>
<p>跟普通的iterator类型的区别在于：普通iterator类型解引用时得到的是非const引用，而const_iterator解引用时，得到的是const引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = intv.begin(); iter != intv.end(); ++iter)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt;<span class="string">","</span>;	<span class="comment">//ok</span></span><br><span class="line">	*iter = <span class="number">0</span>;				<span class="comment">//error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能把 const_iteraor 与const iterator 混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator citer = nums.begin();</span><br><span class="line">*citer = <span class="number">1</span>;	<span class="comment">//ok</span></span><br><span class="line">++citer;	<span class="comment">//error：不能改变迭代器的值</span></span><br></pre></td></tr></table></figure>
<p>const_iterator 可以用于 const vector 和非 const vector。但由于不能改变值，const iterator 基本没什么用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nines(<span class="number">10</span>, <span class="number">9</span>);		<span class="comment">//这样定义的nines的元素不能被改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator citer = nines.begin();	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter = nines.begin();</span><br><span class="line">*iter = <span class="number">1</span>;	<span class="comment">//error：*iter是const</span></span><br><span class="line">++iter;		<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>vector<int>::const_iterator //不能改变容器的值<br>const vector<int>::iterator //不能改变迭代器的值</int></int></p>
</blockquote>
<h3 id="5、迭代器的算术运算">5、迭代器的算术运算</h3><hr>
<p>除了一次移动一个元素之外，迭代器还支持其他算术操作</p>
<ul>
<li><code>iter +(-) n</code>：产生一个新的迭代器，其位置在iter之前（加）或之后（减）的位置。但是加减后的位置还必须是指向vector中的某个元素，或末端的下一个；</li>
<li><code>iter1 - iter2</code>：计算两个迭代器间的距离，该距离是 <strong>difference_type</strong> 的 signed 类型的值，类似于 size_type 也是由vector定义。iter1 和 iter2 必须都指向同一个vector容器，或末端的下一个；</li>
</ul>
<p>下面语句可直接定位vector中间元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator mid = intv.begin() + intv.size()/<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>任何改变vector长度的操作都会使已存在的迭代器失效。例如调用 push_back 之后，迭代器所指向的元素将会改变。</p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>除了使用下标访问vector对象的元素外，还有另一种方式：<strong>迭代器（iterator）</strong>。标准库为每一种容器（包括 vector）定义了一种迭代器类型，现代的C++程序更倾向于使用迭代器，即使支持下标操作的容器也是如此，如 vector。在第11章会详细介绍迭代器。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[7:vector类型]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-7/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-7/</id>
    <published>2015-11-17T08:31:51.000Z</published>
    <updated>2015-11-30T02:57:17.810Z</updated>
    <content type="html"><![CDATA[<p>vector 是一种类型对象的容器，每个对象都有一个对应的整数索引值。我们还把它称之为 <strong>容器</strong>，是因为它可以包含其他对象。一个容器中必须包含的是同一种类型的对象，地9章会详细介绍容器。首先是声明：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>vector 是一个类模板（class template），所以 vector 可以包含不同类型的对象，如 int 型，string 型。vector 的声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv;</span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; salesv;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>vector 不是一种数据类型，只是一个模板，可用来定义任意多种数据类型。但 vector<int> 或 vector<string> 可以看成是一种类型。</string></int></p>
</blockquote>
<h3 id="1、vector_对象的定义和初始化">1、vector 对象的定义和初始化</h3><hr>
<table>
<thead>
<tr>
<th>初始化方式</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>vector<t> v1;</t></td>
<td>默认构造，v1 为空</td>
</tr>
<tr>
<td>vector<t> v2(v1);</t></td>
<td>v2 是 v1 的副本</td>
</tr>
<tr>
<td>vector<t> v3(n, i);</t></td>
<td>v3 包含 n 个 i 的元素</td>
</tr>
<tr>
<td>vector<t> v4(n);</t></td>
<td>v4 初始化为含有 n 个 T 类型默认值的对象</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv2(intv1);	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strv(intv1);	<span class="comment">//error：strv 保存的是 string 类型，不是 int 类型</span></span><br></pre></td></tr></table></figure>
<p>也可以用元素个数和元素之进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv(<span class="number">10</span>, -<span class="number">1</span>);	<span class="comment">//10 个int元素，每个初始化为 -1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; strv(<span class="number">10</span>, <span class="string">"hi"</span>);	<span class="comment">//10 个string元素，每个初始化为 hi</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>vector重要的属性在于可以在运行时高效的添加元素，在元素已知的情况下，最好是动态的添加元素。</p>
</blockquote>
<p>下面说明这种初始化情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strv(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>此时</p>
<ul>
<li><code>intv</code> 会被初始化成包含 10 个 <strong>0</strong> 的 vector 对象；</li>
<li><code>strv</code> 会被初始化成包含 10 个 <strong>空字符串</strong> 的 vector 对象；</li>
</ul>
<p>这种初始化方式叫做 <strong>值初始化</strong>。</p>
<h3 id="2、vector对象的操作">2、vector对象的操作</h3><hr>
<table>
<thead>
<tr>
<th>vector操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>v.empty()</td>
<td>v 为空，返回true</td>
</tr>
<tr>
<td>v.size()</td>
<td>返回 v 中的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td>在 v 的末尾添加一个 t 元素</td>
</tr>
<tr>
<td>v[n]</td>
<td>返回 v 中位置为 n 的元素</td>
</tr>
<tr>
<td>v1 = v2</td>
<td>v1 的值替换成 v2</td>
</tr>
<tr>
<td>v1 == v2</td>
<td>若 v1 和 v2 相等，返回true</td>
</tr>
<tr>
<td>!=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>保持惯有操作</td>
</tr>
</tbody>
</table>
<h4 id="2-1、empty和size">2.1、empty和size</h4><p>empty和size的操作类似于string，成员函数返回的vector类型定义的size_type的值。</p>
<blockquote>
<p>使用size_type时，必须指出该类型是在哪里定义的，如<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">vector</span>::size_type		<span class="comment">//error</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="2-2、向vector添加元素">2.2、向vector添加元素</h4><p>push_back()接受一个元素值，并将它作为一个新的元素添加到vector对象的末尾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)&#123;</span><br><span class="line">	text.push_back(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序的意思是从标准输入读取一系列string对象，并逐一添加到vector对象的末尾。</p>
<h4 id="2-3、vector的下标操作">2.3、vector的下标操作</h4><p>vector对象的元素是没有命名的，但可以按vector对象中的位置来访问它们，跟string类似，位置从0开始计数，下例是将vector中的每个元素置为0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv(<span class="number">10</span>);	<span class="comment">//含有10各元素的vector</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != intv.size(); ++i)&#123;</span><br><span class="line">	intv[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>习惯于Java和C的程序员可能会觉得难以理解<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、for循环用 <span class="escape">`!</span>=<span class="escape">` </span>来作为判断条件；</span><br><span class="line"><span class="number">2</span>、不用变量保存 <span class="escape">`i</span>ntv.size()<span class="escape">`；</span></span><br></pre></td></tr></table></figure></p>
<p>到学习过泛型编程后就会明白 <code>1</code> 的合理性，至于 <code>2</code>，上述循环不需要增加元素，但循环很容易增加元素，所以如果增加了元素的话，那保存就不合理了。</p>
</blockquote>
<h4 id="2-4、下标操作不能添加元素">2.4、下标操作不能添加元素</h4><p>下标操作不能添加元素，但能对已有的元素进行操作，如上例中的将所有元素重置为0。所以下面的例子是错误的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv;	<span class="comment">//这是空vector，没有元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	intv[i] = i;	<span class="comment">//error：intv是空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但下面的例子是正确的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intv;	<span class="comment">//这是空vector，没有元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	intv.push_back(i);	<span class="comment">//ok:动态增加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>vector 是一种类型对象的容器，每个对象都有一个对应的整数索引值。我们还把它称之为 <strong>容器</strong>，是因为它可以包含其他对象。一个容器中必须包含的是同一种类型的对象，地9章会详细介绍容器。首先是声明：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[6:using声明和string类型]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-6/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-6/</id>
    <published>2015-11-15T08:31:46.000Z</published>
    <updated>2015-11-30T02:57:17.807Z</updated>
    <content type="html"><![CDATA[<p>从这篇博客开始学习《C++ primer》的第三章“标准库类型”。首先介绍命名空间的using声明和第一种库类型string。</p>
<h3 id="一、using声明">一、using声明</h3><hr>
<p>在本章之前所用到的标准库类型都使用了 <code>::</code> 操作符，该操作符是作用域操作符，如 <code>std::cin</code>。但每次使用标准库类型就需要添加 <code>std::</code> 显得非常麻烦，本节介绍一种安全的机制：<strong>using声明</strong>。</p>
<a id="more"></a>
<p>使用using声明可以不再需要添加 <code>namespace_name::</code>，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name</span><br></pre></td></tr></table></figure>
<p>一旦使用了 using 声明，后面就不要再次引用命名空间了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two Numbers:"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">int</span> val1, val2;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt; val1 &gt;&gt; val2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; val1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; val2</span><br><span class="line">			&lt;&lt; <span class="string">" is "</span> &lt;&lt; val1+val2 &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以对比之前我们写的程序，发现明显可以简洁很多。在接下来的例子中，我们均假设已经提供了using声明。</p>
<h3 id="二、标准库string类型">二、标准库string类型</h3><hr>
<p>string 类型支持可变长度的字符串，我们不需要知道它的具体实现，只需要知道它提供的操作。跟其他标准库类型一样，要使用也需要添加头文件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<h4 id="2-1、string对象的定义和初始化">2.1、string对象的定义和初始化</h4><p>string 标准库支持几个构造函数，构造函数是一个特殊成员函数，定义如何初始化该类型的对象。下表列出了几个构造函数</p>
<table>
<thead>
<tr>
<th>string构造函数</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s1;</td>
<td>默认构造函数，s1为空字符串</td>
</tr>
<tr>
<td>string s2(s1);</td>
<td>将s2初始化为s1的副本</td>
</tr>
<tr>
<td>string s3(“value”)</td>
<td>将s3初始化为 “value” 的副本</td>
</tr>
<tr>
<td>string s4(n,’c’)</td>
<td>将s4初始化为含n个 ‘c’ 的字符串</td>
</tr>
</tbody>
</table>
<blockquote>
<p>字符串的字面值与标准库string类型不是同一种类型，需要注意！</p>
</blockquote>
<h4 id="2-2、string对象的读写">2.2、string对象的读写</h4><p>跟前面的 iostream 标准库的内置类型 int，double相似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设using声明已经提供</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>string的输入操作：</p>
<ul>
<li>读取时忽略开头所有的空白符（如空格，换行符，制表符）；</li>
<li>读取字符直至再次遇到空白符；</li>
</ul>
<p>因此如果输入的是 “  hello world “（开头和结尾都有空格），上述程序输出是 “hello”，下面程序输出为 “helloworld”。</p>
<p>而且与前面类似，可以把多个操作放在一起</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>另一个例子：读取未知数目的string对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word)&#123;	<span class="comment">//输入“ctrl+z”可以结束</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟上述程序相似的还有 string IO 操作：getline()。该函数接受两个参数：</p>
<ul>
<li>输入流对象；</li>
<li>string对象；</li>
</ul>
<p>该函数是读入输入流的下一行，并保存在string对象中。但行中不包含 <strong>换行符</strong>，getline只要遇到换行符，即便是输入的第一个字符，getline也会停止读入并返回。如果第一个字符是换行符，则string对象为空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>,word))&#123;	<span class="comment">//输入“ctrl+z”可以结束</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3、string对象的操作">2.3、string对象的操作</h4><table>
<thead>
<tr>
<th>string的操作</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.empty()</td>
<td>s为空返回true，否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中的字符个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>范围s中位置为n的字符，位置从0开始计数</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>连接s1，s2成一个新的字符串</td>
</tr>
<tr>
<td>s1 = s2</td>
<td>把s1的内容替换成s2的内容</td>
</tr>
<tr>
<td>s1 == s2</td>
<td>比较s1，s2的内容，相等返回true，否则false</td>
</tr>
<tr>
<td>!=, &lt;, &lt;=, &gt;, &gt;=</td>
<td>就是这些符号表达的意思</td>
</tr>
</tbody>
</table>
<p><strong>1、size()和empty()</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"ni hao\n"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"The size of"</span> &lt;&lt; s &lt;&lt; <span class="string">"is"</span> &lt;&lt; s.size() &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"empty!"</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以像上述程序一样使用size(),empty()。</p>
<p><strong>2、string::size_type类型</strong></p>
<p>从前面来看，size()返回的值似乎是int型，但实际上返回的是 <code>string::size_type</code> 类型。因为int类型所能表示的范围实在有限，所以string类型定义了新的配套类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::size_type i=<span class="number">0</span>; i!=s.size(); ++i)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说使用 int 类型也能够达到要求，但最安全的方法是使用 string::size_type 类型。</p>
<p><strong>3、string关系操作符</strong></p>
<ul>
<li><code>==, !=</code>：相等、不等</li>
<li><code>&lt;, &lt;=, &gt;, &gt;=</code>：小于、小于或等于、大于、大于或等于</li>
</ul>
<p>比较两个字符串时采用了和字典排序相同的策略（大小写敏感）：</p>
<ul>
<li>如果string对象长度不同，且短的string对象与长的对象前面部分相同，则短的小于长的；</li>
<li>如果两个string对象字符不同，则比较第一个不匹配的字符；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(<span class="string">"hey"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (s1 &lt; s2) &lt;&lt; <span class="string">", "</span> &lt;&lt; (s1 &lt; s3) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>输出结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>表示 s1 小于 s2，s1 小于 s3。</p>
<p><strong>4、相加</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"hey"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;	<span class="comment">//生成新字符串</span></span><br><span class="line">s1 += s2;				<span class="comment">//追加至s1末尾</span></span><br></pre></td></tr></table></figure>
<p><strong>5、与字符串字面值的连接</strong></p>
<p><code>+</code> 操作符的左右操作数必须有一个是 string 类型“</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;			<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">"world"</span> + <span class="string">"!"</span>;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + s2 + <span class="string">"!"</span>;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">string</span> s6 = <span class="string">"hello"</span> + <span class="string">"world"</span>;	<span class="comment">//error:两个字面值不能相加</span></span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">"hello"</span> + <span class="string">","</span> + s2;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p><strong>6、下标操作</strong></p>
<p>通过 <code>[]</code> 来取得string对象中的字符。且下标操作可以做左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::size_type i=<span class="number">0</span>; i!=s.size(); ++i)&#123;</span><br><span class="line">	s[i] = <span class="string">'*'</span>;	<span class="comment">//注意是 '*'，不是 "*"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任意可以产生整数值的表达式都可以作为下标：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; s[<span class="number">2</span>*<span class="number">2</span>] &lt;&lt; endl；</span><br></pre></td></tr></table></figure>
<h4 id="2-4、string对象中的字符处理">2.4、string对象中的字符处理</h4><p>经常需要对string对象中的单个字符处理，这些处理的函数在头文件 cctype 中定义</p>
<table>
<thead>
<tr>
<th>cctype定义的函数</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>isalnum(c)</td>
<td>c 是字母或数字，返回true</td>
</tr>
<tr>
<td>isalpha(c)</td>
<td>c 是字母，返回true</td>
</tr>
<tr>
<td>iscntrl(c)</td>
<td>c 是控制字符，返回true</td>
</tr>
<tr>
<td>isdigit(c)</td>
<td>c 是数字，返回true</td>
</tr>
<tr>
<td>isgraph(c)</td>
<td>c 不是空格，但可打印，返回true</td>
</tr>
<tr>
<td>isprint(c)</td>
<td>c 是可打印字符，返回true</td>
</tr>
<tr>
<td>ispunct(c)</td>
<td>c 是标点符号，返回true</td>
</tr>
<tr>
<td>isspace(c)</td>
<td>c 是空白字符，返回true</td>
</tr>
<tr>
<td>isxdigit(c)</td>
<td>c 是十六进制数，返回true</td>
</tr>
<tr>
<td>islower(c)</td>
<td>c 是小写字母，返回true</td>
</tr>
<tr>
<td>isupper(c)</td>
<td>c 是大写字母，返回true</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>若 c 是大写字母，返回 c 的小写形式；否则直接返回 c</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>若 c 是小写字母，返回 c 的大写形式；否则直接返回 c</td>
</tr>
</tbody>
</table>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::size_type i = <span class="number">0</span>; i != s.size(); ++i)&#123;</span><br><span class="line">	s[i] = <span class="built_in">toupper</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>从这篇博客开始学习《C++ primer》的第三章“标准库类型”。首先介绍命名空间的using声明和第一种库类型string。</p>
<h3 id="一、using声明">一、using声明</h3><hr>
<p>在本章之前所用到的标准库类型都使用了 <code>::</code> 操作符，该操作符是作用域操作符，如 <code>std::cin</code>。但每次使用标准库类型就需要添加 <code>std::</code> 显得非常麻烦，本节介绍一种安全的机制：<strong>using声明</strong>。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[5:头文件]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-5/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-5/</id>
    <published>2015-11-14T08:31:39.000Z</published>
    <updated>2015-11-30T02:56:30.743Z</updated>
    <content type="html"><![CDATA[<p>到目前为止，我们编写的程序都是把代码都放在同一个文件中来处理。但是很少程序能够都这么简单的由一个文件搞定，由多个文件组成的程序需要一种连接名字的使用和声明，在C++中通过 <strong>头文件</strong> 可以实现。</p>
<a id="more"></a>
<h3 id="一、设计自己的头文件">一、设计自己的头文件</h3><hr>
<p>头文件为相关声明提供了一个集中存放的位置。头文件一般包含：</p>
<ul>
<li>类的定义；</li>
<li>extern变量的声明；</li>
<li>函数的声明；</li>
</ul>
<p>正确使用头文件能带来两个好处：</p>
<ul>
<li>保证所有文件使用给定实体的同一声明；</li>
<li>当声明需要修改时，只需要更新头文件即可；</li>
</ul>
<p>不过也需要注意以下事项：</p>
<ul>
<li>头文件中所做的声明在逻辑上应该是放在一起的；</li>
<li>编译头文件需要一定时间；</li>
</ul>
<blockquote>
<p>为了减少头文件编译时间，有些C++的实现支持与编译头文件。</p>
</blockquote>
<h4 id="1-1、头文件用于声明而不是定义">1.1、头文件用于声明而不是定义</h4><p>设计头文件时，记住定义和声明的区别很重要。定义只可以出现一次，而声明可以多次。下面是一些定义，不该出现在头文件中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> val1 = <span class="number">10</span>;	<span class="comment">//有初始化，是 定义 不是 声明</span></span><br><span class="line"><span class="keyword">double</span> val2;			<span class="comment">//没有 extern 关键字，是定义</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为头文件包含在多个源文件中，所以不应该包含有变量或函数的定义。</p>
</blockquote>
<p>当然也有另外，头文件中可以定义类、值在编译时就已知的 const 对象和 inline函数（后续介绍）。</p>
<h4 id="1-2、const对象定义在头文件中">1.2、const对象定义在头文件中</h4><p>前一篇博客提到 const 变量默认是文件的局部变量，正如现在看到的，这样的默认设置原因在于允许 const 变量定义在头文件中。</p>
<p>如果 const 变量不是用常量表达式初始化，那么它就不应该在头文件中定义。相反，和其他变量一样，该 const 变量应该在源文件中定义并初始化。在头文件中用 extern 关键字来声明，以使其能够被多个文件共享。</p>
<h3 id="二、预处理器的简单实现">二、预处理器的简单实现</h3><hr>
<h4 id="2-1、头文件经常需要其他头文件">2.1、头文件经常需要其他头文件</h4><p>头文件经常需要使用 <code>#include</code> 其他头文件，比如Sales_item类就需要包含string库。包含其他头文件相当正常，甚至有时一个头文件被多次包含进同意源文件也不稀奇。因此设计头文件时，必须保证多次包含同一头文件不会产生歧义。使用 <strong>头文件保护符（header guard）</strong>，用于避免对已经看见头文件却重新处理。</p>
<h4 id="2-2、避免多重包含">2.2、避免多重包含</h4><p>在编译头文件之前，我们需要引入一些额外的预处理器设施。预处理器允许我们自定义变量。为避免名字冲突，预处理器变量经常用全大写字母表示。</p>
<p>预处理器变量有两种状态：已定义和未定义。 <code>#define</code> 表示接受一个名字并定义其为预处理器变量，<code>#ifndef</code> 表示检测预处理其变量是否被定义，如果未定义，那么紧跟 <code>#ifndef</code> 后面的代码都被处理，直到出现 <code>#endif</code>。可以使用下面方式避免多次包含同一头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifndef</span> SALESITEM_H</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> SALESITEM_H</span></span><br><span class="line"><span class="comment">//Sales_item 类及其数据和操作在此定义</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-3、自定义头文件">2.3、自定义头文件</h4><p><code>#include</code> 接受以下两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;standard_header&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"my_header.h"</span></span></span><br></pre></td></tr></table></figure>
<p>使用 <code>&lt;&gt;</code> 包含的头文件表示该头文件是标准库文件，编译器会在系统预定义的地方查找该头文件。而使用 <code>&quot;&quot;</code>包含的头文件认为它是非系统头文件，通常会在源文件所在路径开始寻找。</p>
<blockquote>
<p>至此，第二章 “变量和基本类型” 的内容到此结束，后续开始第三章 “标准库类型” 的内容。</p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>到目前为止，我们编写的程序都是把代码都放在同一个文件中来处理。但是很少程序能够都这么简单的由一个文件搞定，由多个文件组成的程序需要一种连接名字的使用和声明，在C++中通过 <strong>头文件</strong> 可以实现。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[4:const、引用和typedef]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-4/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-4/</id>
    <published>2015-11-12T08:31:33.000Z</published>
    <updated>2015-11-30T02:56:24.479Z</updated>
    <content type="html"><![CDATA[<h3 id="一、const">一、const</h3><hr>
<p>考虑问题：下面程序中数字 <code>0</code> 的含义？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><p>显然从程序来看，我们并不知道 <code>10</code> 是怎样一个存在，因此它也被称为 <strong>魔数（magic number）</strong>，意思是这个数的意义不能从上下文体现出来，就像魔术一样凭空出现了。</p>
</li>
<li><p>或者如果这个程序多次使用数字 <code>10</code> 的话，当需要要把 <code>10</code> 改为 <code>20</code> 的话就麻烦了。</p>
</li>
</ul>
<p>一种简单的解决办法是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != max; ++i)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样不仅可读性好很多，而且修改起来也相当方便。</p>
<blockquote>
<p><code>max</code> 是可以被修改的</p>
</blockquote>
<h4 id="1-1、定义const对象">1.1、定义const对象</h4><p>上面到，<code>max</code> 可能会被有意或无意的修改，在某些情况下这很严重。<strong>const</strong> 提供一种解决办法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">10</span>；</span><br></pre></td></tr></table></figure>
<p>此时定义 <code>max</code> 为 <strong>常量</strong> 并初始化为 10，但此时的 <code>max</code> 不可被修改。</p>
<blockquote>
<p>C++中的 const 跟 <strong>Java 中的 final</strong> 或 <strong>PHP 中的 define</strong> 类似。<br>const 定义的常量不可修改，所以定义时必须初始化如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>:<span class="built_in">string</span> hi = <span class="string">"Hello"</span>;<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i;	<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2、const对象默认为文件的局部变量">1.2、const对象默认为文件的局部变量</h4><p>跟普通的变量不一样，const定义的变量需要特别的说明才可以在其他文件中访问。例如</p>
<ul>
<li><p>普通变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">10</span>;		<span class="comment">//定义变量</span></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> max;	<span class="comment">//声明外部变量</span></span><br><span class="line"><span class="comment">//下面可以使用变量 max</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>const变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">10</span>;	<span class="comment">//定义变量</span></span><br><span class="line"><span class="comment">//file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> max;		<span class="comment">//声明外部变量</span></span><br><span class="line"><span class="comment">//下面可以使用const变量 max</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>定义非 <code>const</code> 变量时默认问 <code>extern</code>。而 <code>cost</code> 变量必须显式的指定它为 <code>extern</code> 才可以被其他文件访问。</p>
</blockquote>
<h3 id="二、引用">二、引用</h3><hr>
<p>引用（reference）就是对象的另一个名字。在实际程序中，引用主要作为函数的形参，形参的内容将在后续介绍。</p>
<p>引用是一种 <strong>复合类型（compound type）</strong>，在变量名前加 <code>&amp;</code> 符号来定义。复合类型是指用其他类型定义的类型。每个引用都关联到其他某一类型，<strong>不能定义引用的引用，但可以定义任意类型的引用，并且可以有多个引用</strong>。下面用例子说明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;reVal1 = val;	<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;reVal2 = val;	<span class="comment">//正确：val的第二个别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;reVal3;		<span class="comment">//错误：引用必须初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;reVal4 = <span class="number">1</span>;	<span class="comment">//错误：引用必须使用对象初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="2-1、引用是别名">2.1、引用是别名</h4><p>引用只是它所绑定对象的另一个名字，在引用上做的所有操作实际上都作用在原对象上：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reVal1 = <span class="number">5</span>；			<span class="comment">//相当于：val = 5；</span></span><br><span class="line">reVal1 += <span class="number">1</span>;		<span class="comment">//相当于：val += 1;</span></span><br><span class="line"><span class="keyword">int</span> val2 = reVal1;	<span class="comment">//相当于：int val2 = val;</span></span><br></pre></td></tr></table></figure>
<p>下面程序的结果更能直观的说明这个问题</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> &amp;reVal1 = val;</span><br><span class="line">	<span class="keyword">int</span> &amp;reVal2 = val;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"val = "</span> &lt;&lt; val &lt;&lt; <span class="string">", reVal1 = "</span>&lt;&lt; reVal1 &lt;&lt; <span class="string">", reVal2 = "</span> &lt;&lt; reVal2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	reVal1 = <span class="number">1</span>;	<span class="comment">//对 reVal1 操作</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"val = "</span> &lt;&lt; val &lt;&lt; <span class="string">", reVal1 = "</span>&lt;&lt; reVal1 &lt;&lt; <span class="string">", reVal2 = "</span> &lt;&lt; reVal2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	reVal2 = <span class="number">2</span>;	<span class="comment">//对 reVal2 操作</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"val = "</span> &lt;&lt; val &lt;&lt; <span class="string">", reVal1 = "</span>&lt;&lt; reVal1 &lt;&lt; <span class="string">", reVal2 = "</span> &lt;&lt; reVal2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果是： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="number">0</span>, reVal1 = <span class="number">0</span>, reVal2 = <span class="number">0</span></span><br><span class="line">val = <span class="number">1</span>, reVal1 = <span class="number">1</span>, reVal2 = <span class="number">1</span></span><br><span class="line">val = <span class="number">2</span>, reVal1 = <span class="number">2</span>, reVal2 = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2、const引用">2.2、const引用</h4><p>非 const 不能引用 const，只有 const 能够引用 const，且 const 引用不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">0</span>;			<span class="comment">//正确：0是右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;reVal1 = val;	<span class="comment">//正确：val是左值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;reVal2 = i;		<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">reVal1 = <span class="number">1</span>;					<span class="comment">//错误：const 引用是只读的</span></span><br><span class="line"><span class="keyword">int</span> &amp;reVal3 = val;			<span class="comment">//错误：非 const 不能引用 const</span></span><br></pre></td></tr></table></figure>
<p>跟非 const 不同之处还有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re1 = <span class="number">1</span>;			<span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re2 = re1 + i;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p>对于下面这种绑定到同一类型的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i =  <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re1 = i;	<span class="comment">//此时 re1 = 0；</span></span><br><span class="line">i = <span class="number">1</span>;				<span class="comment">//此时 re1 = 1；</span></span><br></pre></td></tr></table></figure>
<p>当改变 <code>i</code> 时，<code>re1</code> 也会被改变。</p>
<p>还有另一种情况：绑定到不同类型的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> i =  <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re1 = i;	<span class="comment">//此时 re1 = 1；</span></span><br><span class="line">i = <span class="number">2.1</span>;			<span class="comment">//此时 re1 = 1；</span></span><br></pre></td></tr></table></figure>
<p>因为对于这种情况，编译器会解释为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp =  i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;re1 = temp;</span><br></pre></td></tr></table></figure>
<p>所以，改变 <code>i</code> 实际上改变的是 <code>temp</code>， <code>re1</code> 不受影响。</p>
<blockquote>
<p>const 引用可以绑定左值或右值，非 const 引用只能绑定左值。</p>
</blockquote>
<h3 id="三、typedef">三、typedef</h3><hr>
<p>typedef 跟引用有点类似，不过 typedef 是定义类型的别名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;	<span class="comment">//wages 是 double 的别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> score;		<span class="comment">//score 是 int 的别名</span></span><br><span class="line"><span class="keyword">typedef</span> wages salary;	<span class="comment">//salary 是 double 的别名</span></span><br></pre></td></tr></table></figure>
<p>其作用是：</p>
<ul>
<li>为了隐藏特定的类型，强调使用类型的目的；</li>
<li>简化复杂的类型定义，易于理解；</li>
<li>允许一个类型用于多个目的，并且每次使用时目的明确；</li>
</ul>
<h3 id="四、枚举">四、枚举</h3><hr>
<p>如果要为某属定义一组可选择的值，每个只对应一种状态，比如文件的打开状态：输出，输入和追加分别对应 0,1,2。则有可能会这样定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> input = <span class="number">0</span>；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> output = <span class="number">1</span>；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> append = <span class="number">2</span>；</span><br></pre></td></tr></table></figure>
<p>属性选择很多时这样定义就不方便，<strong>枚举（enumeration）</strong> 是一种替代方法。</p>
<h4 id="4-1、定义和初始化枚举">4.1、定义和初始化枚举</h4><p>枚举的关键字是 <code>enum</code>，定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> open_modes &#123;input, output, append&#125;;</span><br></pre></td></tr></table></figure>
<p>默认地，第一个枚举成员赋值为 0，后面的依次加 1。</p>
<h4 id="4-2、枚举成员是常量">4.2、枚举成员是常量</h4><p>可以为一个或多个成员提供初值，初始化枚举成员的值必须是一个 <strong>常量表达式（constant expression）</strong>，整型字面值也是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sphere = 2, polygon = 2</span></span><br><span class="line"><span class="keyword">enum</span> forms &#123;shape = <span class="number">1</span>, sphere, cylinder = <span class="number">1</span>, polygon&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3、每个enum都定义了一种唯一的类型">4.3、每个enum都定义了一种唯一的类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">forms f1 = shape;	<span class="comment">//正确：shape 是 forms 类型的枚举成员</span></span><br><span class="line">forms f2 = square;	<span class="comment">//错误：square 不是 forms 类型；</span></span><br><span class="line">forms f3 = <span class="number">1</span>；		<span class="comment">//错误：1 是 int类型，不是forms类型</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>即使 1 与 shape 相关联，但是 1 赋值给 f3 还是非法的</p>
</blockquote>
<h3 id="五、类类型">五、类类型</h3><hr>
<p>在C++中可以通过定义 <strong>类（class）</strong> 来自定义数据类型。类定义了该类型的对象包含的数据和该类型对象可以执行的操作。标准库类型 <strong>string、istream、ostream</strong>都定义成类，关于类后续详细介绍。</p>
<p>本节继续使用在 <a href="http://www.jianshu.com/p/67a45978af28" target="_blank" rel="external">读《C++primer》day1：快速入门</a> 的第三部分提到的 <strong>Sales_item</strong> 类举例。</p>
<h4 id="5-1、从操作开始设计类">5.1、从操作开始设计类</h4><p>每个类都定义了一个 <strong>接口（interface）</strong> 和一个 <strong>实现（implementation）</strong>。接口由使用该类的代码需要执行组成，实现一般包括该类所需的数据及操作。</p>
<p>定义类时，通常先定义接口，即该类所提供的操作。以 Sales_item 举例：</p>
<ul>
<li>加法 <code>+</code> ：将两个对象相加；</li>
<li>输入 <code>&gt;&gt;</code> ： 读取一个对象；</li>
<li>输出 <code>&lt;&lt;</code> ：输出一个对象；</li>
<li>赋值 <code>=</code> ：将一个对象赋给另一个对象；</li>
<li>对比 <code>?</code> ：对比两个对象是否属于同一本书（函数same_isbn）；</li>
</ul>
<p>虽然现在我们并不能实现这些操作（需要更多的知识），但可以考虑实现这些操作需要什么样的数据：</p>
<ul>
<li>记录各书本的销售册数；</li>
<li>该书的总销售收入；</li>
<li>计算该书的平均售价；</li>
</ul>
<p>大概就可以知道需要一个 <code>unsigned</code> 类型对象来记录数的销售册数，一个 <code>double</code> 类型对象计入总收入，<code>string</code> 类型对象记录书本的ISBN。</p>
<h4 id="5-2、定义Sales_item类">5.2、定义Sales_item类</h4><p>按上一节提到的操作和数据，可以这样定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//各种操作在此定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>:<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类定义以关键字 <strong>class</strong> 开始，后面是该类的类名，类体位于花括号内部，花括号后面必须要跟一个分号。</p>
<blockquote>
<p>新手经常会忘记类定义后面的分号！</p>
</blockquote>
<p>类体可以为空，类体定义了该类型的数据和操作。这些数据和操作也称为 <strong>成员（member）</strong>，数据称为 <strong>数据成员（data member）</strong>，操作称为 <strong>成员函数</strong>。</p>
<p>类定义可以包含多个 private 和 public <strong>访问标号（access label）</strong>，给定的访问标号作用域到下一个访问标号出现时为止。类中 <strong>public</strong> 部分定义的成员在程序的任何部分都可以访问，不是类的组成部分的代码不能方便问 <strong>private</strong> 成员，这样可以保证Sales_item对象不能直接操纵数据成员。</p>
<h4 id="5-3、使用struct关键字">5.3、使用struct关键字</h4><p>struct 关键字也可以定义类类型，它是从 C 语言继承而来。区别</p>
<ul>
<li>用关键字 <code>class</code> 定义类：定义在第一个标号之前的所有成员都默认为private；</li>
<li>用关键字 <code>struct</code> 定义类：定义在第一个标号之前的所有成员都默认为public；</li>
</ul>
<p>用 <code>struct</code> 重新定义前面的Sales_item类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="comment">//不需要 public 访问标号</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>:<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用 class 和 struct 关键字定义类的唯一区别就在于 <strong>默认访问级别</strong>。默认情况下，struct 的成员为 public，而 class 的成员的是 private。 </p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、const">一、const</h3><hr>
<p>考虑问题：下面程序中数字 <code>0</code> 的含义？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[3:变量]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-3/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-3/</id>
    <published>2015-11-10T08:31:28.000Z</published>
    <updated>2015-11-30T02:56:11.518Z</updated>
    <content type="html"><![CDATA[<h3 id="首先">首先</h3><hr>
<p>考虑问题：<code>求2的3次方？</code></p>
<p>最直接的想到的可能是：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 raised to the power of 3 is "</span> &lt;&lt; <span class="number">2</span>*<span class="number">2</span>*<span class="number">2</span>  &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>固然，此方法可以求出2的3次方；但是如果要求2的20次方的话不太可能去连续乘20次，此时的替代方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val = <span class="number">2</span>;<span class="comment">//2为底</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">pow</span> = <span class="number">20</span>;<span class="comment">//20次方</span></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="built_in">pow</span>; ++i)&#123;</span><br><span class="line">    	result *= val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2 raised to the power of "</span> &lt;&lt; <span class="built_in">pow</span> &lt;&lt; <span class="string">" is "</span> &lt;&lt; result  &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 <code>val, pow, result 和 i</code> 都是变量。可以对数值进行存储、修改和查询。</p>
<h3 id="1、什么是变量">1、什么是变量</h3><hr>
<p>变量就是 <strong>提供了程序可以操作的有名字的存储区</strong>。</p>
<p>C++中每个变量都有特定的类型，类型确定了变量的 <strong>内存大小</strong>、<strong>该内存能储存的值的取值范围</strong> 及 <strong>可应用于该变量的操作</strong>。</p>
<ul>
<li><strong>左值（lvalue）</strong>：左值可以出现在赋值语句的左或右边。如<ul>
<li><code>i = i + 1;</code></li>
</ul>
</li>
<li><strong>右值（rvalue）</strong>：右值只能出现在赋值语句的右边。如<ul>
<li>正确：<code>i = 1;</code></li>
<li>错误：<code>0 = 1;</code></li>
</ul>
</li>
</ul>
<h3 id="2、变量名">2、变量名</h3><hr>
<p>变量名，即 <strong>标识符(identifier)</strong>。可以由 <strong>字母、数字和下划线</strong> 组成。</p>
<p>必须以 <strong>字母或划线开头</strong>，并且 <strong>区分大小写</strong>。</p>
<blockquote>
<p>C++语言本身没有限制变量名的长度，但考虑阅读和维护，变量名不应太长。</p>
</blockquote>
<h4 id="2-1、C++关键字">2.1、C++关键字</h4><p>C++的关键字不能作为变量名，下面是C++的所有关键字</p>
<table>
<thead>
<tr>
<th>C++关键字</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>asm</td>
<td>do</td>
<td>if</td>
<td>returen</td>
<td>try</td>
</tr>
<tr>
<td>auto</td>
<td>double</td>
<td>inline</td>
<td>short</td>
<td>typedef</td>
</tr>
<tr>
<td>bool</td>
<td>dynamic_cast</td>
<td>int</td>
<td>signed</td>
<td>typeid</td>
</tr>
<tr>
<td>break</td>
<td>else</td>
<td>long</td>
<td>sizeof</td>
<td>typename</td>
</tr>
<tr>
<td>case</td>
<td>enum</td>
<td>mutable</td>
<td>static</td>
<td>union</td>
</tr>
<tr>
<td>catch</td>
<td>explicit</td>
<td>namespace</td>
<td>static_cast</td>
<td>unsigned</td>
</tr>
<tr>
<td>char</td>
<td>export</td>
<td>new</td>
<td>struct</td>
<td>using</td>
</tr>
<tr>
<td>class</td>
<td>extern</td>
<td>operator</td>
<td>switch</td>
<td>virtual</td>
</tr>
<tr>
<td>const</td>
<td>false</td>
<td>private</td>
<td>template</td>
<td>void</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>public</td>
<td>throw</td>
<td>wchar_t</td>
</tr>
<tr>
<td>default</td>
<td>friend</td>
<td>register</td>
<td>true</td>
<td>while</td>
</tr>
<tr>
<td>delete</td>
<td>goto</td>
<td>reinterpret_cast</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<blockquote>
<p>为了发个表格也真是拼了，再次呼吁简书 @简叔 支持嵌入 html code（渴望脸</p>
</blockquote>
<p>除了上面的关键字，C++还保留了一些操作符的替代名</p>
<table>
<thead>
<tr>
<th>C++操作符的替代名</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td>and_eq</td>
<td>bitand</td>
<td>bitor</td>
<td>compl</td>
<td>not</td>
<td>not_eq</td>
<td>or</td>
<td>or_eq</td>
<td>xor</td>
<td>xor_eq</td>
</tr>
</tbody>
</table>
<blockquote>
<p>除了关键字，C++标准也保留了一组标识符用于标准库。<br>标识符 <strong>不能包含两个连续的下划线</strong>、<strong>下划线开头后面紧跟一个大写字母</strong>。</p>
</blockquote>
<h4 id="2-2、变量的命名习惯">2.2、变量的命名习惯</h4><ul>
<li>变量名一般用小写字母；如 <code>salary</code>，而不是 <code>Salary</code> 或 <code>SALARY</code>；</li>
<li>变量名一般用帮助记忆的名字。如 <code>salary</code> 而不是 <code>s</code>；</li>
<li>包含多个单词时，单词间添加一下划线，或内嵌单词的第一个字母大写。如 <code>my_salary</code> 或 <code>mySalary</code>；</li>
</ul>
<blockquote>
<p>不管你使用哪种命名习惯,但请保持一致!</p>
</blockquote>
<h3 id="3、定义对象">3、定义对象</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> books_sold;<span class="comment">//内置类型</span></span><br><span class="line"><span class="keyword">double</span> sales_price, avg_price;<span class="comment">//内置类型</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> title;<span class="comment">//标准库定义的类型</span></span><br><span class="line">Sales_item book;<span class="comment">//类对象</span></span><br></pre></td></tr></table></figure>
<p>int，double，std::string和Sales_item都是类型名。</p>
<h4 id="3-1、初始化">3.1、初始化</h4><p>两种初始化变量的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">val</span><span class="params">(<span class="number">1024</span>)</span></span>;<span class="comment">//直接初始化</span></span><br><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;<span class="comment">//复制初始化</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>复制初始化和直接初始化有微妙的差别，后续详细讲解。现在只要知道，<strong>直接初始化</strong> 语法更灵活且效率更高</p>
</blockquote>
<p>使用 <code>=</code> 初始化变量会很迷惑，因为会把 <strong>初始化</strong> 当成是 <strong>赋值</strong>。</p>
<blockquote>
<p>“初始化不是赋值”。<br>初始化是指创建变量并给它赋初始值，而赋值则是擦除对象当前的值并用新的值替代。</p>
</blockquote>
<h4 id="3-2、使用多种方法初始化">3.2、使用多种方法初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> title1 = <span class="string">"C++ Primer"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">title2</span><span class="params">(<span class="string">"C++ Primer"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则title就有两种初始化的方式。但下面用计数器和一个字符初始化一个变量 <code>nines</code> 就只能使用 <strong>直接初始化</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">nines</span><span class="params">(<span class="number">5</span>, <span class="string">'9'</span>)</span></span>; <span class="comment">//nines = "99999"</span></span><br></pre></td></tr></table></figure>
<h4 id="3-3、初始化多个变量">3.3、初始化多个变量</h4><ul>
<li>定义两个变量以上时，每个变量都可能有各自的初始化式。</li>
<li>可以用前面已定义的变量来初始化后面的变量。</li>
<li>已初始化变量与未初始化变量可以同时同意</li>
</ul>
<p>如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> salary = <span class="number">9999.99</span>, my_salary = salary*<span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> day, month(<span class="number">11</span>), year = <span class="number">2015</span>;</span><br><span class="line">day = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-4、初始化变量的规则">3.4、初始化变量的规则</h4><p>当定义变量而未初始化时，系统有时会帮我们</p>
<p><strong>内置类型变量的初始化</strong></p>
<p>内置类型变量是否自动初始化取决于 <strong>变量定义的位置</strong>。在函数体外定义的变量都初始化成0，函数体内的内置类型不自动进行初始化。</p>
<blockquote>
<p>使用未初始化的变量是常见的程序错误，通常也难以发现。如果够幸运的话，程序不能正确运行；但有时程序在一部机器上能够正确的运行，而另一部却不行。所以要尽量避免变量未初始化。</p>
</blockquote>
<p><strong>类类型的变量初始化</strong></p>
<p>每个类都定义了该类型的对象应该如何初始化。如前面提到的 <code>std::string</code> 就至少提供了两个构造函数（可以理解为初始化的方法）。</p>
<p>如果某个类未定义初始化函数，那它可以通过一个特殊的构造函数即 <strong>默认构造函数</strong> 来实现。如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> empty_str; <span class="comment">//empty_str = "";</span></span><br></pre></td></tr></table></figure>
<h4 id="3-5、声明和定义">3.5、声明和定义</h4><ul>
<li>定义（definition）：用于变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量仅有一个定义。</li>
<li><p>声明（declaration）：用于向程序表明变量的类型和名字。 <strong>定义也是声明</strong>：因为定义时也声明了它的类型和名字。也可以通过 <code>extern</code> 关键字声明变量而不定义。不定义变量的声明包括对象名、对象类型和对象前的关键字 <code>extern</code>:</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;        <span class="comment">//声明 i 而不是定义 i</span></span><br><span class="line">   <span class="keyword">int</span> i;                <span class="comment">//声明和定义 i</span></span><br><span class="line">   <span class="keyword">extern</span> <span class="keyword">int</span> j = <span class="number">1</span>;    <span class="comment">//定义 j</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><code>extern</code> 声明不是定义，不分配存储空间，但如果有初始化操作则会认为是定义，所以下面会出错。变量在程序中可以 <strong>声明多次，但只能定义一次</strong>。</p>
<pre><code><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">1</span>;    <span class="comment">//definition</span>
<span class="keyword">int</span> i;                <span class="comment">//error: redefinition</span>
</code></pre><p>另一种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">1</span>;        <span class="comment">//definition</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;            <span class="comment">//ok:声明不是定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i = <span class="number">2</span>;        <span class="comment">//error: redefinition</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量仅能定义一次，而且在使用变量之前必须定义或声明变量。</p>
</blockquote>
<h4 id="3-6、名字的作用域">3.6、名字的作用域</h4><p>C++程序中，每个名字都与唯一一个实体（如 <strong>变量、函数或类型的等</strong>）相关联。但在程序中还是可以多次使用同一个名字，只要上下文能够区分不同的意义，<strong>上下文</strong> 就称为 <strong>作用域（scope）</strong>，一个名字在不同的作用域中可以跟不同实体关联。</p>
<p>大多数作用域使用 <strong>花括号</strong> 来界定，如下程序说明了各种 <strong>作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> global_int = <span class="number">0</span>;    <span class="comment">//global_int: 全局作用域（global scope）。全局能访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> global_int = <span class="number">1</span>;    <span class="comment">//global_int: 局部作用域（local scope）。隐藏全局作用域，使用局部作用域</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;        <span class="comment">//sum：局部作用域（local scope）。main函数不能访问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)&#123;    <span class="comment">//val：语句作用域（statement scope）。for语句外不能访问</span></span><br><span class="line">	    sum += val;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The global_int is "</span> &lt;&lt; global_int &lt;&lt; <span class="built_in">std</span>::endl;        <span class="comment">//输出：The global_int is 1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 1 to 10 inclusive is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;<span class="comment">//输出：The sum of 1 to 10 inclusive is 55</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在函数内定义的局部变量名最好不同于要使用到的全局变量</p>
</blockquote>
<p>C++还有另外两种不同级别的作用域：<strong>类作用域（class scope）</strong> 和 <strong>命名空间作用域（namespace scope）</strong>，后续详细介绍。</p>
<h4 id="3-7、在变量使用处定义变量">3.7、在变量使用处定义变量</h4><p>一般来说，变量的定义或声明可以放在程序中变量未使用之前的任何位置。</p>
<blockquote>
<p>通常把变量定义放在首次使用的地方是一个好的方法</p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="首先">首先</h3><hr>
<p>考虑问题：<code>求2的3次方？</code></p>
<p>最直接的想到的可能是：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2: 基本类型与字面值常量]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp_primer4-2/"/>
    <id>http://bluestein.github.io/2015/11/cpp_primer4-2/</id>
    <published>2015-11-09T02:36:09.000Z</published>
    <updated>2015-11-30T02:56:42.218Z</updated>
    <content type="html"><![CDATA[<h3 id="一、基本内置类型">一、基本内置类型</h3><hr>
<p>C++定义的几种基本的<em>算术类型</em>：<strong>int</strong>，<strong>char</strong>，<strong>float</strong>和<strong>bool</strong>。以及特殊的<strong>void</strong>类型，void类型没有对应的值，通常用作无返回值函数的返回类型。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th>含义</th>
<th style="text-align:left">最小存储空间（位）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">bool</td>
<td>布尔型</td>
<td style="text-align:left">-</td>
</tr>
<tr>
<td style="text-align:left">char</td>
<td>字符型</td>
<td style="text-align:left">8</td>
</tr>
<tr>
<td style="text-align:left">wchar_t</td>
<td>宽字符型</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">short</td>
<td>短整型</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">int</td>
<td>整型</td>
<td style="text-align:left">16</td>
</tr>
<tr>
<td style="text-align:left">long</td>
<td>长整型</td>
<td style="text-align:left">32</td>
</tr>
<tr>
<td style="text-align:left">float</td>
<td>单精度浮点型</td>
<td style="text-align:left">6位有效数字</td>
</tr>
<tr>
<td style="text-align:left">double</td>
<td>双精度浮点型</td>
<td style="text-align:left">10位有效数字</td>
</tr>
<tr>
<td style="text-align:left">long double</td>
<td>拓展精度浮点型</td>
<td style="text-align:left">10位有效数字</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注：即使是c++标准规定了存储标准，但是并不能阻止编译器使用更大的存储空间。而且，对于int型几乎所有编译器使用的空间都比所要求的大。</p>
</blockquote>
<!-- more -->
<h4 id="1、整型">1、整型</h4><p>表示整数、<span style="color:red">字符</span>和布尔值的算术类型合称为<strong>整型(integral type)</strong>。（<em>没错，字符也是整型！）</em> <br> <strong>1 word(字) = 4 byte(字节) = 32 bit(位)</strong></p>
<ul>
<li>字符类型有两种：<strong>char</strong>和<strong>wchar_t</strong>。char能够保证存储机器基本字符集中任何字符相应的数值，因此char通常是<strong>单个机器字节</strong>（byte）；<strong>wchar_t</strong>类型用于拓展字符集，如汉字和日语，这些字符集中的一些字符不能用单个char表示；</li>
<li><strong>short</strong>、<strong>int</strong>和<strong>long</strong>都表示<strong>整型值</strong>。一般short为半个字（word）长，int为一个字长，而long为一个或两个字长（32位机器中int和long通常字长相同）；</li>
<li><strong>bool</strong>：true, false。可以将整型值赋给bool对象，0值表示false，非0值都代表true；</li>
</ul>
<p><strong>1.1、signed和unsigned</strong></p>
<p>整型除了bool之外都可以<strong>带符号</strong>（signed）也可以<strong>不带符号</strong>（unsigned）。</p>
<ul>
<li>signed（带符号）：能表示正数也可以表示负数（包括0）；</li>
<li>unsigned（不带符号）：只能表示0及以上的数；</li>
</ul>
<p>int，short和long默认是带符号型，需要指定unsigned才能获得无符号类型，其中unsigned int可以简写为unsigned。</p>
<p><strong>1.2、整型值的表示</strong></p>
<ul>
<li>unsigned类型的所有位均可表示数值。例如，在机器中定义了一种类型使用8位表示，则该类型的取值范围是 0~255；</li>
<li>signed类型在c++标准中并未定义如何用位来表示（我读的《C++primer》版本是第4版），由编译器自由决定。8位的signed类型取值范围至少是 -127~127，也有允许 -128~127.</li>
</ul>
<p><strong>1.3、整型的赋值</strong></p>
<p>疑问：当把一个超过其取值范围的值赋给一个指定类型的对象时，会发生什么？</p>
<ul>
<li>unsigned：编译器必须调整越界值使其满足要求，编译器会将该值对该类型的<strong>可能取值数</strong>求模。<br>例如8位的unsigned char，取值范围是 0~255，则可能的取值数是 256。当试图把 336存储到unsigned char中，实际存储的是80，因为 336%256 = 80。<br><blockquote>
<p>注：c++中把负值赋给unsigned对象是完全合法的</p>
</blockquote>
</li>
<li>signed：由编译器决定，可能跟unsigned类似，也可能采取其他方式。</li>
</ul>
<h4 id="2、浮点型">2、浮点型</h4><ul>
<li>float（单精度浮点数）：一个字长（32位）</li>
<li>double（双精度浮点数）：两个字长（64位）</li>
<li>long double（拓展精度）：三或四个字长（96位或128位）</li>
</ul>
<h3 id="二、字面值常量">二、字面值常量</h3><hr>
<p>像42这样的值，在程序中被称为<strong>字面值常量</strong>（literal constant）。</p>
<p>称它为<strong>字面值</strong>是因为只能用它的值来称呼它，称为<strong>常量</strong>是因为它的值不能被修改。</p>
<p>每个字面值都有相应的类型，例如：0是int型；3.14159是double型。</p>
<p>只有内置类型存在字面值，没有类类型的字面值。因此，标准库类型没有字面值。</p>
<h4 id="2-1、整型字面值规则">2.1、整型字面值规则</h4><p>整数常量可以使用下列三种进制的任意一种：<strong>十进制、八进制和十六进制</strong>。</p>
<p>例如值20的定义：</p>
<ul>
<li>decimal:&#9;20</li>
<li>octal:&#9;024</li>
<li>hexadecimal:&#9;0x14</li>
</ul>
<p>字面值整数常量的默认类型为<strong>int或long</strong>。</p>
<p>这取决与字面值——值适合int就是int型，大于int就是long（即，假设int为1机器字长(32位)，则 <code>-2^31+1 ~ 2^31-1</code> 为int，大于 <code>2^31-1</code> 的为long）。</p>
<p>通过加后缀可以把字面值类型转换成long，unsigned或unsigned long。</p>
<ul>
<li>long: 20L</li>
<li>unsigned: 20U(20u)</li>
<li>unsigned long: 20UL(20LU/20Lu/20uL)</li>
</ul>
<blockquote>
<p>注：定义long类型时，推荐使用大写字母 L ，因为用户读起来时，小写字母 l 很容易和数字 1 混淆！</p>
</blockquote>
<h4 id="2-2、浮点字面值规则">2.2、浮点字面值规则</h4><p>可以用<strong>十进制或科学计数法</strong>表示浮点字面值常量。</p>
<p>科学计数法指的是，<strong>指数</strong>用 E 或 e 表示。</p>
<p>默认的浮点字面值常量是<strong>double型</strong>。后缀加上 F 或 f 表示单精度，加上 L 或 l 表示拓展精度（<span style="color:red">不推荐使用小写字母 l</span>）</p>
<p>下面每一列的字面值是表示相同的值：</p>
<table>
<thead>
<tr>
<th style="text-align:left">3.14159F</th>
<th style="text-align:left">.001f</th>
<th style="text-align:left">12.345L</th>
<th style="text-align:left">0.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">3.14159E0f</td>
<td style="text-align:left">1E-3f</td>
<td style="text-align:left">1.2345E1L</td>
<td style="text-align:left">0e0</td>
</tr>
</tbody>
</table>
<h3 id="2-3、布尔字面值和字符字面值">2.3、布尔字面值和字符字面值</h3><p>bool的字面值： <strong>true和false</strong>。</p>
<p>可打印的字符型字面常量通常用一对单引号来定义： <strong>‘a’, ‘2’, ‘,’, ‘ ‘(空格)</strong>；<br> 加上 L 可以得到 wchar_t 类型的宽字符字面值： <strong>L’a’</strong>。</p>
<h4 id="2-4、非打印字符的转义序列">2.4、非打印字符的转义序列</h4><table>
<thead>
<tr>
<th style="text-align:left">\n</th>
<th style="text-align:left">\r</th>
<th style="text-align:left">\a</th>
<th style="text-align:left">\b</th>
<th style="text-align:left">\t</th>
<th style="text-align:left">\v</th>
<th style="text-align:left">\f</th>
<th style="text-align:left">\?</th>
<th style="text-align:left">\”</th>
<th style="text-align:left">\’</th>
<th style="text-align:left">\</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">换行符</td>
<td style="text-align:left">回车符</td>
<td style="text-align:left">报警符</td>
<td style="text-align:left">退格符</td>
<td style="text-align:left">水平制表符</td>
<td style="text-align:left">纵向制表符</td>
<td style="text-align:left">进纸符</td>
<td style="text-align:left">疑问号</td>
<td style="text-align:left">双引号</td>
<td style="text-align:left">单引号</td>
<td style="text-align:left">反斜杠</td>
</tr>
</tbody>
</table>
<p>任何字符都可以通过 <strong>“\XXX”</strong> 的形式表示，“XXX”表示三位八进制数字。下面是用ASCII码表示字面常量：</p>
<ul>
<li>\7 : 报警符</li>
<li>\0 : 空格符</li>
<li>\12: 换行符</li>
<li>\40: 空格符</li>
<li>\115: ‘M’</li>
<li>\062: ‘2’</li>
</ul>
<h4 id="2-5、字符串字面值">2.5、字符串字面值</h4><p>前面的均是基本内置类型，下面的 <strong>字符串字面值</strong> 会更复杂一些，后续会详细说明。</p>
<p>字符串字面值常量是 <strong>双引号括起来的零个或多个字符</strong>，<strong>不可打印的字符</strong>使用相应的转义字符。</p>
<ul>
<li>“Hello World!”</li>
<li>“”</li>
<li>“\nHello\tWorld!\n”</li>
</ul>
<blockquote>
<p>注：为了兼容C语言，C++会在所有字符串字面值常量末尾添加一个空字符<code>&lt;br/&gt;</code>如 ‘A’ 表示 单个字符 A，而 “A” 表示字符 A 和一个空字符两个字符的字符串</p>
</blockquote>
<h4 id="2-6、字符串字面值的连接">2.6、字符串字面值的连接</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span></span><br><span class="line">	<span class="string">" "</span></span><br><span class="line">	<span class="string">"World"</span> <span class="string">"!"</span></span><br><span class="line">	&lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt;<span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>但是下面试图连接 <strong>字符串字面值和宽字符串字面值</strong> 是非法的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> <span class="string">L" World!"</span> &lt;&lt;<span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<h4 id="2-7、多行字面值">2.7、多行字面值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::cou\</span><br><span class="line">t&lt;&lt; <span class="string">"Hello"</span> &lt;&lt; st\</span><br><span class="line">d::endl;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>反斜杠 <strong>‘\’</strong> 必须是该行的结尾，不允许后面有空格或注释。同样的，下一行的前面也不能有任何空格和制表符。</p>
<p>对于下一个 <strong>长字符串</strong> 例子，反斜杠后也不能有其他字符；而后一行的前面所有空格或制表符都会成为 <strong>长字符串的一部分</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello \</span><br><span class="line">	World!"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、基本内置类型">一、基本内置类型</h3><hr>
<p>C++定义的几种基本的<em>算术类型</em>：<strong>int</strong>，<strong>char</strong>，<strong>float</strong>和<strong>bool</strong>。以及特殊的<strong>void</strong>类型，void类型没有对应的值，通常用作无返回值函数的返回类型。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1: 快速入门]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp_primer4-1/"/>
    <id>http://bluestein.github.io/2015/11/cpp_primer4-1/</id>
    <published>2015-11-08T02:33:12.000Z</published>
    <updated>2015-11-30T02:56:42.215Z</updated>
    <content type="html"><![CDATA[<h3 id="一、iostream（输入输出流）">一、iostream（输入输出流）</h3><hr>
<p><strong>i</strong>, <strong>o</strong>分别表示 <code>istream</code> （输入流） 和 <code>ostream</code>（输出流）；<strong>stream</strong>表示 <code>流</code>：随着时间顺序生成或消耗；合起来就是<strong>iostream</strong>（输入输出流）。</p>
<a id="more"></a>
<h4 id="1-1、4个IO对象">1.1、4个IO对象</h4><ul>
<li><strong>cin</strong>：标准输入；</li>
<li><strong>cout</strong>：标准输出；</li>
<li><strong>cerr</strong>：标准错误，通常用来输出警告和错误信息给程序使用者；</li>
<li><strong>clog</strong>：常用于输出程序执行时的一般信息；</li>
</ul>
<p>（后两个第一次知道，逃</p>
<h4 id="1-2、例子">1.2、例子</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two Numbers:"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">int</span> val1, val2;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; val1 &gt;&gt; val2;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span> &lt;&lt; val1 &lt;&lt; <span class="string">" and "</span> &lt;&lt; val2</span><br><span class="line">			&lt;&lt; <span class="string">" is "</span> &lt;&lt; val1+val2 &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行告诉编译器要使用<strong>iostream</strong>库；</li>
<li>输出流（写入到流）：<ul>
<li>输出操作符 <code>&lt;&lt;</code> 将值写入到 <code>流</code>，即 <code>输出</code>。该操作符每次接受两个操作数：左操作数必须是ostream对象；右操作数是要输出的值；</li>
<li>C++中的每个表达式都会产生一个结果，就是说 <code>std::cout&lt;&lt;a;</code> 也会产生返回值，但输出操作符 <code>&lt;&lt;</code> 返回的是输出流本身，所以可以将多个输出连接在一起，形如 <code>std::cout&lt;&lt;a&lt;&lt;b;</code>；</li>
</ul>
</li>
<li>输入流（读入到流）：跟输出流类似；</li>
<li><code>std</code> 表示使用<em>命名空间</em> <strong>std</strong>中定义的的名字；</li>
<li><code>endl</code> 称为操纵符(manipulator)，将它写入 <code>流</code> 时，具有换行的效果，并同时会刷新相关联的缓冲区(buffer)。通过刷新缓冲区，用户可以立即看到写入 <code>流</code> 中的输出；</li>
</ul>
<h3 id="二、控制结构">二、控制结构</h3><hr>
<h4 id="2-1、while语句和for语句">2.1、while语句和for语句</h4><p>问题：求1到10（包括10）的和？</p>
<p><strong>while语句：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (val &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">		sum += val;</span><br><span class="line">		++val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 1 to 10 inclusive is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>while语句的结构形式：<code>while (condition) while_body_statement;</code>。表示，通过测试 <code>condition</code> 为真时执行 <code>while_body_statement</code>，重复这一过程直到 <code>condition</code> 为假<ul>
<li><code>condition</code> 是一个可求值得表达式。如果结果非零，那么为<strong>真</strong>；如果结果为为零，则为<strong>假</strong>；</li>
<li><code>&lt;=</code> 表示<strong>小于等于</strong>操作符；</li>
<li><code>sum += val;</code> 等价于 <code>sum = sum + val;</code>。类似的，<code>++val;</code> 等价于 <code>val = val + 1;</code>；</li>
</ul>
</li>
</ul>
<p>还有另一种情形：只对输入的值进行求和</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>, val;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)&#123;	<span class="comment">//windows系统下输入 ctrl+z 可以作为文件结束符(end-of-file)</span></span><br><span class="line">		sum += val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for语句：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> val = <span class="number">1</span>; val &lt;= <span class="number">10</span>; ++val)&#123;</span><br><span class="line">		sum += val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of 1 to 10 inclusive is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>for语句可以简化管理循环变量.不像在while语句中，需要 <code>val</code> 这样的值来控制循环。其执行流程为：<ul>
<li>1，创建 <code>val</code> 并初始化为1</li>
<li>2，测试 <code>val</code> 是否小于或等于10</li>
<li>3，如果 <code>val</code> 小于或等于10，执行for循环体：把 <code>val</code> 值加到 <code>sum</code> 变量中；否则，执行for语句体之后的语句</li>
<li>4，<code>val</code> 加1</li>
<li>5，重复第2~4步</li>
</ul>
</li>
</ul>
<h4 id="2-2、if语句">2.2、if语句</h4><p>假设这样一种情况：将用户输入的两个数作为上、下界，然后用上面的循环求和。这个时候我们就需要判定那个数值更大而作为上界，另一个作为下界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter two Numbers:"</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">int</span> val1, val2;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt; val1 &gt;&gt; val2;</span><br><span class="line">	<span class="keyword">int</span> lower, upper;</span><br><span class="line">	<span class="keyword">if</span> (val1 &lt;= val2) &#123;</span><br><span class="line">		lower = val1;</span><br><span class="line">		upper = val2;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		lower = val2;</span><br><span class="line">		upper = val1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> val = lower; val &lt;= upper; ++val)&#123;</span><br><span class="line">		sum += val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of "</span>&lt;&lt; lower &lt;&lt; <span class="string">" to "</span>&lt;&lt; upper &lt;&lt;<span class="string">" inclusive is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码就不用多说了，一眼就能看出来</li>
</ul>
<h3 id="三、类的简介">三、类的简介</h3><hr>
<p>假设有书店问题：某书店以文件形式保存每一笔交易。每笔交易形式如：<br>0-201-70353-x&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;24.99<br>第一个元素是ISBN，第二个为销售册数，第三个为单价。店主定期查看这个文件，统计每本书的销售册数、总销售额以及平均售价。</p>
<h4 id="3-1、Sales_item类">3.1、Sales_item类</h4><ol>
<li><p>Sales_item对象上的操作</p>
<ul>
<li>加法 <code>+</code> ：将两个对象相加；</li>
<li>输入 <code>&gt;&gt;</code> ： 读取一个对象；</li>
<li>输出 <code>&lt;&lt;</code> ：输出一个对象；</li>
<li>赋值 <code>=</code> ：将一个对象赋给另一个对象；</li>
<li>对比 <code>?</code> ：对比两个对象是否属于同一本书（函数same_isbn）；</li>
</ul>
</li>
<li><p>初探成员函数</p>
<p> 成员函数是由类定义的函数，也称为<strong>类方法</strong>。如 <code>item1.same_isbn(item2)</code> 调用类Sales_item的成员函数same_isbn来对比 <code>item1</code> 和 <code>item2</code>。</p>
</li>
</ol>
<blockquote>
<p>注：标准库的头文件用尖括号 <code>&lt;&gt;</code> 括起来，非标准库用双引号 <code>&quot;&quot;</code>。</p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、iostream（输入输出流）">一、iostream（输入输出流）</h3><hr>
<p><strong>i</strong>, <strong>o</strong>分别表示 <code>istream</code> （输入流） 和 <code>ostream</code>（输出流）；<strong>stream</strong>表示 <code>流</code>：随着时间顺序生成或消耗；合起来就是<strong>iostream</strong>（输入输出流）。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
</feed>
