<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo]]></title>
  <subtitle><![CDATA[My <a href="https://github.com/bluestein">GitHub</a>]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2016-06-11T15:44:41.173Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[2048]]></title>
    <link href="http://bluestein.github.io/2016/06/2048/2048/"/>
    <id>http://bluestein.github.io/2016/06/2048/2048/</id>
    <published>2016-06-11T15:32:42.000Z</published>
    <updated>2016-06-11T15:44:41.173Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<a id="more"></a>
<html><br><head><br><meta charset="UTF-8"><br><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0"><br><title>2048</title><br><link rel="stylesheet" href="/css/2048/style.css"><br><script type="text/javascript" src="http://libs.baidu.com/jquery/2.0.3/jquery.min.js"></script><br><script type="text/javascript" src="/js/src/2048/main.js"></script><br><script type="text/javascript" src="/js/src/2048/showanimation.js"></script><br><script type="text/javascript" src="/js/src/2048/support.js"></script><br></head><br><body><br><header><br><h1>2048</h1><br><a href="javascript:new_game();" id="new_game_button" target="_blank" rel="external">New Game</a><br><p>score: <span id="score">0</span></p><br></header><br><div id="grid_container"><br><div class="grid_cell" id="grid_cell_0_0"></div><br><div class="grid_cell" id="grid_cell_0_1"></div><br><div class="grid_cell" id="grid_cell_0_2"></div><br><div class="grid_cell" id="grid_cell_0_3"></div><br><div class="grid_cell" id="grid_cell_1_0"></div><br><div class="grid_cell" id="grid_cell_1_1"></div><br><div class="grid_cell" id="grid_cell_1_2"></div><br><div class="grid_cell" id="grid_cell_1_3"></div><br><div class="grid_cell" id="grid_cell_2_0"></div><br><div class="grid_cell" id="grid_cell_2_1"></div><br><div class="grid_cell" id="grid_cell_2_2"></div><br><div class="grid_cell" id="grid_cell_2_3"></div><br><div class="grid_cell" id="grid_cell_3_0"></div><br><div class="grid_cell" id="grid_cell_3_1"></div><br><div class="grid_cell" id="grid_cell_3_2"></div><br><div class="grid_cell" id="grid_cell_3_3"></div><br></div><br></body><br></html>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="HTML" scheme="http://bluestein.github.io/tags/HTML/"/>
    
      <category term="JS" scheme="http://bluestein.github.io/tags/JS/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Game" scheme="http://bluestein.github.io/categories/Code/Game/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[腾讯笔试]]></title>
    <link href="http://bluestein.github.io/2016/04/tencent-test/"/>
    <id>http://bluestein.github.io/2016/04/tencent-test/</id>
    <published>2016-04-12T01:02:05.000Z</published>
    <updated>2016-04-25T06:14:28.013Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>几天前参加了腾讯的笔试（内退为何没电话面试呢），说实话我感觉选错岗位了。我选择的是 移动客户端开发方向，也就会涉及到Android iOS 方面的题目。对此我几乎不了解，这是我又一次自我认知的失误。而且，对于后面的主观题，代码格式和在线调试功能在最后十几分钟才有所了解，可以算得上是一次实战演戏吧。面是一些选择题涉及到的知识，并作回答：</p>
<a id="more"></a>
<p>目录：</p>
<ol>
<li><a href="#http返回码">http返回码</a></li>
<li><a href="#死锁和银行家算法">死锁和银行家算法</a></li>
<li><a href="#动态库和静态库">动态库和静态库</a></li>
<li><a href="#散列存储">散列存储</a></li>
<li><a href="#Android_NDK">Android NDK</a></li>
<li><a href="#&amp;的用法">&amp;的用法</a></li>
<li><a href="#完全二叉树">完全二叉树</a></li>
<li><a href="#栈溢攻击">栈溢攻击</a></li>
<li><a href="#无向图的点和边数">无向图的点和边数</a></li>
</ol>
<h3 id="http返回码">http返回码</h3><h4 id="1-_1xx_Informational">1. 1xx Informational</h4><p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx 响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p>
<p><strong>100 Continue</strong></p>
<p>客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。</p>
<p><strong>101 Switching Protocols</strong></p>
<p>服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。</p>
<p>只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本（如HTTP/2）比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。</p>
<p><strong>102 Processing</strong></p>
<p>由<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="external">WebDAV</a>(<a href="https://tools.ietf.org/html/rfc2518" target="_blank" rel="external">RFC 2518</a>)扩展的状态码，代表处理将被继续执行。</p>
<p><strong>100 Continue</strong></p>
<h4 id="2-_2xx_Success">2. 2xx Success</h4><p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<p><strong>200 OK</strong></p>
<p>请求已成功，请求所希望的响应头或数据体将随此响应返回。</p>
<p><strong>201 Created</strong></p>
<p>请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="external">URI</a> 已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。</p>
<p><strong>202 Accepted</strong></p>
<p>服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。<br>返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</p>
<p><strong>203 Non-Authoritative Information</strong></p>
<p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<p><strong>204 No Content</strong></p>
<p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。</p>
<p>如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。</p>
<p>由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<p><strong>205 Reset Content</strong></p>
<p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。</p>
<p>与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<p><strong>206 Partial Content</strong></p>
<p>服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。<br>响应必须包含如下的头部域：</p>
<ol>
<li>Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。</li>
<li>Date</li>
<li>ETag和／或Content-Location，假如同样的请求本应该返回200响应。</li>
<li>Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</li>
</ol>
<p>假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。</p>
<p>任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。</p>
<p><strong>207 Multi-Status</strong></p>
<p>由<a href="https://zh.wikipedia.org/wiki/WebDAV" target="_blank" rel="external">WebDAV</a>(<a href="https://tools.ietf.org/html/rfc2518" target="_blank" rel="external">RFC 2518</a>)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<ol>
<li>3xx Redirection</li>
</ol>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p>
<p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<p><strong>300 Multiple Choices</strong></p>
<p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p>除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。</p>
<p>如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的<a href="https://zh.wikipedia.org/wiki/URI" target="_blank" rel="external">URI</a>；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。</p>
<p><strong>301 Moved Permanently</strong></p>
<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p>新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</p>
<p>如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<blockquote>
<p>注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。</p>
</blockquote>
<p><strong>302 Found</strong></p>
<p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</p>
<p>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<blockquote>
<p>注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。</p>
</blockquote>
<p><strong>303 See Other</strong></p>
<p>对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。</p>
<p>新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。</p>
<blockquote>
<p>注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。</p>
</blockquote>
<p><strong>304 Not Modified</strong></p>
<p>如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>
<p>该响应必须包含以下的头信息：</p>
<ol>
<li>Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。</li>
<li>ETag和／或Content-Location，假如同样的请求本应返回200响应。</li>
<li>Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</li>
</ol>
<p>假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。</p>
<p>假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。</p>
<p>假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。</p>
<p><strong>305 Use Proxy</strong></p>
<p>被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。</p>
<blockquote>
<p>注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。</p>
</blockquote>
<p><del><strong>306 Switch Proxy</strong></del></p>
<p>在最新版的规范中，306状态码已经不再被使用。</p>
<p><strong>307 Temporary Redirect</strong></p>
<p>请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p>新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。</p>
<p>如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<h4 id="4-_4xx_Client_Error">4. 4xx Client Error</h4><p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<p><strong>400 Bad Request</strong></p>
<p>由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p>
<p><strong>401 Unauthorized</strong></p>
<p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。</p>
<p><strong>402 Payment Required</strong></p>
<p>该状态码是为了将来可能的需求而预留的。</p>
<p><strong>403 Forbidden</strong></p>
<p>服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。</p>
<p><strong>404 Not Found</strong></p>
<p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p><strong>405 Method Not Allowed</strong></p>
<p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。</p>
<p>鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<p><strong>406 Not Acceptable</strong></p>
<p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p>
<p>除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。</p>
<p><strong>407 Proxy Authentication Required</strong></p>
<p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。</p>
<p><strong>408 Request Timeout</strong></p>
<p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<p><strong>409 Conflict</strong></p>
<p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p>
<p>冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。</p>
<p><strong>410 Gone</strong></p>
<p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。</p>
<p>410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。</p>
<p><strong>411 Length Required</strong></p>
<p>服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。</p>
<p><strong>412 Precondition Failed</strong></p>
<p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<p><strong>413 Request Entity Too Large</strong></p>
<p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<p><strong>414 Request-URI Too Long</strong></p>
<p>请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p>
<ol>
<li>本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</li>
<li>重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。</li>
<li>客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</li>
</ol>
<p><strong>415 Unsupported Media Type</strong></p>
<p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>
<p><strong>416 Requested Range Not Satisfiable</strong></p>
<p>如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。</p>
<p>假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。</p>
<p><strong>417 Expectation Failed</strong></p>
<p>在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。</p>
<p><strong>418 I’m a teapot</strong></p>
<p>本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 <a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E5%92%96%E5%95%A1%E5%A3%B6%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">超文本咖啡壶控制协议</a>中定义的，并不需要在真实的HTTP服务器中定义。当一个控制茶壶的HTCPCP收到BREW或POST指令要求其煮咖啡时应当回传此错误。</p>
<p><strong>421 There are too many connections from your internet address</strong></p>
<p>从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。</p>
<p><strong>422 Unprocessable Entity</strong></p>
<p>请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）</p>
<p><strong>423 Locked</strong></p>
<p>当前资源被锁定。（RFC 4918 WebDAV）</p>
<p><strong>424 Failed Dependency</strong></p>
<p>由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）</p>
<p><strong>425 Unordered Collection</strong></p>
<p>在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。</p>
<p><strong>426 Upgrade Required</strong></p>
<p>客户端应当切换到TLS/1.0。（RFC 2817）</p>
<p><strong>449 Retry With</strong></p>
<p>由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>
<p><strong>451 Unavailable For Legal Reasons</strong></p>
<p>由IETF核准，代表该访问因法律的要求而被拒绝。</p>
<h4 id="5-_5xx_Server_Error">5. 5xx Server Error</h4><p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<p>这些状态码适用于任何响应方法。</p>
<p><strong>500 Internal Server Error</strong></p>
<p>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。</p>
<p><strong>501 Not Implemented</strong></p>
<p>服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。</p>
<p><strong>502 Bad Gateway</strong></p>
<p>作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p>
<p><strong>503 Service Unavailable</strong></p>
<p>由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。</p>
<p><strong>504 Gateway Timeout</strong></p>
<p>作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>注意：某些代理服务器在DNS查询超时时会返回400或者500错误。</p>
<p><strong>505 HTTP Version Not Supported</strong></p>
<p>服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。</p>
<p><strong>506 Variant Also Negotiates</strong></p>
<p>由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。</p>
<p><strong>507 Insufficient Storage</strong></p>
<p>服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。（WebDAV RFC 4918）</p>
<p><strong>509 Bandwidth Limit Exceeded</strong></p>
<p>服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。</p>
<p><strong>510 Not Extended</strong></p>
<p>获取资源所需要的策略并没有被满足。</p>
<p><strong>511 Network Authentication Required (RFC 6585)</strong></p>
<p>客户端需要获得网络访问的身份验证。供拦截代理用于控制网络访问(例如, “<a href="https://en.wikipedia.org/wiki/Captive_portal" target="_blank" rel="external">captive portals</a>“ used to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot)</p>
<p>参见：<a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="external">HTTP状态码</a></p>
<h3 id="死锁和银行家算法">死锁和银行家算法</h3><h4 id="死锁">死锁</h4><p>指多个进程在运行过程中因争夺资源而造成的一种僵局（DeadlyEmbrace）。当进程处于这种僵局状态时，若无外力作用，它们将无法继续向前推进。</p>
<p><strong>产生原因</strong></p>
<ol>
<li>竞争资源<br>当系统中供多个进程共享的资源如打印机、公共队列等，其数目不足以满足所有进程的需要时，会引起进程对资源的竞争而产生死锁；</li>
<li>进程间推进顺序非法<br>程序运行过程中，请求和释放资源的顺序不当，也同样会产生死锁；</li>
</ol>
<p><strong>1. 竞争资源产生死锁</strong></p>
<p><strong>1.1 可剥夺非剥夺性资源</strong></p>
<p>可把系统资源分为两类：可剥夺性资源、非剥夺性资源</p>
<p><strong>可剥夺性资源</strong>是指某进程获得该类资源后，该资源可以被其他进程或系统剥夺。例如，优先级高的进程可以剥夺优先权低的进程的CPU 资源。又如，内存区可有存储管理器程序把一个进程从一个存储区移到另一个，此即从多了该进程原来占有的存储区。甚至可将进程从内存调出到外存上。可见CPU 和主存都是可剥夺性资源。</p>
<p><strong>非剥夺性资源</strong>指当系统分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如打印机，刻录机等。</p>
<p><strong>1.2 竞争非剥夺性资源</strong></p>
<p>例如，系统中只有一台打印机R1 和一台刻录机 R2，可供进程P1 和P2 共享。假定P1 已经占用了打印机R1，P2占用了刻录机R2。</p>
<p>此时，若P2 请求打印机，P2 将阻塞；P1 又请求刻录机，P1 也将阻塞。</p>
<p>于是P1 和P2 间形成僵局，两个进程都在等待对方释放出已占有的资源。但它们都因不能获得所需资源而不能继续推进，也不能释放已占有的资源。</p>
<p>如下图所示，箭头表示请求资源，可以看到P1 P2 和 R1 R2 形成环路，进入死锁。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    -&gt;    <span class="type">P1</span>    -&gt;</span><br><span class="line"><span class="type">R1</span>                    <span class="type">R2</span></span><br><span class="line">    &lt;-    <span class="type">P2</span>    &lt;-</span><br></pre></td></tr></table></figure>
<p><strong>1.3 竞争临时性资源</strong></p>
<p>上述打印机资源属于可顺序重复使用的资源，称为永久性资源。还有一种是临时性资源，指由一个进程产生，被另一进程使用一短暂事件后便无用的资源，也称为消耗性资源。</p>
<p>例如，下图所示也将形成死锁。图中S1 S2 S3 是临时资源，P1 产生S1，又要求从P3 请求S3；P2 产生S2，又要求从P1 请求S1；P3 产生S3，又要求从P2 请求S2；</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    &lt;-    <span class="literal">P1</span>    &lt;-</span><br><span class="line"><span class="label">S3</span>                    <span class="literal">S1</span></span><br><span class="line"><span class="title">|                      |</span></span><br><span class="line"><span class="label">P3</span>                    <span class="literal">P2</span></span><br><span class="line">    -&gt;    <span class="literal">s2</span>    -&gt;</span><br></pre></td></tr></table></figure>
<p><strong>2. 进程推进顺序不当引起的死锁</strong></p>
<p><strong>2.1 合法的推进</strong></p>
<p>如果按下列顺序推进，则两个进程都可以顺利完成：</p>
<p>P1: Request(R1); Request(R2);<br>P1: Releast(R1); Releast(R2);<br>P2: Request(R2); Request(R1);<br>P2: Releast(R2); Releast(R1);</p>
<p>这种就叫作合法的推进。</p>
<p><strong>2.2 推进顺序非法</strong></p>
<p>如果推进过程中，会进入不安全状态。如，P1 保持了资源R1，P2 保持了R2，系统就处于不安全状态。此时，再向前推进，则有可能进入死锁状态。</p>
<p><strong>产生死锁的必要条件</strong></p>
<ol>
<li>互斥条件<br>指进程所分配到的资源进行排他性使用，即在一段时间之内，该资源只能由一个进程占用。</li>
<li>请求和保持条件<br>进程已经保持了至少一个资源，但又提出了新的资源请求。</li>
<li>不剥夺条件<br>进程已获得的资源，在未使用完之前，不能被剥夺</li>
<li>环路等待条件<br>发生死锁时，必然存在一个“进程-资源”的环形链</li>
</ol>
<p><strong>处理死锁的方法</strong></p>
<ol>
<li>预防死锁<br>通过设置某些限制条件，从而去破坏死锁的必要条件中的一个或多个。</li>
<li>避免死锁<br>也属于事先预防的策略。但它并不是去破坏四个必要条件，而是在资源动态分配过程中，用某种方法避免系统进入不安全状态。</li>
<li>检测死锁<br>事先不采取任何限制性条件，也不必检查系统是否进入不安全状态，且<strong>允许发生死锁</strong>。但可通过系统的检查机构，及时检测出死锁的发生。</li>
<li>解除死锁<br>与检测死锁相配套的措施。当检测出死锁时，将进程从死锁状态中解脱出来。</li>
</ol>
<h4 id="银行家算法">银行家算法</h4><p>最具代表性的避免死锁的算法是Dijkstra 的银行家算法。由于该算法用于银行系统现金贷款的发放而得名。为实现该算法需先设置若干数据结构：</p>
<ol>
<li>Available 可用资源向量：<br>m 维，每个元素表示一类资源的可用数目。</li>
<li>Max 最大需求矩阵：<br>n &times; m 维，表示系统中n 个进程中的每一个进程对m 类资源最大的需求。</li>
<li>Allocation 分配矩阵：<br>n &times; m 维，表示系统中n 个进程中的每一个进程对m 类资源已分配的数量。</li>
<li>Need 需求矩阵：<br>n &times; m 维，表示系统中n 个进程中的每一个进程对m 类资源尚需的数量。</li>
</ol>
<p>算法：</p>
<p>设Request_i 是进程P_i 的请求向量，如果Request_i[j] = K,表示进程P_i 需要K 个R_j 资源。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 如果Request_i<span class="string">[j]</span> &lt;= Need<span class="string">[i]</span><span class="string">[j]</span>，转向<span class="number">2</span>；否则出错，因为所需资源大于所声明的最大数量。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 如果Request_i<span class="string">[j]</span> &lt;= Available<span class="string">[j]</span>，转向<span class="number">3</span> ；否则出错，表示没有足够资源，P_i 必须等待。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 系统尝试把资源分配给进程P_i，并修改数据：</span><br><span class="line">    Available<span class="string">[j]</span> -= Request_i<span class="string">[j]</span>;</span><br><span class="line">    Allocation<span class="string">[i]</span><span class="string">[j]</span> += Request_i<span class="string">[j]</span>;</span><br><span class="line">    Need<span class="string">[i]</span><span class="string">[j]</span> -= Request_i<span class="string">[j]</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 系统执行安全性算法，检测此次分配是否会使系统进入不安全状态。若安全，才正式分配给进程P_i；否则将试探分配作废，恢复原来的资源状态，让进程P_i 等待。</span><br></pre></td></tr></table></figure>
<p>参见：汤小丹, 梁红兵 etc. 计算机操作系统（第三版）. 西安电子科技大学出版社. 2007年5月</p>
<p>待续..</p>
<h3 id="动态库和静态库">动态库和静态库</h3><p>动态库：动态链接库（英语：Dynamic-link library，缩写为DLL）是微软公司在Windows操作系统中实现共享函数库概念的一种实作方式。</p>
<p>所谓动态链接，就是把一些经常会共用的代码（静态链接的OBJ程序库）制作成DLL档，当可执行文件调用到DLL档内的函数时，Windows操作系统才会把DLL档加载内存内，DLL档本身的结构就是可执行文件，当程序需求函数才进行链接。通过动态链接方式，内存浪费的情形将可大幅降低。</p>
<p>静态库：静态库（英语：Static library, Statically-linked library），或称静态函式库，是一个外部函式与变数的集合体。在编译期间由编译器与连结器将它整合至应用程序内，生成可独立运行的文件。</p>
<p>静态库与动态库想比：<br>优点：只需保证在开发者的计算机有正确的库文件，在以二进制发布时不需考虑在使用者的计算机上库文件是否存在及版本问题，可避免DLL地狱等问题。（DLL地狱（DLL Hell）指在Microsoft Windows系统中，因为动态链接库（DLL）的版本或兼容性的问题而造成程序无法正常运行。）</p>
<p>缺点： 生成的可执行文件体积较大。当初正是为了避免此问题，才开发了动态库技术。</p>
<h3 id="散列存储">散列存储</h3><h3 id="Android_NDK">Android NDK</h3><h3 id="&amp;的用法">&amp;的用法</h3><h3 id="完全二叉树">完全二叉树</h3><p>除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。<br>第i 层至多有2^{i - 1} 个节点；深度为k 的二叉树至多有2^{k} - 1 个节点。例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">1</span></span><br><span class="line">    /   \</span><br><span class="line">  <span class="number">2</span>       <span class="number">3</span></span><br><span class="line"> / \     /</span><br><span class="line"><span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>总结点数k： 2^{h - 1} &lt;= k &lt; 2^{h} - 1 （若等于，则为满二叉树）。<br>树高h：h = log2(k) + 1</p>
<h3 id="栈溢攻击">栈溢攻击</h3><h3 id="无向图的点和边数">无向图的点和边数</h3><p>对一个图G= (V,E)，V表示定点，E表示边。则，<br>连通图：  |E| &gt;= |V| - 1<br>强连通图：|E| &gt;= |V|<br>树：     |E| =  |V| - 1</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>几天前参加了腾讯的笔试（内退为何没电话面试呢），说实话我感觉选错岗位了。我选择的是 移动客户端开发方向，也就会涉及到Android iOS 方面的题目。对此我几乎不了解，这是我又一次自我认知的失误。而且，对于后面的主观题，代码格式和在线调试功能在最后十几分钟才有所了解，可以算得上是一次实战演戏吧。面是一些选择题涉及到的知识，并作回答：</p>]]>
    
    </summary>
    
      <category term="Tencent" scheme="http://bluestein.github.io/tags/Tencent/"/>
    
      <category term="interview" scheme="http://bluestein.github.io/tags/interview/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="JobHunting" scheme="http://bluestein.github.io/categories/Odds-Ends/JobHunting/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LPS: Longest Palindromic Substring(最长回文子串)]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-LPS/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-LPS/</id>
    <published>2016-03-29T12:04:32.000Z</published>
    <updated>2016-03-30T03:26:43.673Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>回文字符串的意思是指一个字符串，从头开始读和从尾开始读都是一样。例如，aba 是一个回文字符串，而 abc 不是。其中，单个字符也是回文字符串。</p>
<p>最长回文子串指在一个字符串中找到最长的那个回文字符串（可以假设该字符串只有一个最长字符串）。例如，</p>
<p>s = “caba”</p>
<p>最长的回文子串是 aba。</p>
<a id="more"></a>
<h2 id="Brute_force_solution,_O(n^3)">Brute force solution, O(n^3)</h2><p>暴力法就是取出所有可能的子字符串，然后验证它是否为回文字符串，最后得到最长的回文子串。</p>
<p>总共有 C(n, 2) 种子字符串（不包括单个字符的情况），因为验证每个子字符串的需要 O(n) 时间，故总共需要 O(n^3)。</p>
<h2 id="Dynamic_programming_solution,_O(n^2)">Dynamic programming solution, O(n^2)</h2><p>为了改善暴力法的时间复杂度，首先需要避免重复计算的问题。比如，ababa，当我们知道 bab 是回文字符串时，很明显就可以看出 ababa 是回文字符串，因为 bab 的左边和右边的字符是相同的，都为 a。</p>
<p>更一般的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">假设 <span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← true  当且仅当 si...sj（字符串 s 下标从 <span class="tag">i</span> 到 j 的子串）是回文字符串</span><br><span class="line">否则 <span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← false</span><br></pre></td></tr></table></figure>
<p>即有</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">P</span><span class="params">(i, j)</span></span> ← ( <span class="function"><span class="title">P</span><span class="params">(i+<span class="number">1</span>, j-<span class="number">1</span>)</span></span> &amp;&amp; Si == Sj )</span><br></pre></td></tr></table></figure>
<p>综合起来就是</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">            true                             ,i = j</span></span><br><span class="line">P[<span class="link_label">i</span>][<span class="link_reference">j</span>] = &#123; s[i] = s[j]                      ,j = i + 1</span><br><span class="line"><span class="code">            s[i] = s[j] and P(i + 1, j - 1)  ,j &gt; i + 1</span></span><br></pre></td></tr></table></figure>
<p>于是有如下 O(n^2) time, O(n^2) space 的解法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_DP</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">bool</span> *P = <span class="keyword">new</span> <span class="keyword">bool</span>[n * n];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n * n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P[i] = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// vector&lt;vector&lt;bool&gt;&gt; P(n, vector&lt;bool&gt;(n, false)); // time exceeded</span></span><br><span class="line">	<span class="keyword">int</span> max_len = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		P[i * n + i] = <span class="literal">true</span>; <span class="comment">// P[i][i]</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// P[j][i] = (s[j] == s[i] &amp;&amp; (i - j &lt; 2 || P[j + 1][i - 1]));</span></span><br><span class="line">			P[j * n + i] = (s[j] == s[i] &amp;&amp; (i - j &lt; <span class="number">2</span> || P[(j + <span class="number">1</span>) * n + i - <span class="number">1</span>]));</span><br><span class="line">			<span class="keyword">if</span> (P[j * n + i] &amp;&amp; max_len &lt; (i - j + <span class="number">1</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				max_len = i - j + <span class="number">1</span>;</span><br><span class="line">				start = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] P;</span><br><span class="line">	P = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s.substr(start, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述方法需要 O(n^2) 的空间和时间复杂度，可作如下改进，得到  O(n^2) time, O(1) space 的解法：</p>
<p>通过观察可以发现，回文字符串是中心对称的。所以一个会文字符串可以从它的中心开始展开，并且一共有 2n - 1 个这样的中心。</p>
<p>为什么有 2n - 1 个中心？是因为回文的中心可以在两个字符之间，如，abba 的中心在两个 b 之间。</p>
<p>因为从中心展开一个回文字符串需要 O(n) 时间复杂度，故总的时间复杂度为 O(n^2)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">expandCenter</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">while</span> (l &gt;= <span class="number">0</span> &amp;&amp; r &lt;= n - <span class="number">1</span> &amp;&amp; s[l] == s[r])</span><br><span class="line">	&#123;</span><br><span class="line">		l--;</span><br><span class="line">		r++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.substr(l + <span class="number">1</span>, r - l - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_DP</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">string</span>();  </span><br><span class="line">    <span class="comment">// single char itself is a palindrome</span></span><br><span class="line">	<span class="built_in">string</span> longest = s.substr(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> s1 = expandCenter(s, i, i);</span><br><span class="line">		<span class="built_in">string</span> s2 = expandCenter(s, i, i + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (s1.size() &gt; longest.size()) longest = s1;</span><br><span class="line">		<span class="keyword">if</span> (s2.size() &gt; longest.size()) longest = s2;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> longest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Manacher’s_algorithm,_O(n)">Manacher’s algorithm, O(n)</h2><h3 id="转换">转换</h3><p>首先，我们利用 # 将输入的字符串转换。如</p>
<p>s = “abaaba”  =&gt;  t = “#a#b#a#a#b#a#”</p>
<p>为了避免边界的检测，我们还可以在<strong>两边分别插入一个不同的字符作为边界哨兵</strong>（# 除外），例如 ^ 和 $</p>
<p>t = “^#a#b#a#a#b#a#$”</p>
<p>根据前面（动态规划方法2）所说，我们需要根据 t_{i} 展开得到 t_{i-d} … t_{i+d} 回文串。则很容易发现 d 就是以 t_{i} 为中心的回文串的长度。</p>
<p>我们利用 P[i] 来记录以 t_{i} 为中心的回文子串的长度，则 p[i] 中最大值就是最长回文子串的长度。</p>
<p>直观地：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t = ^ <span class="preprocessor"># a # b # a # a # b # a # $</span></span><br><span class="line">P = <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">6</span> <span class="number">1</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>通过观察 P 可以知道，最长的回文子串为 abaaba 且长度为 6。</p>
<p>并且很容易看出，s 的长度不管是奇数还是偶数的都会转换为长度为奇数的 t。</p>
<h3 id="举例">举例</h3><p>下面介绍一个更加复杂的例子，s = “babcbabcbaccba”</p>
<p><img src="/images/lps/lps_1.png" alt=""></p>
<p>假设我们计算到当前状态 i = 13 的时候，实竖线表示回文串 “abcbabcba” 的中心（C）。两个虚线 L 和 R 分别表示左右边界。此时该如何计算 P[i] 呢？</p>
<p>假设我们现在处于 i = 13，现在需要计算 p[i]（用？标明的地方）。我们先看它关于中心 C 的对称点 i’，它的下标是 i’ = 9</p>
<p><img src="/images/lps/lps_2.png" alt=""></p>
<p>两条绿色的实线分别表示以 i 和 i’ 为中心的回文串所覆盖的范围。它们满足对称的性质，故有 P[i] = p[i’] = 1。实际上，接下来的三个元素都满足该性质（即，P[ 12 ] = P[ 10 ] = 0, P[ 13 ] = P[ 9 ] = 1, P[ 14 ] = P[ 8 ] = 0）。</p>
<p><img src="/images/lps/lps_3.png" alt=""></p>
<p>现在 i = 15，它的对称点为 i’ = 7 且 P[7] = 7，那么 P[15] = P[7] = 7？</p>
<p>我们通过观察发现 P[15] = 5 != P[7] = 7，如果我们在 t_{15} 进行展开，它的回文串为 “a#b#c#b#a”，这比 7 小，为什么？</p>
<p><img src="/images/lps/lps_4.png" alt=""></p>
<p>上面标出颜色的线表示 i 和 i’ 的覆盖范围，实绿线表示符合对称性质的区域，红实线表示可能不符合，虚绿线表示重合的地方。</p>
<p>显然，绿实线表示的区域是完全符合对称的。注意到 P[i’] = 7 一直展开至 L 的左边，所以 L 左边的部分不符合对称。我们知道的是 P[i] &gt;= 5，为了找到确切的 P[i] 我们需要增加 R 来进行更多匹配。对于本例来说，因为 P[21] != P[1]，则有 P[i] = 5。</p>
<p>现在总结该算法如下：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>   P[i<span class="comment">'] <span class="xmlDocTag">&lt;= R - i,</span><br><span class="line">then P[i]   = P[i']</span><br><span class="line">else P[i]  &gt;</span>= P[i'].(这种情况需要展开 R 来找 P[i])</span></span><br></pre></td></tr></table></figure>
<p>接下来就是，何时我们才需要往右移动 C 和 R，即：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果以 <span class="built_in">i</span> 为中心的回文串展开超过 R，则更新 C = <span class="built_in">i</span>（作为新回文串的中心），同时将 R 更新为新回文串的右边界。</span><br></pre></td></tr></table></figure>
<p>每一步都只有两种情况：</p>
<ol>
<li>P[i] &lt;= R - i：则 P[i] = P[i’]，只需要一步计算。</li>
<li>从右边界 R 开始拓展，试图将回文串的中心更改为 i。</li>
</ol>
<p>拓展 R 做多只需要做 n 步，并且中心测试也只需要 n 次。所以该算法能够保证在 2*n 内做完，即 O(n)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transform S into T.</span></span><br><span class="line"><span class="comment">// For example, S = "abba", T = "^#a#b#b#a#$".</span></span><br><span class="line"><span class="comment">// ^ and $ signs are sentinels appended to each end to avoid bounds checking</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">preProcess</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"^$"</span>;</span><br><span class="line">	<span class="built_in">string</span> ans = <span class="string">"^"</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) ans += <span class="string">"#"</span> + s.substr(i, <span class="number">1</span>);</span><br><span class="line">	ans += <span class="string">"#$"</span>;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Manacher's Algorithm, O(n) time, O(n) space</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome_Manachers</span><span class="params">(<span class="built_in">string</span> s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> T = preProcess(s);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">int</span> n = T.size();</span><br><span class="line">	<span class="keyword">int</span> *P = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">	<span class="keyword">int</span> C = <span class="number">0</span>, R = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> i_mirror = <span class="number">2</span> * C - i;  <span class="comment">// equals to i' = C - (i - C)</span></span><br><span class="line">		P[i] = (R &gt; i) ? min(R - i, P[i_mirror]) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Attempt to expand palindrome centered at i</span></span><br><span class="line">		<span class="keyword">while</span> (T[i + <span class="number">1</span> + P[i]] == T[i - <span class="number">1</span> - P[i]])</span><br><span class="line">		&#123;</span><br><span class="line">			P[i]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// If palindrome centered at i expand past R,</span></span><br><span class="line">		<span class="comment">// adjust center based on expanded palindrome</span></span><br><span class="line">		<span class="keyword">if</span> (i + P[i] &gt; R)</span><br><span class="line">		&#123;</span><br><span class="line">			C = i;</span><br><span class="line">			R = i + P[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// find the maximun element in P</span></span><br><span class="line">	<span class="keyword">int</span> max_len = <span class="number">0</span>, center_index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (P[i] &gt; max_len)</span><br><span class="line">		&#123;</span><br><span class="line">			max_len = P[i];</span><br><span class="line">			center_index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] P;</span><br><span class="line">	P = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> s.substr((center_index - <span class="number">1</span> - max_len) / <span class="number">2</span>, max_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reference：</p>
<ol>
<li><a href="http://articles.leetcode.com/longest-palindromic-substring-part-i/" target="_blank" rel="external">longest palindromic substring part I</a></li>
<li><a href="http://articles.leetcode.com/longest-palindromic-substring-part-ii/" target="_blank" rel="external">longest palindromic substring part II</a></li>
</ol>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>回文字符串的意思是指一个字符串，从头开始读和从尾开始读都是一样。例如，aba 是一个回文字符串，而 abc 不是。其中，单个字符也是回文字符串。</p>
<p>最长回文子串指在一个字符串中找到最长的那个回文字符串（可以假设该字符串只有一个最长字符串）。例如，</p>
<p>s = “caba”</p>
<p>最长的回文子串是 aba。</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://bluestein.github.io/tags/DP/"/>
    
      <category term="LPS" scheme="http://bluestein.github.io/tags/LPS/"/>
    
      <category term="Palindromic" scheme="http://bluestein.github.io/tags/Palindromic/"/>
    
      <category term="Substring" scheme="http://bluestein.github.io/tags/Substring/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LCS: Longest Common Subsequence(最长公共子序列)]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-LCS/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-LCS/</id>
    <published>2016-03-25T14:30:32.000Z</published>
    <updated>2016-03-29T13:19:23.687Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="概念">概念</h2><h3 id="子序列">子序列</h3><p>设X = &lt; x1, x2,…, xm &gt;，若有1≤ i1 &lt; i2 &lt; … &lt; ik &le; m，使得 Z = &lt; z1, z2, …, zk&gt; = &lt; xi1, xi2, …, xik &gt;，则称Z 是X 的子序列， 记为Z &lt; X。<br>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Z = &lt; B,C,B,A &gt;,  则有Z &lt; X。</p>
<a id="more"></a> 
<h3 id="公共子序列">公共子序列</h3><p>设X，Y 是两个序列，且有Z &lt; X 和Z &lt; Y， 则称Z 是X 和Y 的公共子序列。 </p>
<h3 id="最长公共子序列的概念">最长公共子序列的概念</h3><p>若Z &lt; X，Z &lt; Y，且不存在比Z 更长的X 和Y 的公共子序列， 则称Z是X和Y 的最长公共子序列，记为Z &isin; LCS(X, Y)。</p>
<h3 id="最长公共子序列往往不止一个">最长公共子序列往往不止一个</h3><p>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Y = &lt; B,D,C,A,B,A &gt;.</p>
<p>则 Z = &lt; B,C,B,A &gt;,   Z’ = &lt; B,C,A,B &gt;,  Z’’ = &lt; B,D,A,B &gt; 均属于LCS(X, Y) ，即X,Y 有3 个LCS。</p>
<h2 id="算法">算法</h2><h3 id="Brute-force（暴力法）">Brute-force（暴力法）</h3><p>列出X 的所有长度不超过n （即|Y|）的子序列，从长到短逐一进行检查，看其是否为Y 的子序列，直到找到第一个最长公共子序列。由于X共有2^m 个子序列，故此方法对较大的m 没有实用价值。</p>
<h3 id="DP(动态规划)">DP(动态规划)</h3><p>记Xi = &lt; x1，…，xi &gt;即X序列的前i个字符 (1 &le; i &le; m)（前缀） Yj = &lt; y1，…，yj &gt;即Y 序列的前j 个字符 (1≤ j≤ n)（前缀） 假定Z = &lt; z1，…，zk &gt; &isin; LCS(X, Y)。 </p>
<ol>
<li>若xm = yn（最后一个字符相同），则不难用反证法证明：<br>该字符必是X 与Y 的任一最长公共子序列Z（设长度为k）的 最后一个字符，即有zk = xm = yn 且显然有 Zk-1 &isin; LCS(Xm-1 , Yn-1) 即Z 的前缀Zk-1 是Xm-1 与Yn-1 的最长公共子序列。 </li>
<li>若xm &ne; yn，则亦不难用反证法证明：<br>要么Z &isin; LCS(Xm-1, Y)，要么Z &isin; LCS(X, Yn-1)。 由于zk &ne; xm 与zk &ne; yn 其中至少有一个必成立，因此： 若zk &ne; xm则有Z &isin; LCS(Xm-1 , Y)， 若zk &ne; yn 则有Z &isin; LCS(X, Yn-1)。</li>
</ol>
<p><strong>所以</strong></p>
<ol>
<li>若xm = yn，则问题化归成求Xm-1 与Yn-1 的LCS。<br>（LCS(X, Y)的长度等于LCS(Xm-1, Yn-1) 的长度加1） </li>
<li>若xm &ne; yn 则问题化归成求Xm-1 与Y 的LCS 及X 与Yn-1 的LCS<br>LCS(X , Y)的长度为：max{LCS(Xm-1, Y)的长度, LCS(X, Yn-1)的长度} </li>
</ol>
<p>引进一个二维数组C，用C[i,j]记录Xi与Yj的LCS的长度   如果我们是自底向上进行递推计算，那么在计算C[i,j]之前， C[i-1,j-1], C[i-1,j]与C[i,j-1]均已计算出来。此时我们 根据X[i]=Y[j]还是X[i]Y[j]，就可以计算出C[i,j]： </p>
<ol>
<li>若X[i] = Y[j]，则执行C[i,j]←C[i-1,j-1]+1；</li>
<li>若X[i] &ne; Y[j]，则根据： 若C[i-1,j]≥C[i,j-1]则C[i,j]←C[i-1,j]；</li>
<li>否则C[i,j]←C[i,j-1]。即有</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">          <span class="number">0</span>;                         若i = <span class="number">0</span> 或j = <span class="number">0</span>；</span><br><span class="line">C[i,j] =&#123; C[i-<span class="number">1</span>, j-<span class="number">1</span>] + <span class="number">1</span>;           若i, j &gt; <span class="number">0</span> 且 xi = yj；</span><br><span class="line">          max&#123;C[i-<span class="number">1</span>, j], C[i, j-<span class="number">1</span>]&#125;  若i, j &gt; <span class="number">0</span> 且 xi != yj；</span><br></pre></td></tr></table></figure>
<p>如下图</p>
<p><img src="/images/LCS.png" alt=""></p>
<p>为了构造出LCS，使用一个m &times; n 的二维数组b， b[i,j] 记录C[i,j] 是通过哪一个子问题的值求得的, 以决定搜索的方向： </p>
<ol>
<li>若X[i] = Y[j]，，则b[i,j] 中记入“↖”；</li>
<li>若C[i-1,j] ≥ C[i,j-1]，则b[i,j] 中记入“↑”； </li>
<li>若C[i-1,j] &lt; C[i,j-1]，则b[i,j] 中记入“←”；</li>
</ol>
<p>算法伪代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">LCS(X,Y,m,n,C) &#123;</span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">0</span> to m <span class="keyword">do</span> C[i,<span class="number">0</span>]←<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j=<span class="number">1</span> to n <span class="keyword">do</span> C[<span class="number">0</span>,j]←<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span> to m <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> j=<span class="number">1</span> to n <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> x[i]=y[j] &#123;</span><br><span class="line">                C[i,j]←C[i-<span class="number">1</span>,j-<span class="number">1</span>]+<span class="number">1</span>；</span><br><span class="line">                b[i,j]←“↖” ；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> C[i-<span class="number">1</span>,j]≥C[i,j-<span class="number">1</span>] &#123;</span><br><span class="line">                C[i,j]←C[i-<span class="number">1</span>,j]；</span><br><span class="line">                b[i,j]←“↑” ；</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                C[i,j]←C[i,j-<span class="number">1</span>]；</span><br><span class="line">                b[i,j]←“←”;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<strong>一个</strong>LCS(X,Y) 的递归算法</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">LCS_Output</span>(<span class="keyword">b,X,i,j) </span>&#123;</span><br><span class="line">    <span class="preprocessor">if</span> i<span class="number">=0</span> or j<span class="number">=0</span> </span><br><span class="line">        return<span class="comment">; </span></span><br><span class="line">    <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“↖” </span>&#123;             <span class="comment">/*X[i]=Y[j]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i-1,j-1)；</span><br><span class="line"></span>        输出 X[i]；</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="preprocessor">else</span> <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“↑” </span>          <span class="comment">/*C[i-1,j]≥C[i,j-1]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i-1,j) </span></span><br><span class="line">    <span class="preprocessor">else</span> <span class="preprocessor">if</span> <span class="keyword">b[i,j]=“←” </span>          <span class="comment">/*C[i-1,j]&lt;C[i,j-1]*/</span></span><br><span class="line">        LCS_Output(<span class="keyword">b,X,i,j-1)</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>对上述例子调用 <strong>LCS_Output(b,X,7,6)</strong>。</p>
<p>下面是输出全部LCS 的C++ 代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> LCS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">LCS_L</span><span class="params">(<span class="built_in">string</span> x, <span class="built_in">string</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; C)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> m = x.size(), n = y.size();</span><br><span class="line">		C = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (x[i - <span class="number">1</span>] == y[j - <span class="number">1</span>]) C[i][j] = C[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  <span class="comment">// 相同</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (C[i - <span class="number">1</span>][j] &gt;= C[i][j - <span class="number">1</span>]) C[i][j] = C[i - <span class="number">1</span>][j];  <span class="comment">// 不相同，取较大的一个</span></span><br><span class="line">				<span class="keyword">else</span> C[i][j] = C[i][j - <span class="number">1</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">LCS_output</span><span class="params">(<span class="built_in">string</span> x, <span class="built_in">string</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; C, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="built_in">string</span> lcs)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x[i - <span class="number">1</span>] == y[j - <span class="number">1</span>])  <span class="comment">// 由右上角产生</span></span><br><span class="line">			&#123;</span><br><span class="line">				lcs.push_back(x[i - <span class="number">1</span>]);</span><br><span class="line">				--i;</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>      (C[i - <span class="number">1</span>][j] &gt; C[i][j - <span class="number">1</span>]) --i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (C[i - <span class="number">1</span>][j] &lt; C[i][j - <span class="number">1</span>]) --j;</span><br><span class="line">				<span class="keyword">else</span>  <span class="comment">// equal</span></span><br><span class="line">				&#123;</span><br><span class="line">					LCS_output(x, y, C, i - <span class="number">1</span>, j, lcs);</span><br><span class="line">					LCS_output(x, y, C, i, j - <span class="number">1</span>, lcs);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		reverse(lcs.begin(), lcs.end());</span><br><span class="line">		ans.push_back(lcs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	LCS lcs;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; C;</span><br><span class="line">	<span class="built_in">string</span> x = <span class="string">"ABCBDAB"</span>, y = <span class="string">"BDCABA"</span>, str;</span><br><span class="line">	lcs.LCS_L(x, y, C);</span><br><span class="line">	lcs.LCS_output(x, y, C, x.size(), y.size(), str);;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> s : lcs.ans)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BCBA</span><br><span class="line"></span><span class="keyword">BCAB</span><br><span class="line"></span><span class="keyword">BDAB</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="概念">概念</h2><h3 id="子序列">子序列</h3><p>设X = &lt; x1, x2,…, xm &gt;，若有1≤ i1 &lt; i2 &lt; … &lt; ik &le; m，使得 Z = &lt; z1, z2, …, zk&gt; = &lt; xi1, xi2, …, xik &gt;，则称Z 是X 的子序列， 记为Z &lt; X。<br>e.g. X = &lt; A,B,C,B,D,A,B &gt;,  Z = &lt; B,C,B,A &gt;,  则有Z &lt; X。</p>]]>
    
    </summary>
    
      <category term="DP" scheme="http://bluestein.github.io/tags/DP/"/>
    
      <category term="LCS" scheme="http://bluestein.github.io/tags/LCS/"/>
    
      <category term="Subsequence" scheme="http://bluestein.github.io/tags/Subsequence/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用位操作符实现四则运算]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-add-substract-multiply-divide/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-add-substract-multiply-divide/</id>
    <published>2016-03-21T10:10:32.000Z</published>
    <updated>2016-03-21T11:07:20.997Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>如何使用位操作分别实现整数的加减乘除四种运算呢？</p>
<p>常用到的位操作：</p>
<p>1, 等式： <strong>-n = ~(n - 1) = ~n + 1</strong></p>
<p>2, 获取整数n的二进制中最后一个1： <strong>n &amp; (-n) 或者 n &amp; ~(n - 1)</strong></p>
<blockquote>
<p>如 n = 010100，则 -n = 101100，n &amp; (-n) = 000100</p>
</blockquote>
<p>3, 去掉整数n的二进制中最后一个1： <strong>n &amp; (n-1)</strong></p>
<blockquote>
<p>如：n = 010100，n-1 = 010011，n &amp; (n-1) = 010000</p>
</blockquote>
<a id="more"></a> 
<h2 id="加法">加法</h2><p>可以利用“异或”操作实现整数加法运算：<br>对应位数的“异或操作”可得到该位的数值，对应位的“与操作”可得到该位产生的高位进位，如：a =  010010，b = 100111，计算步骤如下：</p>
<p>第一轮：a ^ b= 110101，(a &amp; b) &lt;&lt; 1 = 000100， 由于进位（000100）大于0，则进入下一轮计算，a = 110101，b = 000100，a ^ b = 110001，(a &amp; b) &lt;&lt; 1= 001000，由于进位大于0，则进入下一轮计算：a = 110001，b = 001000，a ^ b = 111001，(a &amp; b) &lt;&lt; 1 = 0，进位为0，终止。计算结果为：111001。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Maths::add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!b) <span class="keyword">return</span> a;  <span class="comment">// 没有进位</span></span><br><span class="line">	<span class="keyword">int</span> sum = a ^ b;  <span class="comment">// 不计进位的和</span></span><br><span class="line">	<span class="keyword">int</span> carry = a &amp; b;  <span class="comment">// 进位</span></span><br><span class="line">	carry &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(sum, carry)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非递归</strong></p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">sum</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">sum</span> = a ^ b;  <span class="comment">// 不带进位</span></span><br><span class="line">		b = ((a &amp; b) &lt;&lt; <span class="number">1</span>);  <span class="comment">// 进位</span></span><br><span class="line">		a = <span class="keyword">sum</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">sum</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="减法">减法</h2><p>减法可很容易地转化为加法：a - b = a + (-b) = a + (~b + 1 )</p>
<p>即，取减数的补码再相加 1</p>
<ol>
<li>负数的补码：原码取反加1</li>
<li>正数的补码：原码</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> complement = add(~b, <span class="number">1</span>); </span><br><span class="line">	<span class="function"><span class="keyword">return</span> <span class="title">add</span><span class="params">(a, complement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法">乘法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	<span class="number">111</span>		(<span class="number">7</span>)</span><br><span class="line">  * <span class="number">101</span>		(<span class="number">5</span>)</span><br><span class="line">---------------</span><br><span class="line">	<span class="number">111</span>		(<span class="number">00111</span>) <span class="number">7</span> 向左移动 <span class="number">0</span> 位：<span class="number">111</span></span><br><span class="line">   <span class="number">000</span>		(<span class="number">00000</span>) <span class="number">7</span> 向左移动 <span class="number">1</span> 位：<span class="number">1110</span></span><br><span class="line">  <span class="number">111</span>		(<span class="number">11100</span>) <span class="number">7</span> 向左移动 <span class="number">2</span> 位：<span class="number">11100</span></span><br><span class="line">---------------</span><br><span class="line">  <span class="number">100011</span>	(<span class="number">35</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>b 的第0 位，为1，则结果加上 111，因为 1 * （111） = 111</li>
<li>b 的第2 位，为0，则结果加上 0000，因为 0 * (1110) = 0000</li>
<li>b 的第3 位，为1，则结果加上 11100，因为 1 * (11100) = 11100</li>
</ol>
<p>可以看到，<strong>b 每向右移一位，a 就要向左移动一位。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> isNegtive = (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>);  <span class="comment">// 决定结果的正负</span></span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = -b;  <span class="comment">// 负数转化为正数计算</span></span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = -a;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = add(ans, a); <span class="comment">// 从右至左取 b 的二进制中的 1 （即右移）</span></span><br><span class="line">		a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isNegtive ? -ans : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="除法">除法</h2><p>除法就是由乘法的过程逆推，依次减掉（如果a 够减）b^(2^31), b^(2^30), …, b^8, b^4, b^2, b^1。</p>
<p><strong>b 减掉相应数量，则结果需加上相应的数量。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">bool</span> isNegtive = (a &lt; <span class="number">0</span>) ^ (b &lt; <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (b &lt; <span class="number">0</span>) b = -b;</span><br><span class="line">	<span class="keyword">if</span> (a &lt; <span class="number">0</span>) a = -a;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((a &gt;&gt; i) &gt;= b)</span><br><span class="line">		&#123;</span><br><span class="line">			a = substract(a, (b &lt;&lt; i));</span><br><span class="line">			ans = add(ans, (<span class="number">1</span> &lt;&lt; i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> isNegtive ? -ans : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>如何使用位操作分别实现整数的加减乘除四种运算呢？</p>
<p>常用到的位操作：</p>
<p>1, 等式： <strong>-n = ~(n - 1) = ~n + 1</strong></p>
<p>2, 获取整数n的二进制中最后一个1： <strong>n &amp; (-n) 或者 n &amp; ~(n - 1)</strong></p>
<blockquote>
<p>如 n = 010100，则 -n = 101100，n &amp; (-n) = 000100</p>
</blockquote>
<p>3, 去掉整数n的二进制中最后一个1： <strong>n &amp; (n-1)</strong></p>
<blockquote>
<p>如：n = 010100，n-1 = 010011，n &amp; (n-1) = 010000</p>
</blockquote>]]>
    
    </summary>
    
      <category term="4-Arithmetic-Operations" scheme="http://bluestein.github.io/tags/4-Arithmetic-Operations/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="bit-manipulate" scheme="http://bluestein.github.io/tags/bit-manipulate/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深拷贝带随机指针的链表]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-copy-random-list/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-copy-random-list/</id>
    <published>2016-03-20T13:48:32.000Z</published>
    <updated>2016-03-20T13:57:37.743Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。返回一个深拷贝的链表。</p>
<ol>
<li>浅拷贝(影子克隆):只复制对象的基本类型，对象类型，仍属于原来的引用</li>
<li>深拷贝(深度克隆):不仅复制对象的基本类型，同时也复制原对象中的对象，就是说完全是新产生的对象</li>
</ol>
<a id="more"></a> 
<p>介绍两种方法，分别需要： O(n) time, O(n) space 和 O(n) time, O(1) space</p>
<h2 id="Solution1">Solution1</h2><p>三遍遍历。 O(n) time, O(n) space</p>
<p>分成3步：</p>
<ol>
<li>复制节点，如A-B-C =&gt; A-A’-B-B’-C-C’</li>
<li>依次遍历节点A,B,C，将A’B’C’这些节点的随机指针与其一致</li>
<li>分离成 A-B-C 和 A’-B’-C’，A’-B’-C’便是所求链表</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">RandomListNode* copyRandomList_nn(RandomListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line">	RandomListNode *cur = head;</span><br><span class="line">	<span class="comment">// 创建拷贝</span></span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		RandomListNode *node = <span class="literal">new</span> RandomListNode(cur<span class="subst">-&gt;</span>label);</span><br><span class="line">		node<span class="subst">-&gt;</span>next = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">		cur<span class="subst">-&gt;</span>next = node;</span><br><span class="line">		cur = node<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 调整random 指针</span></span><br><span class="line">	cur = head;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		RandomListNode *node = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">		<span class="comment">// 指向自身</span></span><br><span class="line">		<span class="keyword">if</span> (cur<span class="subst">-&gt;</span>random == cur) node<span class="subst">-&gt;</span>random = node;</span><br><span class="line">		<span class="comment">// 指向非空且不指向自身</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (cur<span class="subst">-&gt;</span>random) node<span class="subst">-&gt;</span>random = cur<span class="subst">-&gt;</span>random<span class="subst">-&gt;</span>next;</span><br><span class="line">		<span class="comment">// 指向空时，无需操作，因为默认为空</span></span><br><span class="line">		cur = cur<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分离</span></span><br><span class="line">	RandomListNode *copy = cur = head<span class="subst">-&gt;</span>next;</span><br><span class="line">	<span class="keyword">while</span> (cur<span class="subst">-&gt;</span>next) &#123;</span><br><span class="line">		cur<span class="subst">-&gt;</span>next = cur<span class="subst">-&gt;</span>next<span class="subst">-&gt;</span>next;</span><br><span class="line">		cur = cur<span class="subst">-&gt;</span>next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Solution2">Solution2</h2><p>将各节点依次往后移一位，新建最后一位节点。 O(n) time, O(1) space</p>
<p>分成两步：</p>
<ol>
<li>移动：1-&gt;2-&gt;3-&gt;null =&gt; 1-&gt;1-&gt;2-&gt;3-&gt;null</li>
<li>调整指针关系</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line">RandomListNode* copyRandomList_n1(RandomListNode* head)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == nullptr) <span class="keyword">return</span> nullptr;</span><br><span class="line">	RandomListNode *prev = head, *cur = head-&gt;next;</span><br><span class="line">	RandomListNode *copy;</span><br><span class="line">	<span class="keyword">int</span> prev_label = head-&gt;label, cur_label;</span><br><span class="line">	<span class="comment">// 移动 label</span></span><br><span class="line">	<span class="comment">// 1-2-3-null =&gt; 1-1-2-3-null</span></span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		<span class="comment">// label 往后移动一位</span></span><br><span class="line">		cur_label = cur-&gt;label;</span><br><span class="line">		cur-&gt;label = prev_label;</span><br><span class="line">		prev_label = cur_label;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 往后移动指针</span></span><br><span class="line">		prev = cur;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最后一个节点，需要新建，并连接到原链表</span></span><br><span class="line">	RandomListNode *last = <span class="keyword">new</span> RandomListNode(prev_label);</span><br><span class="line">	prev-&gt;next = last;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调整 random 指针</span></span><br><span class="line">	prev = head, cur = head-&gt;next;</span><br><span class="line">	RandomListNode *cur_random = head-&gt;random, *prev_random;</span><br><span class="line">	<span class="keyword">while</span> (cur) &#123;</span><br><span class="line">		prev_random = cur_random; <span class="comment">// 获取prev 的random 指针</span></span><br><span class="line">		cur_random = cur-&gt;random; <span class="comment">// 记录当前random 指针</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 指向自身</span></span><br><span class="line">		<span class="keyword">if</span> (prev_random == prev) cur-&gt;random = cur;</span><br><span class="line">		<span class="comment">// 指向非空且不指向自身</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (prev_random) cur-&gt;random = prev_random-&gt;next;</span><br><span class="line">		<span class="comment">// 指向空</span></span><br><span class="line">		<span class="keyword">else</span> cur-&gt;random = nullptr;</span><br><span class="line"></span><br><span class="line">		prev = cur;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="描述">描述</h2><p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。返回一个深拷贝的链表。</p>
<ol>
<li>浅拷贝(影子克隆):只复制对象的基本类型，对象类型，仍属于原来的引用</li>
<li>深拷贝(深度克隆):不仅复制对象的基本类型，同时也复制原对象中的对象，就是说完全是新产生的对象</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="deep copy" scheme="http://bluestein.github.io/tags/deep-copy/"/>
    
      <category term="linked list" scheme="http://bluestein.github.io/tags/linked-list/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[二叉树的后序遍历]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-postorder-traversal/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-postorder-traversal/</id>
    <published>2016-03-19T12:09:32.000Z</published>
    <updated>2016-03-19T13:45:48.636Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>
<a id="more"></a>
<p>比如，有如下二叉树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>则我们可以知道</p>
<ol>
<li>先序：preorder = [1,2,4,3,5]</li>
<li>中序：inorder = [2,4,1,3,5]</li>
<li>后序：postorder = [4,2,5,3,1]</li>
</ol>
<p>下面介绍的是后序遍历算法，分别使用递归和非递归方法。</p>
<h2 id="递归方法">递归方法</h2><p>算法首先遍历左子树，然后遍历右子树，最后是根节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	postorder(root, ans);</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">	postorder(root-&gt;left, ans);  <span class="comment">// 左子树</span></span><br><span class="line">	postorder(root-&gt;right, ans);  <span class="comment">// 右子树</span></span><br><span class="line">	ans.push_back(root-&gt;val);  <span class="comment">// 根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非递归方法">非递归方法</h2><p>可以用栈或 Morris 遍历</p>
<h3 id="1-_栈">1. 栈</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="comment">// 栈：时间复杂度 O(n)， 空间复杂度 O(n)</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Trees::postorderTraversal(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">const</span> TreeNode*&gt; s;</span><br><span class="line">	<span class="comment">// *p 正在访问的点，*q 刚刚访问的点</span></span><br><span class="line">	<span class="keyword">const</span> TreeNode *p, *q;</span><br><span class="line">	p = root;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (p) &#123;  <span class="comment">// 往左走</span></span><br><span class="line">			s.push(p);</span><br><span class="line">			p = p-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		q = <span class="literal">nullptr</span>;  <span class="comment">// 未被访问过</span></span><br><span class="line">		<span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">			p = s.top();</span><br><span class="line">			s.pop();</span><br><span class="line">			<span class="comment">// 右孩子不存在，或已被访问</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;right == q) &#123;</span><br><span class="line">				ans.push_back(p-&gt;val);</span><br><span class="line">				q = p;  <span class="comment">// 保存刚访问的节点</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//当前节点不能访问，再次进栈</span></span><br><span class="line">				s.push(p);</span><br><span class="line">				<span class="comment">// 先处理右子树</span></span><br><span class="line">				p = p-&gt;right;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (!s.empty());</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-_Morris">2. Morris</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++</span></span><br><span class="line"><span class="comment">// Morris：时间复杂度 O(n)， 空间复杂度 O(1)</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; Trees::postorderTraversal_Morris(TreeNode* root)</span><br><span class="line">&#123;</span><br><span class="line">	vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">	TreeNode fake(-<span class="number">1</span>);</span><br><span class="line">	TreeNode *cur, *prev = nullptr;</span><br><span class="line">	function&lt; void(<span class="keyword">const</span> TreeNode*) &gt; visit = [&amp;ans](<span class="keyword">const</span> TreeNode *node) &#123;</span><br><span class="line">		ans.push_back(node-&gt;val);</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	fake.left = root;</span><br><span class="line">	cur = &amp;fake;</span><br><span class="line">	<span class="keyword">while</span> (cur != nullptr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;left == nullptr)</span><br><span class="line">		&#123;</span><br><span class="line">			prev = cur; <span class="comment">// 必须要有</span></span><br><span class="line">			cur = cur-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			TreeNode *node = cur-&gt;left;</span><br><span class="line">			<span class="keyword">while</span> (node-&gt;right != nullptr &amp;&amp; node-&gt;right != cur)</span><br><span class="line">			&#123;</span><br><span class="line">				node = node-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 还没线索化，则建立线索 */</span></span><br><span class="line">			<span class="keyword">if</span> (node-&gt;right == nullptr)</span><br><span class="line">			&#123;</span><br><span class="line">				node-&gt;right = cur;</span><br><span class="line">				prev = cur;  <span class="comment">// 必须要有</span></span><br><span class="line">				cur = cur-&gt;left;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* 已经线索化，则访问节点，并删除线索 */</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit_reverse(cur-&gt;left, prev, visit);</span><br><span class="line">				prev-&gt;right = nullptr;</span><br><span class="line">				prev = cur;  <span class="comment">// 必须要有</span></span><br><span class="line">				cur = cur-&gt;right;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 逆转路径</span></span><br><span class="line">void Trees::reverse(TreeNode *from, TreeNode *to)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode *x = from, *y = from-&gt;right, *z;</span><br><span class="line">	<span class="keyword">if</span> (from == to) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">while</span> (x != to)</span><br><span class="line">	&#123;</span><br><span class="line">		z = y-&gt;right;</span><br><span class="line">		y-&gt;right = x;</span><br><span class="line">		x = y;</span><br><span class="line">		y = z;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问逆转后的路径上的所有结点</span></span><br><span class="line">void Trees::visit_reverse(TreeNode *from, TreeNode *to,</span><br><span class="line">	function&lt; void(<span class="keyword">const</span> TreeNode*) &gt;&amp; visit)</span><br><span class="line">&#123;</span><br><span class="line">	TreeNode *p = to;</span><br><span class="line">	reverse(from, to);</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">		<span class="keyword">if</span> (p == from) <span class="keyword">break</span>;</span><br><span class="line">		p = p-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	reverse(to, from);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较复杂，可以参考 <a href="http://www.cnblogs.com/AnnieKim/archive/2013/06/15/MorrisTraversal.html" target="_blank" rel="external">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）- cnblogs</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="binary tree" scheme="http://bluestein.github.io/tags/binary-tree/"/>
    
      <category term="postorder traversal" scheme="http://bluestein.github.io/tags/postorder-traversal/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[按奇偶分割数组]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-partition-array/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-partition-array/</id>
    <published>2016-03-18T14:00:05.000Z</published>
    <updated>2016-03-18T14:47:11.060Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="问题描述">问题描述</h2><p>给定一个数组，比如 array = { 6, 2, 3, 1, 1, 3, 5, 8}，对该数组进行整理，使得所有奇数都在前面，所有的偶数都在后面。且满足下列条件之一：</p>
<ol>
<li>保证所有奇数的相对顺序不改变，所有偶数的相对顺序不改变</li>
<li>不要求相对顺序不变</li>
</ol>
<a id="more"></a>
<p>愚钝，暂时只想到下面这些：</p>
<h2 id="1-_保持相对位置">1. 保持相对位置</h2><h3 id="a-_利用冒泡思想">a. 利用冒泡思想</h3><p>复杂度： T(n) = O(n^2), S(n) = O(1)<br>描述：从左至右扫描，遇到奇数则将其往左移动，直到遇到最近的奇数停止</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_bubble</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; nums.size()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) &#123;  <span class="comment">// odd</span></span><br><span class="line">			<span class="keyword">int</span> k = i;</span><br><span class="line">			<span class="keyword">while</span> (k &gt; j) &#123;  <span class="comment">// bubble: swap with the previous one</span></span><br><span class="line">				<span class="keyword">int</span> tmp = nums[k];</span><br><span class="line">				nums[k] = nums[k - <span class="number">1</span>];</span><br><span class="line">				nums[k - <span class="number">1</span>] = tmp;</span><br><span class="line">				--k;</span><br><span class="line">			&#125;</span><br><span class="line">			j += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135628</span></span><br></pre></td></tr></table></figure>
<h3 id="b-_使用额外数组">b. 使用额外数组</h3><p>复杂度： T(n) = O(n), S(n) = O(n)<br>描述： </p>
<ol>
<li>新建一个数组，扫描原数组中的奇数并保存到新数组</li>
<li>再次扫描原数组，保存扫描到的所有偶数至新数组</li>
<li>然后把新数组的元素拷贝到原数组即可</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Arrays::partitionArray_copy(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 1. put odd number to copy</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) copy.push_back(nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 2. put even number to copy</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(nums[i] % <span class="number">2</span>)) copy.push_back(nums[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)  <span class="comment">// 3. copy to nums</span></span><br><span class="line">	&#123;</span><br><span class="line">		nums[i] = copy[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135628</span></span><br></pre></td></tr></table></figure>
<h2 id="2-_不保持相对位置">2. 不保持相对位置</h2><h3 id="a-_借助快速排序分区的方法">a. 借助快速排序分区的方法</h3><p>复杂度： T(n) = O(n), S(n) = O(1)<br>描述： </p>
<ol>
<li>使用两个指针i, j，从数组左边（右边一样）同时开始扫描</li>
<li>指针i 所指的元素是奇数时，则与j 所指元素对换</li>
<li>重复过程2，直到i 到达末尾</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_same</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) &#123; <span class="comment">// odd</span></span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">			++j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">31135268</span></span><br></pre></td></tr></table></figure>
<h3 id="b-_两指针相撞">b. 两指针相撞</h3><p>复杂度： T(n) = O(n), S(n) = O(1)<br>描述：</p>
<ol>
<li>使用两个指针，i 指向头, j 指向尾，分别从数组左右边两边同时开始扫描</li>
<li>i 寻找第一个偶数，j 寻找第一个奇数，然后将它们所指元素对换</li>
<li>重复过程2 直至i &lt; j</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">partitionArray_both</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, j = nums.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(nums[i] % <span class="number">2</span>) &amp;&amp; (nums[j] % <span class="number">2</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			swap(nums[i], nums[j]);</span><br><span class="line">			i++, j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (nums[i] % <span class="number">2</span>) i++;  <span class="comment">// skip odd</span></span><br><span class="line">		<span class="keyword">if</span> (!(nums[j] % <span class="number">2</span>)) j--;  <span class="comment">// skip even</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以array = { 6, 2, 3, 1, 1, 3, 5, 8} 为例，调整后array 的结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">53311268</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="问题描述">问题描述</h2><p>给定一个数组，比如 array = { 6, 2, 3, 1, 1, 3, 5, 8}，对该数组进行整理，使得所有奇数都在前面，所有的偶数都在后面。且满足下列条件之一：</p>
<ol>
<li>保证所有奇数的相对顺序不改变，所有偶数的相对顺序不改变</li>
<li>不要求相对顺序不变</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="array" scheme="http://bluestein.github.io/tags/array/"/>
    
      <category term="partition" scheme="http://bluestein.github.io/tags/partition/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[由前序遍历和中序遍历树构造二叉树]]></title>
    <link href="http://bluestein.github.io/2016/03/algorithm-preorder-inorder/"/>
    <id>http://bluestein.github.io/2016/03/algorithm-preorder-inorder/</id>
    <published>2016-03-17T14:23:05.000Z</published>
    <updated>2016-03-19T13:45:46.083Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>
<a id="more"></a>
<p>比如，有如下二叉树：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line"> \   \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>则我们可以知道</p>
<ol>
<li>先序：preorder = [1,2,4,3,5]</li>
<li>中序：inorder = [2,4,1,3,5]</li>
<li>后序：postorder = [4,2,5,3,1]</li>
</ol>
<h2 id="算法">算法</h2><p>算法首先利用先序遍历序列构造“跟”节点，然后依据中序遍历序列来构造左右子树。就拿上面二叉树举例，算法流程如下：</p>
<ol>
<li>根节点（root）是先序序列中的第一个节点preorder[0] = 1；</li>
<li>在inorder 中找到值等于1 的点，然后将inorder 分为左右两块，即[2,4] 和[3,5]</li>
<li>利用两块[2,4] 和[3,5] 分别用来构造根节点1 的左右子树。</li>
<li>递归产生各子树</li>
</ol>
<p>C++代码如下（仅供参考）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Definition of TreeNode:</span><br><span class="line"> * class TreeNode &#123;</span><br><span class="line"> * public:</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left, *right;</span><br><span class="line"> *     TreeNode(int val) &#123;</span><br><span class="line"> *         this-&gt;val = val;</span><br><span class="line"> *         this-&gt;left = this-&gt;right = NULL;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Solution &#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *@param preorder : A list of integers that preorder traversal of a tree</span><br><span class="line">     *@param inorder : A list of integers that inorder traversal of a tree</span><br><span class="line">     *@return : Root of a tree</span><br><span class="line">     */</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_pre = preorder.size(), len_in = inorder.size();</span><br><span class="line">        <span class="keyword">if</span> (!len_in || !len_pre) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> in = <span class="number">0</span>;  <span class="comment">// in: 中序遍历根节点所在位置</span></span><br><span class="line">        <span class="keyword">while</span> (preorder[<span class="number">0</span>] != inorder[in]) in++;  <span class="comment">// 在中序遍历找到根节点位置</span></span><br><span class="line">        preorder.erase(preorder.begin()); <span class="comment">// 去除preorder的第一个元素</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it_in = inorder.begin();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_left, inorder_right;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="number">0</span>)  <span class="comment">// 有左子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            inorder_left = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(it_in, it_in + in);  <span class="comment">// 左侧子树的中序遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (in != len_in -<span class="number">1</span>)  <span class="comment">// 有右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            inorder_right = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(it_in + in + <span class="number">1</span>, inorder.end());  <span class="comment">// 右侧子树的中序遍历</span></span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = buildTree(preorder, inorder_left);  <span class="comment">// 构造左子树</span></span><br><span class="line">        root-&gt;right = buildTree(preorder, inorder_right);  <span class="comment">// 构造右子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="二叉树的遍历">二叉树的遍历</h2><p>二叉树的先序、中序、后序说的都是根相对的位置来说的。</p>
<ol>
<li>先序（先根）：根-左-右</li>
<li>中序（中根）：左-根-右</li>
<li>后序（后根）：左-右-根</li>
</ol>]]>
    
    </summary>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="binary tree" scheme="http://bluestein.github.io/tags/binary-tree/"/>
    
      <category term="inorder" scheme="http://bluestein.github.io/tags/inorder/"/>
    
      <category term="preorder" scheme="http://bluestein.github.io/tags/preorder/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[MapReduce]]></title>
    <link href="http://bluestein.github.io/2016/03/ML-map-reduce/"/>
    <id>http://bluestein.github.io/2016/03/ML-map-reduce/</id>
    <published>2016-03-11T14:15:10.000Z</published>
    <updated>2016-03-11T14:19:39.987Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="map函数和reduce函数">map函数和reduce函数</h3><p>map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p>
<ol>
<li>map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</li>
<li>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</li>
</ol>
<a id="more"></a>
<p>使用词频统计来做例子：拆分文件集，copy程序，整合结果。下面是MapReduce函数的核心代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">map(String key, String value):</span><br><span class="line">	// key: document name</span><br><span class="line">	// value: document contents</span><br><span class="line">	<span class="keyword">for</span> each word w <span class="keyword">in</span> value:</span><br><span class="line">		EmitIntermediate(w, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">reduce(String key, Iterator values):</span><br><span class="line">	// key: a word</span><br><span class="line">	// values: a list of counts</span><br><span class="line">	int result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> each v <span class="keyword">in</span> values:</span><br><span class="line">		result += ParseInt(v);</span><br><span class="line">		Emit(AsString(result));</span><br></pre></td></tr></table></figure>
<p>在统计词频的例子里，map 函数接受的键是文件名，值是文件的内容，map 逐个遍历单词，每遇到一个单词w，就产生一个中间键值对<w, "1"="">，这表示单词w 咱又找到了一个；MapReduce 将键相同（都是单词w）的键值对传给reduce 函数，这样reduce 函数接受的键就是单词w，值是一串”1”（最基本的实现是这样，但可以优化），个数等于键为w的键值对的个数，然后将这些“1”累加就得到单词w的出现次数。最后这些单词的出现次数会被写到用户定义的位置，存储在底层的分布式存储系统（GFS 或HDFS）。</w,></p>
<h3 id="MapReduce工作">MapReduce工作</h3><p><img src="/images/mapReduce.jpg" alt=""></p>
<p>上图是论文里给出的流程图。一切都是从最上方的user program 开始的，user program 链接了MapReduce 库，实现了最基本的Map 函数和Reduce 函数。图中执行的顺序都用数字标记了。</p>
<ol>
<li>MapReduce 库先把user program 的输入文件划分为M份（M为用户定义），每一份通常有16MB 到64MB，如图左方所示分成了split0~4；然后使用fork 将用户进程拷贝到集群内其它机器上。</li>
<li>user program 的副本中有一个称为master，其余称为worker，master 是负责调度的，为空闲worker 分配作业（Map 作业或者Reduce 作业），worker 的数量也是可以由用户指定的。</li>
<li>被分配了Map 作业的worker，开始读取对应分片的输入数据，Map 作业数量是由M 决定的，和split一一对应；Map 作业从输入数据中抽取出键值对，每一个键值对都作为参数传递给map 函数，map 函数产生的中间键值对被缓存在内存中。</li>
<li>缓存的中间键值对会被定期写入本地磁盘，而且被分为R 个区，R 的大小是由用户定义的，将来每个区会对应一个Reduce 作业；这些中间键值对的位置会被通报给master，master 负责将信息转发给Reduce worker。</li>
<li>master 通知分配了Reduce 作业的worker 它负责的分区在什么位置（不止一个地方，每个Map 作业产生的中间键值对都可能映射到所有R 个不同分区），当Reduce worker 把所有它负责的中间键值对都读过来后，先对它们进行排序，使得相同键的键值对聚集在一起。因为不同的键可能会映射到同一个分区也就是同一个Reduce 作业（因为分区少），所以排序是必须的。</li>
<li>reduce worker 遍历排序后的中间键值对，对于每个唯一的键，都将键与关联的值传递给reduce 函数，reduce 函数产生的输出会添加到这个分区的输出文件中。</li>
<li>当所有的Map 和Reduce 作业都完成了，master 唤醒正版的user program，MapReduce 函数调用返回user program 的代码。</li>
</ol>
<p>所有执行完毕后，MapReduce输出放在了R个分区的输出文件中（分别对应一个Reduce作业）。用户通常并不需要合并这R个文件，而是将其作为输入交给另一个MapReduce程序处理。整个过程中，输入数据是来自底层分布式文件系统（GFS）的，中间数据是放在本地文件系统的，最终输出数据是写入底层分布式文件系统（GFS）的。而且我们要注意Map/Reduce作业和map/reduce函数的区别：Map作业处理一个输入数据的分片，可能需要调用多次map函数来处理每个输入键值对；Reduce作业处理一个分区的中间键值对，期间要对每个不同的键调用一次reduce函数，Reduce作业最终也对应一个输出文件。</p>
<h3 id="用户的权利">用户的权利</h3><p>用户最主要的任务是实现map 和reduce 接口，但还有一些有用的接口是向用户开放的。</p>
<ol>
<li>input reader：这个函数会将输入分为M个部分，并且定义了如何从数据中抽取最初的键值对，比如词频的例子中定义文件名和文件内容是键值对</li>
<li>partition function：这个函数用于将map函数产生的中间键值对映射到一个分区里去，最简单的实现就是将键求哈希再对R取模</li>
<li>compare function：这个函数用于Reduce作业排序，这个函数定义了键的大小关系</li>
<li>output writer：负责将结果写入底层分布式文件系统</li>
<li>combiner function：实际就是reduce 函数，这是用于前面提到的优化。比如统计词频时，如果每个<w, "1"="">要读一次，因为reduce 和map 通常不在一台机器，非常浪费时间，所以可以在map 执行的地方先运行一次combiner，这样reduce 只需要读一次<w, "n"="">了</w,></w,></li>
<li>map 和reduce 函数</li>
</ol>
<p>参见 <a href="http://blog.csdn.net/opennaive/article/details/7514146" target="_blank" rel="external">csdn</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="map函数和reduce函数">map函数和reduce函数</h3><p>map函数和reduce函数是交给用户实现的，这两个函数定义了任务本身。</p>
<ol>
<li>map函数：接受一个键值对（key-value pair），产生一组中间键值对。MapReduce框架会将map函数产生的中间键值对里键相同的值传递给一个reduce函数。</li>
<li>reduce函数：接受一个键，以及相关的一组值，将这组值进行合并产生一组规模更小的值（通常只有一个或零个值）。</li>
</ol>]]>
    
    </summary>
    
      <category term="Hadoop" scheme="http://bluestein.github.io/tags/Hadoop/"/>
    
      <category term="MapReduce" scheme="http://bluestein.github.io/tags/MapReduce/"/>
    
      <category term="分布式" scheme="http://bluestein.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Hadoop" scheme="http://bluestein.github.io/categories/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Efficient Online Evaluation of Big Data Stream Classifiers]]></title>
    <link href="http://bluestein.github.io/2016/03/ML-evaluation-of-data-stream/"/>
    <id>http://bluestein.github.io/2016/03/ML-evaluation-of-data-stream/</id>
    <published>2016-03-09T01:57:05.000Z</published>
    <updated>2016-03-11T13:05:27.450Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372" target="_blank" rel="external">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>
<a id="more"></a>
<p>如今，几乎所有研究者都需要有效的评价他们自己模型的有效性。然而，数据流领域的评价标准面临很多挑战。数据流中的实例是随着时间到来的，并且这些数据所包含的概念（concept）也可能也时间有关。再者，大量的数据还可能面临类别不平衡（class imbalance）问题。现阶段的数据流评价标准一般使用 prequential(predictive sequential?) setting，并且只建立一个模型，不能够实时地计算出统计意义（statistical significance）。</p>
<p>提供统计的意义是非常重要，确保评价结果是有效且没有误导成分。现提出三种突出的有误导性的评价的例子：</p>
<ol>
<li>为了评价两个分类器在数据流上的statistical significance 好坏，会利用McNemar’s test。然而这两个分类器实际上是同一个算法的两个对象（这么理解：C++中的类，new 两个对象），只是使用不同seed 对决策树的随机组合。McNemar’s test对于小型数据来说表现不错，但是使用在大型数据上就是误导。然而，它在数据流分类中却被广泛的使用。</li>
<li>将数据分成独立（disjoint）的两块：training，test，是通常的做法。然而，这种类型的分法，导致一个评价程序仅仅通过分类器的话，不能正确的区分这两块用不同方式构造的数据;</li>
<li>a simple majority class（多类） classifier that keeps the majority class of a sliding window may have positive k statistic and positive harmonic mean accuracy（调和平均精度） for some periods.</li>
</ol>
<p>对于四个问题：</p>
<ol>
<li>Validation methodology（方法验证）</li>
<li>Statistical testing（统计测试）：McNemar’s test 是误导</li>
<li>Unbalanced measure（不平衡衡量标准）：通常的F1-Measure 和Accuracy 会偏向一个类</li>
<li>Forgetting mechanism（遗忘机制）：sliding window（滑动窗口） 和 exponential forgetting 是两种很流行的方法，但是他们都很确定参数。</li>
</ol>
<p>解决方法是：</p>
<ol>
<li>new bootstrap validation</li>
<li>Sign test 和 Wilcoxon signed-rank test</li>
<li>κ_{m} statistic </li>
<li>new forgetting mechanism for prequential evaluation based<br>on ADWIN </li>
</ol>
<h3 id="validation_methodology">validation methodology</h3><p>validation methodology 是用来决定训练集合和测试集合的算法。在文献中有两种主要方法来评价数据流：</p>
<ol>
<li>prequential evaluation：平均10次随机生成数据流上的实验结果。或者使用真实数据集和非随机分类器（non-randomized）进行一个实验；</li>
<li>标准的10-fold 交叉验证；</li>
</ol>
<p>第一类中，使用真实数据和非随机分类器时不能获得statistical significance。第二类把每个fold 的流当成独立的，所以可能会丢失概念漂移的信息。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>]]>
    
    </summary>
    
      <category term="big data" scheme="http://bluestein.github.io/tags/big-data/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/tags/data-stream/"/>
    
      <category term="evaluation" scheme="http://bluestein.github.io/tags/evaluation/"/>
    
      <category term="Machine Learning" scheme="http://bluestein.github.io/categories/Machine-Learning/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/categories/Machine-Learning/data-stream/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里电话面试]]></title>
    <link href="http://bluestein.github.io/2016/03/interview-ali/"/>
    <id>http://bluestein.github.io/2016/03/interview-ali/</id>
    <published>2016-03-08T14:00:05.000Z</published>
    <updated>2016-03-10T11:04:14.286Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>
<a id="more"></a>
<p>关于我答不上来这件事，我知道完全是我自己没准备，以至于错失一次好机会。也总结出关于投递简历的一点小建议（其实是师兄告诉我的。。）：<strong>在deadline之前，在没准备好的情况下，先别冲动投简历！</strong>至于怎么界定“准备好”，就得看大家自己的感觉了。对于我来说，至少需要把基础书看上一遍吧。。不能跟我一样卡壳在基础知识上，以至于面试官认为你根本不是简历上说的那么犀利（excellent？就那意思啦），甚至认为在造假，这种错误我绝不能再犯第二次，嗯，不能。。</p>
<p>下面是今天的问题，大概。。</p>
<p>1，    HTPP中URL由几部分组成<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">URL-Wikipedia</a>）</p>
<p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p>
<ul>
<li>传送协议。</li>
<li>服务器。（通常为域名，有时为IP地址）</li>
<li>端口号。（以数字方式表示，若为HTTP的预设值“:80”可省略）</li>
<li>路径。（以“/”字元区别路径中的每一个目录名称）</li>
<li>查询。（GET模式的表单参数，以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题）</li>
</ul>
<p>2，排序算法<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">排序算法-Wikipedia</a>）</p>
<h4 id="稳定的排序">稳定的排序</h4><ol>
<li>冒泡排序（bubble sort）— O(n2)</li>
<li>鸡尾酒排序（cocktail sort）—O(n2)</li>
<li>插入排序（insertion sort）—O(n2)</li>
<li>桶排序（bucket sort）—O(n)；需要O(k)额外空间</li>
<li>计数排序（counting sort）—O(n+k)；需要O(n+k)额外空间</li>
<li>归并排序（merge sort）—O(n log n)；需要O(n)额外空间</li>
<li>原地归并排序— O(n log2 n)如果使用最佳的现在版本</li>
<li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li>
<li>鸽巢排序（pigeonhole sort）—O(n+k)；需要O(k)额外空间</li>
<li>基数排序（radix sort）—O(n·k)；需要O(n)额外空间</li>
<li>侏儒排序（gnome sort）— O(n2)</li>
<li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li>
<li>块排序（block sort）— O(n log n)</li>
<li>额外儿童网二对一后退萨大人排序（children two to one additional network Back Sa adults sort）— O(n2)</li>
</ol>
<h4 id="不稳定排序">不稳定排序</h4><ol>
<li>选择排序（selection sort）—O(n2)</li>
<li>希尔排序（shell sort）—O(n log2 n)如果使用最佳的现在版本</li>
<li>Clover排序算法（Clover sort）—O(n)期望时间，O(n2)最坏情况</li>
<li>梳排序— O(n log n)</li>
<li>堆排序（heap sort）—O(n log n)</li>
<li>平滑排序（smooth sort）— O(n log n)</li>
<li>快速排序（quick sort）—O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li>
<li>内省排序（introsort）—O(n log n)</li>
<li>耐心排序（patience sort）—O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li>
</ol>
<p>3，浏览器输入一个网址，其背后原理解释<br>答：(参考 <a href="http://www.cricode.com/3696.html" target="_blank" rel="external">在浏览器中输入网址后都发生了什么</a>)</p>
<p>从输入一个网址到显示，包括dns解析，http协议解析，html解析，js解析，以及各种内容渲染</p>
<ol>
<li><p>浏览器发起DNS查询请求<br>在广域网中，我们是基于IP地址进行通信的。但通常客户访问的是一个网址，为此，我们需要先得到网址对应的IP地址，这就需要域名服务系统将域名转换成IP地址。</p>
</li>
<li><p>域名服务器向客户端返回查询结果域名，从而完成域名到IP地址的转换</p>
</li>
<li><p>客户端向web服务器发送HTTP请求<br>在得到了域名对应的IP地址后，客户端便可以向真正的web服务器发生HTTP请求。<br>HTTP请求是一个基于TCP协议之上的应用层协议——超文本传输协议。浏览器通过DNS获取到web服务器真的IP地址后，便向web服务器发起tcp连接请求，通过TCP三次握手建立好连接后，浏览器便可以将HTTP请求数据通过发送给服务器了。</p>
</li>
<li><p>发送响应数据给客户端<br>Web服务器通常通过监听80端口，来获取客户端的HTTP请求。与客户端建立好TCP连接后，web服务器开始接受客户端发来的数据，并通过HTTP解码，从接受到的网络数据中解析出请求的url信息以前其他诸如Accept-Encoding、Accept-Language等信息。<br>至此，一个HTTP通信过程完成。web服务器会根据HTTP请求头中的Connection字段值决定是否关闭TCP链接通道，当Connection字段值为keep-alive时，web服务器不会立即关闭此连接。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>]]>
    
    </summary>
    
      <category term="alibaba" scheme="http://bluestein.github.io/tags/alibaba/"/>
    
      <category term="hhh" scheme="http://bluestein.github.io/tags/hhh/"/>
    
      <category term="interview" scheme="http://bluestein.github.io/tags/interview/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="JobHunting" scheme="http://bluestein.github.io/categories/Odds-Ends/JobHunting/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KMP: 字符串匹配算法]]></title>
    <link href="http://bluestein.github.io/2016/03/Algorithm-KMP/"/>
    <id>http://bluestein.github.io/2016/03/Algorithm-KMP/</id>
    <published>2016-03-08T07:23:05.000Z</published>
    <updated>2016-03-08T08:01:38.905Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="external">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>
<a id="more"></a>
<h3 id="1">1</h3><p><img src="/images/kmp/kmp_1.png" alt=""></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<h3 id="2">2</h3><p><img src="/images/kmp/kmp_2.png" alt=""></p>
<p>因为B与A不匹配，搜索词再往后移。</p>
<h3 id="3">3</h3><p><img src="/images/kmp/kmp_3.png" alt=""></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>
<h3 id="4">4</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<h3 id="5">5</h3><p><img src="/images/kmp/kmp_6.png" alt=""></p>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较就像上图所示。<strong>这样做虽然可行，但是效率很差</strong>，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>
<h3 id="6">6</h3><p><img src="/images/kmp/kmp_8.png" alt=""></p>
<p>可以针对搜索词，算出一张<strong>部分匹配表</strong>（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<h3 id="7">7</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">　　移动位数 </span>=<span class="string"> 已匹配的字符数 - 对应的部分匹配值</span></span><br></pre></td></tr></table></figure>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<h3 id="8">8</h3><p><img src="/images/kmp/kmp_10.png" alt=""></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<h3 id="9">9</h3><p><img src="/images/kmp/kmp_11.png" alt=""><br>因为空格与A不匹配，继续后移一位。</p>
<h3 id="10">10</h3><p><img src="/images/kmp/kmp_12.png" alt=""></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<h3 id="11">11</h3><p><img src="/images/kmp/kmp_13.png" alt=""></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<h2 id="Partial_Match_Table：部分匹配表">Partial Match Table：部分匹配表</h2><p><img src="/images/kmp/kmp_14.png" alt=""></p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<p>参考 @阮一峰 <a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">KMP-cnblog</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>]]>
    
    </summary>
    
      <category term="KMP" scheme="http://bluestein.github.io/tags/KMP/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[const与指针、函数]]></title>
    <link href="http://bluestein.github.io/2016/03/cpp-const-pointer-function/"/>
    <id>http://bluestein.github.io/2016/03/cpp-const-pointer-function/</id>
    <published>2016-03-05T01:23:05.000Z</published>
    <updated>2016-03-05T02:46:17.003Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>2. const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p>关于指针的其他内容，请参考本站文章<a href="http://bluestein.github.io/2015/11/cpp-primer4-11/">指针</a>。</p>
<h2 id="const与函数">const与函数</h2><hr>
<p><strong>1. 用const修饰函数的参数</strong></p>
<p>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。const 只能修饰输入参数：</p>
<p><strong>如果输入参数采用“指针传递”，那么加 const 修饰可以防止意外地改动该指针，起到保护作用。</strong></p>
<p>例如 StringCopy 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *destination, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>source</code> 是输入参数，<code>destination</code> 是输出参数。给 <code>destination</code> 加上 const 修饰后，<strong>如果函数体内的语句试图改动 source 的内容，编译器将指出错误。</strong></p>
<p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，则输入参数无需保护，所以不要加 const 修饰。</p>
<p>例如， void func(int x) 而不是 void func(const int x) 。同理，同理不要将函数 void fun2(A a) 写成 void func2(const A a)。其中 A 为用户自定义的数据类型。</p>
<p>对于非内部数据类型的参数而言，象 void func(A a) 这样声明的函数注定效率比较底。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p><strong>为了提高效率，可以将函数声明改为 void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数 void func(A &amp;a) 存在一个缺点:</strong></p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p>
<p>以此类推，是否应将 void func(int x) 改写为 void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p>总结一下：</p>
<ol>
<li>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将 void func(A a) 改为 void func(const A &amp;a)。</li>
<li>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如 void func(int x) 不应该改为void func(const int &amp;x)。</li>
</ol>
<p><strong>2. 用const 修饰函数的返回值</strong></p>
<p>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，<strong>该返回值只能被赋给加const 修饰的同类型指针</strong>。</p>
<p>如下语句将出现编译错误：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。</p>
<p>例如，不要把函数 int getInt(void) 写成 const int getInt(void)。同理不要把函数 A getA(void) 写成 const A getA(void)，其中 A 为用户自定义的数据类型。</p>
<p>如果返回值不是内部数据类型，将函数 A getA(void) 改写为 const A &amp; getA(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">A</span> &amp; operate = (const <span class="type">A</span> &amp;other); <span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> a, b, <span class="built_in">c</span>; <span class="comment">// a, b, c 为 A 的对象</span></span><br><span class="line">a = b = <span class="built_in">c</span>; <span class="comment">// 正常的链式赋值</span></span><br><span class="line">(a = b) = <span class="built_in">c</span>; <span class="comment">// 不正常的链式赋值，但合法</span></span><br></pre></td></tr></table></figure>
<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p>
<p><strong>3. const 成员函数</strong></p>
<p>任何不会修改数据成员的函数都应该声明为 const 类型。如果在编写 const 成员函数时，不慎修改了数据成员，或者调用了其它非 const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p>
<p>以下程序中，类 Stack 的成员函数 GetCount 仅用于计数，从逻辑上讲 GetCount 应当为 const 函数。编译器将指出 GetCount 函数中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_num;</span><br><span class="line">	<span class="keyword">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::GetCount(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	++m_num; <span class="comment">// 编译错误，企图修改数据成员 m_num</span></span><br><span class="line">	Pop(); <span class="comment">// 编译错误，企图调用非 const 函数</span></span><br><span class="line">	<span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 成员函数的声明看起来怪怪的：const 关键字只能放在函数声明的尾部，大概是因为其它地方都已经被占用了。</p>
<p>关于 const 函数的几点规则：</p>
<ol>
<li>const 对象只能访问 const 成员函数,而非 const 对象可以访问任意的成员函数,包括 const 成员函数.</li>
<li>const 对象的成员是不可修改的,然而 const 对象通过指针维护的对象却是可以修改的.</li>
<li>const 成员函数不可以修改对象的数据,不管对象是否具有 const 性质.它在编译时,以是否修改成员数据为依据,进行检查.</li>
<li>然而加上 mutable 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 const 成员函数是可以修改它的</li>
</ol>
<p>该部分,参考<a href="http://www.cnblogs.com/Fancyboy2004/archive/2008/12/23/1360810.html" target="_blank" rel="external">原文</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="const" scheme="http://bluestein.github.io/tags/const/"/>
    
      <category term="指针" scheme="http://bluestein.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[冬跑]]></title>
    <link href="http://bluestein.github.io/2016/02/interest-winter-running/"/>
    <id>http://bluestein.github.io/2016/02/interest-winter-running/</id>
    <published>2016-02-25T07:15:05.000Z</published>
    <updated>2016-03-05T02:44:53.849Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>
<a id="more"></a>
<h3 id="1、跑鞋">1、跑鞋</h3><p>我个人觉得，要跑步的话必须现有一双好的跑鞋。我在网络上看到，这个网站 <a href="http://www.myprecisionfit.com" title="myprecisionfit" target="_blank" rel="external">myprecisionfit</a> 能够根据自身情况进行跑鞋推荐。这个网站推荐了好几双，各种价位的都有，但考虑到刚入门和能不坚持下去都是个问题就选了一双经济承受范围内 wave 系列。在京东和天猫都有官方旗舰店，可自行选择购买。我的选择是：（切记，要根据自身情况选择跑鞋，我列出我的选择是为了理清预算）</p>
<ul>
<li>MIZUNO Wave Laser 2 ￥329</li>
</ul>
<h3 id="2、服饰装备">2、服饰装备</h3><h4 id="2-1、上身">2.1、上身</h4><p>看到网络大部分意见上说冬天需要三层：</p>
<ul>
<li>最里层：速干T；</li>
<li>中层：保暖；</li>
<li>最外层：防风；</li>
<li>其他：臂包，袜子，手套，帽子等；</li>
</ul>
<p>上面所说的所有装备均可以在 <a href="http://www.decathlon.com.cn/zh/running" title="迪卡侬" target="_blank" rel="external">迪卡侬</a> 买到，而且性价比不错。先声明，绝对不是打广告。我选择的是</p>
<ul>
<li>速干T：KALENJI EKIDEN TS ￥19.9</li>
<li>保暖：KALENJI EKIDEN LS ￥69.9</li>
<li>防风：<ul>
<li>KALENJI COMFORT PROTECT WIND ￥79.0</li>
<li>其他</li>
</ul>
</li>
<li>其他：<ul>
<li>臂包：KALENJI ARMBAND ￥49.9</li>
<li>袜子：暂未购买</li>
<li>其他</li>
</ul>
</li>
</ul>
<h4 id="2-2、下身">2.2、下身</h4><p>也有说不用特别选下身的，只要是普通运动裤都可以。但是我个人觉得别人有这个卖的话顺便也买一条，反正也不贵呀。对于下身来说，分两层就可以了吧。</p>
<ul>
<li>内层：快干内裤；</li>
<li>外层：运动长裤（冬天当然是长裤）；</li>
</ul>
<p>同样的，也可以在迪卡侬选购，再说一遍，我真的不是打广告的（=_=）。我的选择是：</p>
<ul>
<li>内层：暂时未买，试试看再说；</li>
<li>外层：KALENJI EKIDEN PANT ￥99.0</li>
</ul>
<p><strong>总预算：329 + 19.9 + 69.9 + 79.0 + 49.9 + 99.0 = ￥646.7</strong></p>
<h3 id="3、开跑">3、开跑</h3><p>以下内容参考了知乎</p>
<h4 id="3-1、空气环境">3.1、空气环境</h4><p>一般来说PM2.5超过100就要慎重，比100低基本问题不大；大于100，小于150，属于轻度污染，如果对雾霾比较敏感的人不太适宜跑步，如果不是很敏感，勉强可以接受；但是如果是150～200，这属于中度污染，跑步这个时候对人体是不健康的；如果追求健康就不要跑了。超过200逼近300的话，无论如何是不能出去跑的，等个合适的天再出门跑步，实在熬不住，那就跑步机或去周围空气好的城市或山区跑一下，这里提醒大家PM2.5指数以当时指数为准。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</p>
<h4 id="3-2、跑步流程：热身→跑步→拉伸">3.2、跑步流程：热身→跑步→拉伸</h4><ul>
<li>跑步姿势可以参考 <a href="http://www.zhihu.com/question/31089103/answer/61288749" target="_blank" rel="external">缺个口子的大苹果 - 正确的跑步姿势是怎样的？</a>。</li>
<li>预热：晨跑前先喝大概250cc糖水或香蕉，防止低血糖。然后先可以先走一走，比如出家门走到运动场。通过血液循环，使身体由内而外地热起来。然后只要再做做准备动作，身体就可以充分放松了。注意不要像散步一样随意走，要保持正确的姿势，从骨盆开始带动腿。（<a href="http://www.zhihu.com/question/36505010/answer/67853152" target="_blank" rel="external">袁超 - 冬天了，跑步方便吗？</a>）</li>
<li>跑步：调整呼吸开跑，完成预定目标。</li>
<li>拉伸：要充分的拉伸。</li>
</ul>
<h4 id="3-3、注意事项">3.3、注意事项</h4><ol>
<li>如果喜欢一边跑步一边听歌的话最好换个蓝牙耳机。北京冬天早上空气冷，普通耳机橡胶线遇冷容易变硬，弹性减小，再加上跑步运动，很容易把耳机线拉断。</li>
<li>记得带个润唇膏，暴漏在干冷天气里的嘴唇很容易干裂。如果遇到大风天，可以戴防风眼镜。</li>
<li>秋季空气中湿度减少，容易引起咽喉干燥、口舌少津、嘴唇干裂、鼻子出血、大便干燥等症状。再加上运动时丧失的水分会加重人体缺乏水分的反应，所以，运动后一定要多喝开水，多吃梨、苹果、乳类、芝麻、新鲜蔬菜等柔润食物，或是平时多喝冰糖梨水、冬瓜汤等食物来保持上呼吸道黏膜的正常分泌，防止咽喉肿痛。</li>
<li>如果运动量较大，出汗过多，可在开水中加少量食盐，以维持体内酸碱平衡，有条件的可以喝一些含电解质的运动饮料，防止肌肉出现痉挛。</li>
<li>如进行长跑锻炼，还要饮用适量的糖开水，以防低血糖，出现头晕、出虚汗、四肢乏力等不良生理反应。</li>
<li>运动时补水不能在运动前或运动后一下子喝很多，运动前喝多了容易造成肠胃负担加重，而且一动起来胃里咣咣响也影响锻炼。运动后猛喝会带走大量的电解质，部分流出体外，对身体不好，运动时饮水最好能分次少量饮用，比如锻炼20分钟，喝150到200毫升，饮料浓度为6-8%的低渗饮料（含糖、钠、钾、钙、镁）。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</li>
</ol>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>]]>
    
    </summary>
    
      <category term="running" scheme="http://bluestein.github.io/tags/running/"/>
    
      <category term="sport" scheme="http://bluestein.github.io/tags/sport/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="兴趣" scheme="http://bluestein.github.io/categories/Odds-Ends/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单词转换程序]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-12/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-12/</id>
    <published>2016-01-14T12:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.938Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; trans_map;</span><br><span class="line">	<span class="built_in">string</span> key, value;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"wrong number of arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream map_file;</span><br><span class="line">	map_file.open(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!map_file) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no transformation file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (map_file &gt;&gt; key &gt;&gt; value) &#123;</span><br><span class="line">		trans_map.insert(make_pair(key, value));</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream input;</span><br><span class="line">	input.open(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no input file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> line;</span><br><span class="line">	<span class="keyword">while</span> (getline(input, line)) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">s</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (s &gt;&gt; word) &#123;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::const_iterator map_citer = trans_map.find(word);</span><br><span class="line">			<span class="keyword">if</span> (map_citer != trans_map.end()) &#123;</span><br><span class="line">				word = map_citer-&gt;second;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (first) &#123;</span><br><span class="line">				first = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关联容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-associative_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-associative_container/</id>
    <published>2016-01-14T06:49:02.000Z</published>
    <updated>2016-03-05T02:41:48.583Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>
<a id="more"></a>
<ol>
<li>map 以 key-value（键-值） 的形式组织：键作为元素在 map 中的索引，而值则表示所要存储和读取的元素。</li>
<li>set 仅包含键，可以看成含有很多键值得集合。</li>
</ol>
<table>
<thead>
<tr>
<th>关联容器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>关联数组</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
</tr>
<tr>
<td>multimap</td>
<td>一个键可出现多次的 map 类型</td>
</tr>
<tr>
<td>multiset</td>
<td>一个键可出现多次的 set 类型</td>
</tr>
</tbody>
</table>
<p>一般来说，<strong>如果想有效的存储不同值得集合</strong>，使用 set 比较合适；而 map 容器则更适合用于存储键关联值得情况。<br>比如在文本处理时，可以使用 set 来存储要忽略的词，而 map 可以使用作字典：单词本身是键，其解释是值。</p>
<blockquote>
<p>set 和 map 的键是唯一的，每个键只能出现一次。如果想使用一个键对应多个值得情况，那么使用 multiset 和 multimap 类型。</p>
</blockquote>
<h3 id="pair_类型">pair 类型</h3><p>在介绍关联容器之前，必须先了解一种与之相关的简单的标准库类型——pair 类型，在 <code>utility</code> 头文件中定义</p>
<table>
<thead>
<tr>
<th>pair 类型所提供的操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pair<t1, t2=""> p1</t1,></td>
<td>创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用<strong>值初始化</strong></td>
</tr>
<tr>
<td>pair<t1, t2=""> p1(v1,v2)</t1,></td>
<td>创建一个 pair 对象，它的两个元素类型分别是 T1 和 T2。其中 first 成员初始化为 v1，second 成员初始化为 v2</td>
</tr>
<tr>
<td>make_pair(v1, v2)</td>
<td>用 v1 和 v2 创建一个 pair 对象，其元素的类型分别是 v1 和 v2 的类型。</td>
</tr>
<tr>
<td>p1 &lt; p2</td>
<td>两个 pair 对象的小于运算，其定义遵循字典次序：如果 <code>p1.first &lt; p2.first</code> 或 <code>!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second</code> 则返回 true</td>
</tr>
<tr>
<td>p1 == p2</td>
<td>等于操作</td>
</tr>
<tr>
<td>p.first</td>
<td>返回 p 中的 first（第一个） 成员</td>
</tr>
<tr>
<td>p.second</td>
<td>返回 p 中的 second（第二个） 成员</td>
</tr>
</tbody>
</table>
<h4 id="pair_的创建和初始化">pair 的创建和初始化</h4><p>在创建 pair 对象时，必须提供两个类型名，这两个类型名不必相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; line;</span><br></pre></td></tr></table></figure>
<p><strong>创建 pair 时，如果不提供初始化式，则调用默认构造函数进行值初始化。</strong>所以，<code>anon</code> 是包含两个空 string 成员的 pair 对象； <code>word_count</code> 中的 int 型成员获得 0 值； <code>line</code> 则是存储一个空 string 和一个空 vector 类型的对象。</p>
<p>也可以提供初始化式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author(<span class="string">"James"</span>, <span class="string">"Joyce"</span>);</span><br></pre></td></tr></table></figure>
<p>pair 类型使用起来较繁琐，可以使用 typedef 简化声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">"Marcel"</span>, <span class="string">"Proust"</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="pair_对象操作">pair 对象操作</h4><p>与其他标准库类型不同，对于 pair 类型，<strong>可以直接访问其数据成员，它的成员都是公有的</strong>。分别命名为 first 和 second。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook;</span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author == <span class="string">"Joyce"</span>)</span><br><span class="line">	firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure>
<p>除了构造函数之外，标准库还提供一个 make_pair 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="built_in">string</span> first, last;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123;</span><br><span class="line">	next_auth = make_pair(first, last);</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为成员是公有的，所以可以直接输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; next_auth.first &gt;&gt; next_auth.second) &#123;</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联容器">关联容器</h3><p>关联容器与顺序容器共享大部分的操作，但并不是全部。关联容器不支持 <strong>front, push_front, pop_front, back, push_back, pop_back</strong> 等操作。共享的包括：</p>
<ol>
<li><p>三种构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;</span><br><span class="line">C&lt;T&gt; c1(c2);</span><br><span class="line">C&lt;T&gt; c(begin, end);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算</p>
</li>
<li>begin，end，rbegin，rend</li>
<li>typedef。注意：对于 map 类型，<strong>value_type 的类型是 pair 类型。</strong></li>
<li>swap 和 赋值操作。<strong>但不提供 assign 函数</strong>。</li>
<li>clear，erase。<strong>关联容器 erase 操作返回 void 类型</strong>。</li>
<li>容器大小的操作。<strong>不支持 resize 操作</strong>。</li>
</ol>
<p>对于与顺序容器相同的操作，关联容器重新定义了这些操作的含义或返回类型，主要区别在于关联容器中使用了键。</p>
<blockquote>
<p>元素在关联容器中根据键的顺序排列。</p>
</blockquote>
<h3 id="map_类型">map 类型</h3><p>map 可以理解为 <strong>关联数组</strong>，但是通过键获取元素值，而不是位置。</p>
<h4 id="map_的定义">map 的定义</h4><p>要使用 map 需包含 map 头文件</p>
<table>
<thead>
<tr>
<th>map 的构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v=""> m;</k,></td>
<td>空 map 对象，键和值得类型分别为 k 和 v</td>
</tr>
<tr>
<td>map<k, v=""> m(m1)</k,></td>
<td>创建 m1 的副本</td>
</tr>
<tr>
<td>map<k, v=""> m(begin, end);</k,></td>
<td>创建 begin 至 end 范围内所有元素的副本</td>
</tr>
</tbody>
</table>
<p><strong>键类型的约束</strong></p>
<p>在使用关联容器时，<strong>它的键类型必须要有一个比较函数</strong>。所使用的比较函数必须在键类型上<strong>严格弱排序</strong>。所谓严格弱排序，可以理解为键类型数据上的“小于”关系，不能出现相互“小于”的情况。</p>
<blockquote>
<p>在实际应用中，键类型必须定义 &lt; 操作符，而且该操作符能正确的工作。</p>
</blockquote>
<h4 id="map_定义的类型">map 定义的类型</h4><p>map 对象是键-值对，每个元素分为两个部分：键和其关联的值。map 的 value_type 可以很清楚的表示这种情况，该类型是 pair 类型。</p>
<table>
<thead>
<tr>
<th>map 定义的类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v="">::key_type</k,></td>
<td>键的类型</td>
</tr>
<tr>
<td>map<k, v="">::mapped_type</k,></td>
<td>值的类型</td>
</tr>
<tr>
<td>map<k, v="">::value_type</k,></td>
<td>键-值的类型：pair类型。有 first 和 second 两个公有成员</td>
</tr>
</tbody>
</table>
<p>对 map 的迭代器解引用会产生一个 pair 类型值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h4 id="向_map_添加元素">向 map 添加元素</h4><p><strong>下标</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面程序会发生：</p>
<ol>
<li>在 <code>word_count</code> 中查找键为 Anna 的元素，没有找到；</li>
<li>将一个键为 Anna 的 pair 插入到 <code>word_count</code>，该 pair 的值为 (“Anna”, 0)。</li>
<li>读取新插入的元素，并将它赋值为 1.</li>
</ol>
<blockquote>
<p>故使用下标访问 map 中没有的元素会导致向该容器中添加一个新元素。</p>
</blockquote>
<p><strong>insert</strong></p>
<table>
<thead>
<tr>
<th>insert 操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.insert(p);</td>
<td>p 是 value_type 类型的值，如果 p.first 不存在，则插入 p 到 m，否则 m 保持不变。该函数返回一个 pair 对象，包含一个指向 p 的 map 的迭代器，和一个 bool 值。</td>
</tr>
<tr>
<td>m.insert(begin, end);</td>
<td>插入 begin 和 end 范围内的值。返回 void 类型</td>
</tr>
<tr>
<td>m.insert(iter, p)</td>
<td>如果 p.first 不在 m 中，则以 iter 为起点搜索 p 的存储位置。返回一个迭代器，指向新插入的 p。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<p><strong>insert 的返回值类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// use typedef</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret_type;</span><br><span class="line">ret_type ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<h4 id="查找_map_中的元素">查找 map 中的元素</h4><p>读取 map 中一个元素最简单的方法是下标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">int</span> occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>但是有个弊端：如果该键不在 map 中，则会插入之。</p>
<p>对于查找或读取元素，map 提供了两个操作： count 和 find。</p>
<ol>
<li>find： <code>m.find(key)</code>, 如果存在 key 索引的元素，返回指向该元素的迭代器，否则返回末端迭代器，即 end()；</li>
<li>count：<code>m.count(key)</code>,  返回 m 中 k 出现的次数；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (word_count.count(<span class="string">"Anna"</span>))</span><br><span class="line">	occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>这里对元素做了两次查询，在优化性能时可以考虑。find 则更适合查询元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"Anna"</span>);</span><br><span class="line"><span class="keyword">if</span> (it != word_count.end())</span><br><span class="line">	occurs = it-&gt;second;</span><br></pre></td></tr></table></figure>
<h4 id="从_map_删除元素">从 map 删除元素</h4><table>
<thead>
<tr>
<th>删除元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.erase(key)</td>
<td>删除键为 k 的元素。返回 size_type 类型的值，表示删除元素的个数</td>
</tr>
<tr>
<td>m.erase(iter)</td>
<td>删除迭代器 iter 指向的元素。iter 必须指向存在的元素，且不能等于 m.end()。返回 void 类型。</td>
</tr>
<tr>
<td>m.erase(begin, end)</td>
<td>删除范围内的元素。返回 void 类型。</td>
</tr>
</tbody>
</table>
<h3 id="set_类型">set 类型</h3><p>set 跟 map 不同，它只是单纯的键的集合。支持：</p>
<ol>
<li>insert</li>
<li>count，find</li>
<li>erase</li>
</ol>
<p>另外：</p>
<ol>
<li>不支持下标操作；</li>
<li>没有 mapped_type 类型；</li>
</ol>
<h4 id="set_类型的定义和使用">set 类型的定义和使用</h4><p>set 存放的是一系列唯一值的集合。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; endl; <span class="comment">// prints 20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; endl; <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向 set 添加元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; sset;</span><br><span class="line">sset.insert(<span class="string">"C.X.Q"</span>);</span><br><span class="line">sset.insert(<span class="string">"I L U"</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">iset.insert(ivec.begin(), ivec.end());</span><br></pre></td></tr></table></figure>
<p><strong>从 set 中获取元素</strong></p>
<p>set 不提供下标操作，只能使用 find 和 count 函数，count 函数的返回值只能是 1 或 0，因为里面的元素都是唯一的。正如不能修改 map 的键一样，set 中的键也是 const 类型。在获得指向 set 中某元素的迭代器后，只能对其做读操作，不能做写操作。</p>
<h3 id="multiset_和_multimap">multiset 和 multimap</h3><p>map 和 set 中键都是唯一的，而 multimap 和 multiset 类型则允许同一个键多次出现。也就是说每次调用 insert 都会添加一个元素，而 erase 则会删除跟该键有关的所有元素。</p>
<h4 id="multiset_和_multimap_中查找元素">multiset 和 multimap 中查找元素</h4><p>在 multimap 中，同一个键的所有元素都相邻存放。</p>
<p><strong>使用 find 和 count 函数</strong></p>
<p>count 返回某个键的出现的次数，find 返回的是一个迭代器，指向第一个正在查找的键的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"C.X.Q."</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::size_type sz_type;</span><br><span class="line">sz_type entrise = authors.count(search_item);</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter = authors.find(search_item);</span><br><span class="line"><span class="keyword">for</span> (sz_type cnt = <span class="number">0</span>; cnt != entrise; ++cnt, ++iter)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>另一种解决办法</strong></p>
<table>
<thead>
<tr>
<th>返回迭代器的关联操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.lower_cound(key)</td>
<td>返回一个迭代器，指向第一个不小于 key 的元素</td>
</tr>
<tr>
<td>m.upper_bound(key)</td>
<td>返回一个迭代器，指向第一个大于 key 的元素</td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>返回一个迭代器的 pair 对象<br>first 成员等价于 m.lower_bound(key),second 成员等价于 m.upper_bound(key)</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LaTeX: LLNCS v2.4]]></title>
    <link href="http://bluestein.github.io/2016/01/ML-LATEX-LLNCS/"/>
    <id>http://bluestein.github.io/2016/01/ML-LATEX-LLNCS/</id>
    <published>2016-01-09T02:02:00.000Z</published>
    <updated>2016-03-05T02:37:36.864Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/" target="_blank" rel="external">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="Invoke_LLNCS_class">Invoke LLNCS class</h4><p>LLNCS 只是标准 LATEX “article” class 的拓展版本，所以在文章中可以使用所有 “article” 的语法。如果要使用 LLNCS class，则使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;llncs&#125;</span><br><span class="line">%</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">&lt;Your contribution&gt;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文章已经用_LATEX_写好而未使用_LLNCS_格式的情况">文章已经用 LATEX 写好而未使用 LLNCS 格式的情况</h4><p>请不要使用任何会影响文档布局或格式的 LATEX 或 TEX命令（即像 <code>\textheight</code>, <code>\vspace</code>, <code>\headsep</code>, etc）。然而，有可能会有例外的情况下，可以使用一些。</p>
<h3 id="公式输入">公式输入</h3><p>公式会以您文章出现的顺序在右手边使用阿拉伯数字自动编号。当你的工作在数学模式时，都是用斜体字排版。有时候你需要插入非数学元素（例如单词或短语）。这种插入的代码应该使用 roman（即 <code>\mbox</code>）如下例所示： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125; </span><br><span class="line">\left(\frac&#123;a^&#123;<span class="number">2</span>&#125; + b^&#123;<span class="number">2</span>&#125;&#125;&#123;c^&#123;<span class="number">3</span>&#125;&#125; \right) = <span class="number">1</span> \quad</span><br><span class="line">\mbox&#123; <span class="keyword">if</span> &#125; c\neq <span class="number">0</span> \mbox&#123; and <span class="keyword">if</span> &#125; a,b,c\in \bbbr \enspace .</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<p><img src="/images/equation_sample.png" alt=""></p>
<p>如果你想在一个显示公式后立即开始新的段落，插入一个空白行，以产生所需的缩进。如果不插入一个空白行或代码 <code>\noindent</code> 会立即继续之前的文本而没有没有新的段落。</p>
<p>displayed 公式也使用相同的方式处理，其他普通文本则在结束本句前使用 <code>\enspace</code>。</p>
<p>注意括号的尺寸或其他分隔符必须保证是闭合的，使用下面命令可以保证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left( 或者 \left[ 和 \right) 或者 \right].</span><br></pre></td></tr></table></figure>
<h4 id="斜体和_Roman_体">斜体和 Roman 体</h4><ol>
<li>在公式中，一般使用斜体，但下标应使用 Roman 体而不是斜体。</li>
<li>确保一些物理标记使用 <code>\mathrm</code> 命令，如 Hz： <code>\mathrm{Hz}</code>。还有一些常用的数学函数，如 log，sin，exp，max和sup应该使用：<code>\log</code>，<code>\sin</code>，<code>\exp</code>，<code>\max</code> 和 <code>\sup</code>。</li>
<li>化学式应该使用 Roman 体，如： H2O。</li>
<li>熟悉的单词或句子不应使用斜体，如： et al., a priori, in situ, bremsstrahlung, eigenvalues。</li>
</ol>
<h3 id="How_to_Edit_Input_(Source)_File">How to Edit Input (Source) File</h3><h4 id="Headings">Headings</h4><p>标题中的所有单词应该都大写，除了连词、介词 (例如 on, of, by, and, or, but, from, with, without, under) 还有定冠词和不定冠词 (the, a, an) 除非他们出现在开头，否则均小写。公式的字母必须在文本内排版。</p>
<h4 id="大写和不大写">大写和不大写</h4><ol>
<li>下面情况均需大写：<ol>
<li>Headings。</li>
<li>文章中的缩写和表达式，如：  Fig(s)., Table(s), Sect(s)., Chap(s)., Theorem, Corollary, Deﬁnition etc. 跟数字一起使用时，如： Fig.3, Table 1, Theorem 2。</li>
</ol>
</li>
<li>下面情况不能大写：<ol>
<li>在文章中，当 ﬁgure(s), table(s), equation(s), theorem(s) 等词没有与编号一起使用时。</li>
<li>图表图例和表格标题，除非是缩写。</li>
</ol>
</li>
</ol>
<h4 id="词的缩写">词的缩写</h4><ol>
<li>下列词除非是出现在句子开头，否则在文章中应该使用缩写： Chap., Sect., Fig.。例如： The results are depicted in Fig.5. Figure 9 reveals that …. <blockquote>
<p>注： 公式一般使用括号跟数字代替，但出现在句子开头时需使用 “Equation”。 例如：Equation (14) is very important. However, (15) makes it clear that …. </p>
</blockquote>
</li>
<li>如果文章中有出现全局的缩写，应该在第一次出现的时候标明，如： Plurisubharmonic (PSH) Functions, Strong Optimization (SOPT) Problem.</li>
</ol>
<h3 id="文章的开头">文章的开头</h3><p>文章的标题（必须的）使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;&lt;Your contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>标题中所有单词应大写，除了连词、介词和不出现在开头的定冠词和不定冠词。标题没有结束标点。</p>
<p>如果是很长的标题，使用 <code>\\</code> 另起一行。</p>
<p>If you are to produce running heads for a speciﬁc volume the standard (of no such running heads) is overwritten with the [runningheads] option in the \documentclass line. For long titles that do not ﬁt in the single line of the running head a warning is generated. You can specify an abbreviated title for the running head on odd pages with the command：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\titlerunning&#123;&lt;Your abbreviated contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>There is also a possibility to change the text of the title that goes into the table of contents (that’s for volume editors only – there is no table of contents for a single contribution). For this use the command:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\toctitle&#123;&lt;Your changed title <span class="keyword">for</span> the table of contents&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>副标题使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\subtitle&#123;&lt;subtitle of your contribution&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>作者使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;&lt;author(s) name(s)&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>为每个作者或地址指定标号时，使用： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\inst&#123;&lt;no&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>超过一位作者的话，可以使用 <code>\and</code> 分隔。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是地址（学校，公司）了，多于一个地址，使用 <code>\and</code> 命令会自动编号，请确保跟作者顺序对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\institute&#123;&lt;name of an institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>\institute</code> 内使用 <code>\email{&lt;email address&gt;}</code> 可以提供email地址。如果在文章的任何地方需要注脚，请使用(immediately after the word where the footnote indicator should be placed)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\thanks&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>\thanks</code> 仅能出现在 <code>\title</code>, <code>\author</code> and <code>\institute</code>中. 如果有两个或更多的脚注使用 <code>\fnmsep</code> (i.e. footnote mark separator) 分隔.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\maketitle</span><br></pre></td></tr></table></figure>
<p>然后 heading 就结束了，到这一步为止，还不会产生任何文本。</p>
<p>接下来就是摘要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">&lt;Text of the summary of your article&gt;</span><br><span class="line">\end&#123;abstract&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### How to Code Your Text ###</span></span><br><span class="line"></span><br><span class="line">用以下代码的话，标题会自动编号：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">\section&#123;This is a First-Order Title&#125; </span><br><span class="line">\subsection&#123;This is a Second-Order Title&#125; </span><br><span class="line">\subsubsection&#123;This is a Third-Order Title.&#125; </span><br><span class="line">\paragraph&#123;This is a Fourth-Order Title.&#125;</span><br></pre></td></tr></table></figure>
<p><code>\section</code> and <code>\subsection</code> 没有 end punctuation。<code>\subsubsection</code> and <code>\paragraph</code> 需要在末尾 punctuate。 </p>
<p>另外，theorem-like environments 会自动编号，如果要使用计数器，只需指定 <code>envcountsame</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountsame]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>例如 <code>\begin{lema}</code>，第一次调用时会编号为1，再次调用编号为2，以此类推。如果需要每个 section 都重新计数，则指定为 <code>envcountreset</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountreset]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预定义的_Theorem-like_Environments">预定义的 Theorem-like Environments</h3><p>下面的标题随你选择：</p>
<ol>
<li><p>加粗并带斜体文本的 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;corollary&#125; &lt;text&gt; \end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; &lt;text&gt; \end&#123;lemma&#125; </span><br><span class="line">\begin&#123;proposition&#125; &lt;text&gt; \end&#123;proposition&#125; </span><br><span class="line">\begin&#123;theorem&#125; &lt;text&gt; \end&#123;theorem&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下的一般表现为斜体 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;proof&#125; &lt;text&gt; \qed \end&#123;proof&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这不编号，并且在结束前有一个吸引眼球的 square （即 <code>\qed</code>）。</p>
<ol>
<li>更多斜体和加粗体 run-in 标题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;definition&#125; &lt;text&gt; \end&#123;definition&#125;</span><br><span class="line">\begin&#123;example&#125; &lt;text&gt; \end&#123;example&#125; </span><br><span class="line">\begin&#123;exercise&#125; &lt;text&gt; \end&#123;exercise&#125; </span><br><span class="line">\begin&#123;note&#125; &lt;text&gt; \end&#123;note&#125; </span><br><span class="line">\begin&#123;problem&#125; &lt;text&gt; \end&#123;problem&#125; </span><br><span class="line">\begin&#123;question&#125; &lt;text&gt; \end&#123;question&#125; </span><br><span class="line">\begin&#123;remark&#125; &lt;text&gt; \end&#123;remark&#125; </span><br><span class="line">\begin&#123;solution&#125; &lt;text&gt; \end&#123;solution&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自定义的_Theorem-like_Environments">自定义的 Theorem-like Environments</h3><p>加强了标准的 <code>\newtheorem</code> 命令，得到两个新的命令 <code>\ spnewtheorem</code> 和 <code>\spnewtheorem*</code>，现在可以使用来定义新的语法。需要两个参数：type style 和 text style。type style 表示所出现的环境，text style 表示新环境的 text style。使用 <code>\ spnewtheorem</code> 的两种方法：</p>
<h4 id="第一种（推荐！）">第一种（推荐！）</h4><p>如果想与其他环境共享计数器，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;[&lt;num_like&gt;]&#123;&lt;caption&gt;&#125; &#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>[&lt;num_like&gt;]</code> 指定为想要共享的环境。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;mainth&#125;[theorem]&#123;Main Theorem&#125;&#123;\bfseries&#125;&#123;\itshape&#125; </span><br><span class="line">\begin&#123;theorem&#125; The early bird gets the worm. \end&#123;theorem&#125; </span><br><span class="line">\begin&#123;mainth&#125; The early worm gets eaten. \end&#123;mainth&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theorem <span class="number">3.</span> The early bird gets the worm. </span><br><span class="line">Main Theorem <span class="number">4.</span> The early worm gets eaten.</span><br></pre></td></tr></table></figure>
<h4 id="第二种">第二种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;[&lt;within&gt;]</span><br><span class="line">&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会定义一个名为 <code>&lt;env_name&gt;</code> 的环境，它以 <code>&lt;cap_font&gt;</code> 打印标题 <code>&lt;caption&gt;</code>， 它以 <code>&lt;body_font&gt;</code> 打印文本。在每个新 section 指定 <code>&lt;within&gt;</code> 时，会重新编号。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;joke&#125;&#123;Joke&#125;[subsection]&#123;\bfseries&#125;&#123;\rmfamily&#125;</span><br></pre></td></tr></table></figure>
<p>deﬁnes a new environment called joke which prints the caption Joke in boldface and the text in roman. The jokes are numbered starting from 1 at the beginning of every subsection with the number of the subsection preceding the number of the joke e.g. 7.2.1 for the ﬁrst joke in subsection 7.2.</p>
<h4 id="Unnumbered_Environments">Unnumbered Environments</h4><p>如果想要非编号环境，使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem*&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序代码">程序代码</h3><p>可以使用 verbatim 环境或者 LATEX 的 verbatim package。</p>
<p>文章示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;Hamiltonian Mechanics&#125;</span><br><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line">\institute&#123;Princeton University, Princeton NJ <span class="number">08544</span>, USA</span><br><span class="line">\and </span><br><span class="line">Universit\’&#123;e&#125; de Paris-Sud, </span><br><span class="line">Laboratoire d’Analyse Num\’&#123;e&#125;rique, B\^&#123;a&#125;timent <span class="number">425</span>,\\</span><br><span class="line">F-<span class="number">91405</span> Orsay Cedex, France&#125;</span><br><span class="line"></span><br><span class="line">\maketitle </span><br><span class="line">% </span><br><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">This paragraph shall summarize the contents of the paper in <span class="keyword">short</span> terms. </span><br><span class="line">\end&#123;abstract&#125; </span><br><span class="line">%</span><br><span class="line">\section&#123;Fixed-Period Problems: The Sublinear Case&#125; </span><br><span class="line">% </span><br><span class="line">With <span class="keyword">this</span> chapter, the preliminaries are over, and we begin the search <span class="keyword">for</span> periodic solutions \dots </span><br><span class="line">% </span><br><span class="line">\subsection&#123;Autonomous Systems&#125; </span><br><span class="line">% </span><br><span class="line">In <span class="keyword">this</span> section we will consider the <span class="keyword">case</span> when the Hamiltonian </span><br><span class="line">$H(x)$ \dots </span><br><span class="line">% </span><br><span class="line">\subsubsection*&#123;The General Case: Nontriviality.&#125; </span><br><span class="line">% </span><br><span class="line">We assume that $H$ is </span><br><span class="line">$\left(A_&#123;\infty&#125;, B_&#123;\infty&#125;\right)$-subqua\-dra\-tic </span><br><span class="line">at infinity, <span class="keyword">for</span> some constant \dots </span><br><span class="line">% </span><br><span class="line">\paragraph&#123;Notes and Comments.&#125; </span><br><span class="line">The first results on subharmonics were \dots </span><br><span class="line">% </span><br><span class="line">\begin&#123;proposition&#125;</span><br><span class="line">Assume $H’(<span class="number">0</span>)=<span class="number">0</span>$ and $ H(<span class="number">0</span>)=<span class="number">0</span>$. Set \dots </span><br><span class="line">\end&#123;proposition&#125; </span><br><span class="line">\begin&#123;proof&#125;[of proposition] </span><br><span class="line">Condition (<span class="number">8</span>) means that, <span class="keyword">for</span> every $\delta’&gt;\delta$, there is </span><br><span class="line">some $\varepsilon&gt;<span class="number">0</span>$ such that \dots \qed </span><br><span class="line">\end&#123;proof&#125; </span><br><span class="line">% </span><br><span class="line">\begin&#123;example&#125;[\rmfamily (External forcing)] </span><br><span class="line">Consider the system \dots </span><br><span class="line">\end&#123;example&#125; </span><br><span class="line">\begin&#123;corollary&#125; </span><br><span class="line">Assume $H$ is $C^&#123;<span class="number">2</span>&#125;$ and </span><br><span class="line">$\left(a_&#123;\infty&#125;, b_&#123;\infty&#125;\right)$-subquadratic </span><br><span class="line">at infinity. Let \dots </span><br><span class="line">\end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; </span><br><span class="line">Assume that $H$ is $C^&#123;<span class="number">2</span>&#125;$ on $\bbbr^&#123;<span class="number">2</span>n&#125;\backslash \&#123;<span class="number">0</span>\&#125;$ </span><br><span class="line">and that $H’’(x)$ is \dots </span><br><span class="line">\end&#123;lemma&#125; </span><br><span class="line">\begin&#123;theorem&#125;[(Ghoussoub-Preiss)] </span><br><span class="line">Let $X$ be a Banach Space and $\Phi:X\to\bbbr$ \dots</span><br><span class="line">\end&#123;theorem&#125; </span><br><span class="line">\begin&#123;definition&#125; </span><br><span class="line">We shall say that a $C^&#123;<span class="number">1</span>&#125;$ function $\Phi:X\to\bbbr$ </span><br><span class="line">satisfies \dots </span><br><span class="line">\end&#123;definition&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例如下图，或<a href="http://www.springer.com/computer/lncs/lncs+authors" target="_blank" rel="external">官网</a>下载查看</p>
<p><img src="/images/paper_sample.png" alt=""></p>
<h3 id="文本优化">文本优化</h3><table>
<thead>
<tr>
<th>文本优化</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\,</td>
<td>产生一个小型空格。例如在数字之间</td>
</tr>
<tr>
<td>—</td>
<td>产生一个横杠。前后无空格</td>
</tr>
<tr>
<td>&nbsp;—&nbsp;</td>
<td>产生一个横杠。前后各一空格</td>
</tr>
<tr>
<td>-</td>
<td>连字符。前后无空格</td>
</tr>
<tr>
<td>$-$</td>
<td>负号。只在文本中使用</td>
</tr>
</tbody>
</table>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>\,$^&#123;\circ&#125;$C etc., </span><br><span class="line">Dr h.\,c.\,Rockefellar-Smith \dots </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>\,km and Prof.\,Dr Mallory \dots </span><br><span class="line"><span class="number">1950</span>--<span class="number">1985</span> \dots </span><br><span class="line"><span class="keyword">this</span> -- written on a computer -- is now printed </span><br><span class="line">$-<span class="number">30</span>$\,K \dots</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>◦C etc., Dr h.c.Rockefellar-Smith ... </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>km and Prof.Dr Mallory ... </span><br><span class="line"><span class="number">1950</span>–<span class="number">1985</span> ... </span><br><span class="line"><span class="keyword">this</span> – written on a computer – is now printed </span><br><span class="line">−<span class="number">30</span>K ...</span><br></pre></td></tr></table></figure>
<h3 id="特殊字体">特殊字体</h3><p>普通的字体类型（Roman）不需要代码。斜体 (<code>{\em &lt;text&gt;}</code> 或 <code>\emph{&lt;text&gt;}</code>)，如果需要，黑体用于强调：</p>
<table>
<thead>
<tr>
<th>特殊字体</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{\itshape Text}</code></td>
<td>斜体文本</td>
</tr>
<tr>
<td><code>{\em &lt;text&gt;}</code></td>
<td>强调的文本</td>
</tr>
<tr>
<td><code>{\bfseries Text}</code></td>
<td>重要文本</td>
</tr>
<tr>
<td><code>\vec{Symbol}</code></td>
<td>向量只能出现在 math mode。如 <code>$\vec{A \times B\cdot C}</code> 得到 <code>A×B ·C</code></td>
</tr>
</tbody>
</table>
<h3 id="Footnotes">Footnotes</h3><p>注脚应该被包含在下面代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\footnote&#123;Text&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote\footnote&#123;The footnote is automatically numbered.&#125; and text continues ...</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote^<span class="number">4</span> and text continues ...</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125; </span><br><span class="line">  \item First item </span><br><span class="line">  \item Second item </span><br><span class="line">  \begin&#123;enumerate&#125; </span><br><span class="line">    \item First nested item </span><br><span class="line">    \item Second nested item </span><br><span class="line">  \end&#123;enumerate&#125; \item </span><br><span class="line">  Third item </span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First item </span><br><span class="line">2. 2. Second item </span><br><span class="line">   (a) First nested item</span><br><span class="line">   (b) Second nested item </span><br><span class="line">3. Third item</span><br></pre></td></tr></table></figure>
<h3 id="插图">插图</h3><p>图片应该插入到第一次提到该图片的段落后（不是段落中），它会被自动编号。图片应该是 PostScript 文件——最好是 EPS 数据，通过 epsfig package 生成。</p>
<p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;x cm&#125; </span><br><span class="line">\caption[ ]&#123;...text of caption...&#125; (Do type [ ]) </span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><code>x</code>表示图片的高度。 </p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;<span class="number">2.5</span>cm&#125; </span><br><span class="line">\caption&#123;This is the caption of the figure displaying a white eagle and a white horse on a snow field&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多请参见 LATEX 文档 p. 26 ff. 和 p. 204</p>
</blockquote>
<h3 id="表格">表格</h3><h4 id="使用_LATEX_编写表格">使用 LATEX 编写表格</h4><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125; </span><br><span class="line">\caption&#123;Critical $N$ values&#125; </span><br><span class="line">\begin&#123;tabular&#125;&#123;llllll&#125; </span><br><span class="line">\hline\noalign&#123;\smallskip&#125;</span><br><span class="line">$&#123;\mathrm M&#125;_\odot$ &amp; $\beta_&#123;<span class="number">0</span>&#125;$ &amp; $T_&#123;\mathrm c6&#125;$ &amp; $\gamma$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm L&#125;$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm&#123;Te&#125;&#125;$\\ </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">\hline </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">  <span class="number">30</span> &amp; <span class="number">0.82</span> &amp; <span class="number">38.4</span> &amp; <span class="number">35.7</span> &amp; <span class="number">154</span> &amp; <span class="number">320</span> \\ </span><br><span class="line">  <span class="number">60</span> &amp; <span class="number">0.67</span> &amp; <span class="number">42.1</span> &amp; <span class="number">34.7</span> &amp; <span class="number">138</span> &amp; <span class="number">340</span> \\ </span><br><span class="line">  <span class="number">120</span> &amp; <span class="number">0.52</span> &amp; <span class="number">45.1</span> &amp; <span class="number">34.0</span> &amp; <span class="number">124</span> &amp; <span class="number">370</span> \\ </span><br><span class="line">\hline </span><br><span class="line">\end&#123;tabular&#125; </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="/images/table_sample.png" alt=""></p>
<h4 id="不使用_LATEX">不使用 LATEX</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\caption&#123;text of your caption&#125; </span><br><span class="line">\vspace&#123;x cm&#125; % the actual height needed <span class="keyword">for</span> your table </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Signs_and_Characters">Signs and Characters</h4><p>更多请参见原文档和 LATEX 官方文档 pp.41 ff.</p>
<h4 id="参考文献">参考文献</h4><p>有三种参考文献模式：number only，letter-number， 或 author-year。更多请参见 LATEX 官方文档 p. 71.<br>LLNCS 有一种特殊的 BIBTEX 格式，使用class： splncs.bst。调用代码 <code>\bibliographystyle{splncs}</code>。<br>如果打算使用 author BIBTEX style，请指定 <code>[oribibl]</code> 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[oribibl]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Letter-Number_或_Number_Only">Letter-Number 或 Number Only</h4><p>在文章中使用 <code>\cite</code> 命令来引用文章，会得到形如：[1]，[E1, S2], [P1] 中之一的格式，这取决于  thebibliography 环境中 <code>\bibitem</code> 的使用。</p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;[MT1]&#125; </span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[CE1]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>会产生类似的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CE1] Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">[CE2] Clarke, F., Ekeland, I.: Solutions p´eriodiques, du p´eriode donn´ee, des ´equations hamiltoniennes. Note CRAS Paris <span class="number">287</span>, <span class="number">1013</span>–<span class="number">1015</span> (<span class="number">1978</span>)</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of \cite&#123;clar:eke&#125;;</span><br></pre></td></tr></table></figure>
<p>会得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of [CE1];</span><br></pre></td></tr></table></figure>
<p><strong>Number-Only System</strong></p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;<span class="number">1</span>&#125; </span><br><span class="line">\bibitem &#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\cite&#123;n1,n3,n2,n3,n4,n5,foo,n1,n2,n3,?,n4,n5&#125;</span><br></pre></td></tr></table></figure>
<p>能够得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>-<span class="number">5</span>,foo,<span class="number">1</span>-<span class="number">3</span>,?,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Author-Year_System">Author-Year System</h4><p>效果就像这样：<code>(Smith 1970,1980),(Ekelandetal.1985,Theorem2),(JonesandJffe 1986; Farrow 1988, Chap.2)</code>。如果名字作为句子的一部分，那么括号内就可能只出现年份，如，<code>Ekeland et al. (1985, Sect.2.1)</code>。</p>
<p>如果有几个文章属于同一（多）个作者，引用时应列在适当的顺序，表示如下：</p>
<ol>
<li>一个作者：按文章时间排序；</li>
<li>相同的合作作者：按文章时间排序；</li>
<li>和不同的合作作者：按合作作者名字进行字母排序；</li>
</ol>
<p>如果，有多个同样的作者同样的时间的文章，用 “a”, “b”, “c”, etc 区分。</p>
<p><strong>How to Code Author-Year System</strong></p>
<p>要使用这个系统，则需指定 <code>[citeauthoryear]</code> 参数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[citeauthoryear]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;&#125; % (<span class="keyword">do</span> not forget &#123;&#125;)</span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[<span class="number">1982</span>]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>产生样例：<br>cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>)</span><br></pre></td></tr></table></figure></p>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(\cite&#123;clar:eke&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>产生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(<span class="number">1982</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>END. </p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="LLNCS" scheme="http://bluestein.github.io/tags/LLNCS/"/>
    
      <category term="LaTeX" scheme="http://bluestein.github.io/tags/LaTeX/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="LaTex" scheme="http://bluestein.github.io/categories/Odds-Ends/LaTex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[顺序容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-sequential_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-sequential_container/</id>
    <published>2016-01-02T10:46:49.000Z</published>
    <updated>2016-03-05T02:37:36.895Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>顺序容器</strong></td>
<td>-</td>
</tr>
<tr>
<td>vector</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td>list</td>
<td>支持快速插入删除</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列</td>
</tr>
<tr>
<td><strong>顺序容器适配器</strong></td>
<td>-</td>
</tr>
<tr>
<td>stack</td>
<td>后进先出（LIFO）</td>
</tr>
<tr>
<td>queue</td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td>priority_queue</td>
<td>有优先级管理的队列</td>
</tr>
</tbody>
</table>
<h3 id="顺序容器的定义">顺序容器的定义</h3><p>首先必须包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>所有顺序容器都是类模板</strong>。要定义某种特殊的容器，必须在容器名后添加一对尖括号，尖括号内提供容器将要存放元素的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="built_in">deque</span>&lt;Sales_item&gt; item;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有容器都有默认构造函数，该构造函数不带任何参数</p>
</blockquote>
<h4 id="初始化">初始化</h4><p>除了默认构造函数，容器类型还提供了其他的构造函数，可以指定其元素的初值</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C<t> c;</t></td>
<td>创建名为 c 的容器。<br>C 为容器名，如 vector。<br>T为元素类型，如string，int。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c2(c1)</td>
<td>创建容器 c1 的副本。<br>c2 和 c1 必须是相同类型的容器，并存放相同类型的元素。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(begin, end)</td>
<td>使用迭代器 begin 和 end 范围内的元素创建 c。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(n, t)</td>
<td>用 n 个值为 t 的元素创建容器。<br>t 必须与容器存放的类型匹配，或者可以转化为该类型的值。<br><strong>只适用于顺序容器</strong></td>
</tr>
<tr>
<td>C c(n)</td>
<td>创建 n 个默认初始值的容器。<br><strong>只适用于顺序容器</strong></td>
</tr>
</tbody>
</table>
<p><strong>初始化为另一个容器的副本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(ivec1); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(ivec1); <span class="comment">// error: ivec is not list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dvec(ivec); <span class="comment">// error: ivec holds int not double</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化为另一容器的部分元素</strong></p>
<p>允许通过传递一对迭代器来初始化容器。使用迭代器时，不需要容器类型相同，容器内的元素类型可以不同，只要相容即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator mid = svec.begin() + svec.size() / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; front(svec.begin(), mid);</span><br></pre></td></tr></table></figure>
<p>因为指针就是迭代器，所以可以用数组中的值对容器进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *words1[] = &#123;<span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(words1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; words2(words1, words1 + sz);</span><br></pre></td></tr></table></figure>
<p><strong>初始化指定数目的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>都是 10 个元素的 list，<code>slist</code> 的每个值初始化为 <strong>hi</strong>， <code>ilist</code> 每个值初始化为 <strong>0</strong>。</p>
<blockquote>
<p>只有当元素类型有默认构造函数时才可以使用 <code>C c(n)</code> 的方式初始化。例如上面的 int 默认初始化为 0。</p>
</blockquote>
<p><strong>容器的容器</strong></p>
<p>支持容器的容器，不过要注意使用空格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; lines; <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; lines; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>否则被认为是右移操作。</p>
<h3 id="迭代器和迭代器的范围">迭代器和迭代器的范围</h3><p>标准库为所有容器类提供的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>解引用</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>解引用，获取指定名为 member 的成员，等价于 (*iter).member</td>
</tr>
<tr>
<td>++iter<br>iter++</td>
<td>使iter指向后一个元素</td>
</tr>
<tr>
<td>–iter<br>iter–</td>
<td>使iter指向前一个元素</td>
</tr>
<tr>
<td>iter1 == iter2<br>iter1 != iter2</td>
<td>比较是否相等</td>
</tr>
</tbody>
</table>
<h4 id="vector,_deque额外的操作">vector, deque额外的操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n<br>iter - n</td>
<td>使iter指向后（前） n 个元素</td>
</tr>
<tr>
<td>iter1 += iter2<br>iter1 -= iter2<br>iter1 - iter2</td>
<td>迭代器运算</td>
</tr>
<tr>
<td>&gt;, &gt;=, &lt;, &lt;=</td>
<td>关系操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只适用于 vector 和 deque</p>
</blockquote>
<h3 id="顺序容器的操作">顺序容器的操作</h3><p>每种顺序容器都有以下操作</p>
<ol>
<li>向容器添加元素</li>
<li>删除元素</li>
<li>设置容器大小</li>
<li>获取容器第一个或最后一个元素（如果有的话）</li>
</ol>
<h4 id="为容器定义的类型别名">为容器定义的类型别名</h4><table>
<thead>
<tr>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>无符号整型，足以存储此容器类型的最大可能长度</td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器</td>
</tr>
<tr>
<td>const_iterator</td>
<td>只读类型迭代器</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>逆序寻址的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>只读逆序寻址的迭代器</td>
</tr>
<tr>
<td>difference_type</td>
<td>足够存储两迭代器差值的有符号整型，可为负值</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型，是 value_type&amp; 的同义词</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的常量左值类型，等价于 const value_type&amp;</td>
</tr>
</tbody>
</table>
<h4 id="begin_和_end_成员">begin 和 end 成员</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.begin()</td>
<td>返回一个迭代器，指向容器的第一个元素</td>
</tr>
<tr>
<td>c.end()</td>
<td>返回一个迭代器，指向容器最后一个元素的后面一个位置</td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>逆序迭代器，指向容器的最后一个元素</td>
</tr>
<tr>
<td>c.rend()</td>
<td>返回一个逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
</tbody>
</table>
<h4 id="添加元素">添加元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)</td>
<td>在容器尾部添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.push_front(t)</td>
<td>在容器前端添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, t)</td>
<td>在迭代器p所指元素的前面插入一个值为 t 的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p, n, t)</td>
<td>在迭代器p所指元素的前面插入 n 个值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, begin, end)</td>
<td>在迭代器p所指元素的前面插入迭代器 begin 和 end 范围内的元素，返回 void 类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>迭代器可能会失效。指向新加入元素后面的那个元素的迭代器会失效</p>
</blockquote>
<h4 id="关系操作符">关系操作符</h4><p>要使用类型相同的进行比较</p>
<ol>
<li>如果两容器有相同长度并且所有元素相等，则两个容器相等；</li>
<li>如果两容器有不同长度，但较短容器的元素等于较长容器的子序列，则短容器小于长容器；</li>
<li>如果不存在子序列，则比较第一个不同的元素；</li>
</ol>
<h4 id="容器大小">容器大小</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.size()</td>
<td>返回容器 c 中的元素个数，类型为 c::size_type</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>最多可容纳个数</td>
</tr>
<tr>
<td>c.empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>c.resize(n)</td>
<td>调整 c 的大小，容量为 n</td>
</tr>
<tr>
<td>c.resize(n, t</td>
<td>调整 c 的大小，容量为 n，所有新添加的元素值为 t</td>
</tr>
</tbody>
</table>
<h4 id="访问元素">访问元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回 c 的最后一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回 c 的第一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
<tr>
<td>c.at(n)</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
</tbody>
</table>
<p>back 和 front 同样可以用 end 和 begin 迭代器的解引用完成。</p>
<h4 id="删除元素">删除元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器 p 所指元素。<br>返回被删除元素的后一个位置，或最后一个元素的下一个位置</td>
</tr>
<tr>
<td>c.erase(begin, end)</td>
<td>不越界的情况下，删除 begin 和 end 范围内的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 内所有元素，返回 void</td>
</tr>
<tr>
<td>c.pop_back()</td>
<td>删除最后一个元素，返回 void</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除第一个元素，返回 void<br><strong>只适用于 list 和 deque 类型</strong></td>
</tr>
</tbody>
</table>
<h4 id="赋值和交换">赋值和交换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>将 c2 的内容赋值给 c1。会删除 c1 的内容</td>
</tr>
<tr>
<td>c1.swap(c2)</td>
<td>交换 c1 和 c2 的内容</td>
</tr>
<tr>
<td>c.assign(begin, end)</td>
<td>重设 c，把 begin 和 end 范围内的元素赋给 c</td>
</tr>
<tr>
<td>c.assign(n, t)</td>
<td>重设 c 为 n 个值为 t 的元素</td>
</tr>
</tbody>
</table>
<p>assign 会删除原容器中的元素，然后将所指定的新元素插入到该容器中。如果两个容器类型相同，就可以使用赋值操作符将一个容器赋值给另一个容器。如果在不同容器中，元素类型不同但相互兼容，那么必须使用 assign 函数。</p>
<h3 id="vector容器的自增长">vector容器的自增长</h3><p>vector 以连续的方式存储每一个元素，一个挨着一个。所以当在超过预申请内存时再插入元素时，必须重新申请空间，然后将旧元素赋值到新空间中。此时就要用到 capacity 和 reserve，capacity 表示在必须重新非配空间之前可以存储元素的个数，一般由标准库定义，至少等于容器的大小，但一般来说会更大一些；而 reserve 表示人工预留存储空间（类似于数组大小的声明），当使用过程中超过人工预留空间后，vector会自己重新分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.push_back(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="容器的选择">容器的选择</h3><p>元素是否连续存储会显著的影响：</p>
<ol>
<li>在容器内部位置添加或删除元素；</li>
<li>执行元素的随机访问的代价；</li>
</ol>
<h4 id="插入操作影响容器的选择">插入操作影响容器的选择</h4><ol>
<li>list 存储在不连续的空间，允许向前向后逐个遍历，<strong>在任何位置可以高效的 insert 和 erase</strong>。不过它不支持随机访问，必须遍历涉及到的元素。</li>
<li>vector 存储在连续区域，除了在尾部插入（删除），其他任何位置插入（删除）时都必须移动其后面的元素。</li>
<li>deque 更加复杂，在两段插入和删除都非常快，但在内部差入或删除时代价会更高。它还同时提供了 list 和 vector 的性质：<ol>
<li>与 vector 一样，在容器内部 insert 和 erase 效率较低；</li>
<li>不同于 vector，deque 可以高效的实现首尾的 insert 和 erase；</li>
<li>deque 支持所有元素的随机访问；</li>
<li>deque 首尾插入不会使任何迭代器失效，而在首尾删除元素时，会使指向被删除元素的迭代器失效。在其他位置插入或删除都会使所有迭代器失效；</li>
</ol>
</li>
</ol>
<h4 id="访问影响">访问影响</h4><p>vector 和 deque 都支持高效的随机访问，而 list 只能顺序的跟随指针，一直遍历。</p>
<h4 id="建议">建议</h4><ol>
<li>要求随机访问，使用 vector 或 deque；</li>
<li>要求内部插入（删除）元素，选择 list；</li>
<li>如果在首部或尾部插入（删除），则选择 deque；</li>
<li>如果只需在输入时在容器中间插入元素，然后需要随机访问。可以考虑输入时存放到 list 中，接着对其排序，然后将其复制到 vector 中；</li>
<li>如果既需要中间插入元素又要随机访问，则选择容器时，考虑下面两种操作的相对代价：<ol>
<li>随机访问 list 的代价；</li>
<li>在 vector 或 deque 内部插入（删除）元素的代价；</li>
</ol>
</li>
</ol>
<h3 id="深入string类型">深入string类型</h3><p>除了前面用过的操作外，string 类型还支持大多数顺序容器操作。在某些方面可将 string 类型视为字符容器，操作也与 vector 类似，不过 string 不支持以栈方式操作容器：即 string 不能使用 front, back, pop_back等操作。下表扼要的介绍了一些 string 的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s;</td>
<td>定义一个空对象</td>
</tr>
<tr>
<td>string s(cp);</td>
<td>定义一个对象，并用 cp 指向的 c 风格的字符串初始化</td>
</tr>
<tr>
<td>string s2(s1);</td>
<td>初始化为s1的副本</td>
</tr>
<tr>
<td>is &gt;&gt; s;</td>
<td>从输入流 is 中读取一个以空白符分隔的字符串，存入 s</td>
</tr>
<tr>
<td>os &lt;&lt; s;</td>
<td>将 s 写到输出流 os</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从输入流 is 中读取一行字符，写入 s</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>将 s1 和 s2 串接起来，产生一个新的 string 对象</td>
</tr>
<tr>
<td>s1 += s2</td>
<td>将 s2 拼接到 s1 后面</td>
</tr>
<tr>
<td>关系操作符</td>
<td>相等运算（== 和 !=）及关系运算（&lt;, &lt;=, &gt;, &gt;=）都可用于 string 对象的比较。等效于（区分大小写）字典次序的比较</td>
</tr>
</tbody>
</table>
<p>string 支持的容器操作有：</p>
<ol>
<li>迭代器类型；</li>
<li>容器的构造函数（参考<a href="#初始化">前面</a>），但是不包含只需一个长度参数的构造函数；</li>
<li>跟 vector 一样的添加元素的操作。无论是 vector 还是 string 都不支持 push_front；</li>
<li>支持长度操作。resize, size, reserve 等；</li>
<li>支持下标和 at 操作；</li>
<li>支持 begin 和 end 操作；</li>
<li>支持 erase 和 clear 操作。但是不支持 pop_back 或 pop_front 操作；</li>
<li>支持<a href="#赋值和交换">前面</a>表中的赋值操作；</li>
<li>与vector容器一样，string也是连续存储的，因此也支持 capacity 和 reserve 操作；</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hey!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::iterator iter = s.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != s.end()) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造_string_对象">构造 string 对象</h4><p>string 几乎支持<a href="#初始化">前面</a>所有的构造函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2(5, 'a'); // s2 == "aaaaa"</span><br><span class="line">string s3(s2); // s3 是 s2 的副本</span><br><span class="line">string s4(s3.begin(),</span><br><span class="line">		s3.begin() + s3.size() / 2); // s4 == "aa"</span><br><span class="line"></span><br><span class="line">char *cp = "hey!";</span><br><span class="line">char carr[] = "Hello!";</span><br><span class="line">char no_null[] = &#123;'H', 'i'&#125;;</span><br><span class="line">string ss1(cp); // ss1 == "hey!"</span><br><span class="line">string ss2(carr,5); // ss2 == "Hello"</span><br><span class="line">string ss3(carr + 2, 3); // ss3 == "llo"</span><br><span class="line">string ss4(no_null); // runtime_error: 没有 null 结束符</span><br><span class="line">string ss5(no_null, 2); // ok</span><br></pre></td></tr></table></figure>
<p>构造 string 对象的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td>创建用 cp 所指数组的前 n 个字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos)</td>
<td>创建从 s1 的 pos 位置开始的字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos, len)</td>
<td>创建 s1 的 pos 位置开始长为 len 的字符的副本</td>
</tr>
</tbody>
</table>
<blockquote>
<p>n, len, pos 都是 unsigned 值。</p>
</blockquote>
<h4 id="修改string对象">修改string对象</h4><p><strong>与容器共有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, t)</td>
<td>在迭代器 pos 前插入一个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, n, t)</td>
<td>在迭代器 pos 前插入 n 个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, begin, end)</td>
<td>在迭代器 pos 前插入迭代器 begin 到 end 之间的值</td>
</tr>
<tr>
<td>s.assign(begin, end)</td>
<td>用迭代器 begin 到 end 之间的值重新初始化 s</td>
</tr>
<tr>
<td>s.assign(n, t)</td>
<td>用 n 个 t 值重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos)</td>
<td>删除迭代器 pos 所指元素</td>
</tr>
<tr>
<td>s.erase(begin, end)</td>
<td>删除迭代器 begin 到 end 之间的值</td>
</tr>
</tbody>
</table>
<p><strong>string 特有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, n, c)</td>
<td>在下标 pos 前插入 n 个值为 c 的字符</td>
</tr>
<tr>
<td>s.insert(pos, s1)</td>
<td>在下标 pos 前插入一个 s1 的副本</td>
</tr>
<tr>
<td>s.insert(pos, s1, pos1, len)</td>
<td>在下标 pos 前插入 s1 中从 pos1 开始长为 len 的子字符串</td>
</tr>
<tr>
<td>s.insert(pos, cp, len)</td>
<td>在下标 pos 前插入 cp 所指的数组前 n 个字符</td>
</tr>
<tr>
<td>s.insert(pos, cp)</td>
<td>在下标 pos 前插入 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>s.assign(s1)</td>
<td>用 s1 重新初始化 s</td>
</tr>
<tr>
<td>s.assign(s1, pos1, len)</td>
<td>用 s1 中下标 pos1 开始长为 len 的子串重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp, len)</td>
<td>用 cp 所指的数组前 len 个元素重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp)</td>
<td>用 cp 所指以 null 结束的字符数组重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除从下标 pos 开始 len 个字符</td>
</tr>
</tbody>
</table>
<h3 id="只适用于_string_的操作">只适用于 string 的操作</h3><ol>
<li>substr 函数；</li>
<li>append 和 replace</li>
<li>find</li>
</ol>
<h4 id="substr">substr</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos, n)</td>
<td>返回从 pos 开始的 n 个字符</td>
</tr>
<tr>
<td>s.substr(pos)</td>
<td>返回从位置 pos 开始到结尾的字符</td>
</tr>
<tr>
<td>s.substr()</td>
<td>返回 s 的副本</td>
</tr>
</tbody>
</table>
<h4 id="append_和_replace">append 和 replace</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.append(args)</td>
<td>将 args 拼接在 s 后。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(pos, len, args)</td>
<td>删除 pos 开始的 len 个字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(begin, end, args)</td>
<td>删除 begin 到 end 之间的字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1</td>
<td>字符串 s1</td>
</tr>
<tr>
<td>s1, pos1, len1</td>
<td>s1 子串</td>
</tr>
<tr>
<td>cp</td>
<td>cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, len1</td>
<td>cp 所指以 null 结束的字符数组前 len1 个元素</td>
</tr>
<tr>
<td>n, c</td>
<td>n 个 字符 c</td>
</tr>
<tr>
<td>begin1, end1</td>
<td>迭代器 begin1 和 end1 间的字符</td>
</tr>
</tbody>
</table>
<h4 id="find">find</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找 s 中 args 第一次出现</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找 s 中 args 最后一次出现</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>查找 s 中 args 的任意字符第一次出现</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>查找 s 中 args 的任意字符最后一次出现</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找 s 中第一个不属于 args 的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>查找 s 中最后一个不属于 args 的字符</td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c, pos</td>
<td>在 s 中从 pos 开始查找字符 c</td>
</tr>
<tr>
<td>s1, pos</td>
<td>在 s 中从 pos 开始查找 string 对象 s1</td>
</tr>
<tr>
<td>cp, pos</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, pos, n</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组前 n 个字符</td>
</tr>
</tbody>
</table>
<h4 id="string_对象的比较">string 对象的比较</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.compare(s1)</td>
<td>s 与 s1比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1, pos1, n1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 从 pos1 开始长为 n1 的子串比较</td>
</tr>
<tr>
<td>s.compare(cp)</td>
<td>s 与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp)</td>
<td>s 从 pos 开始长为 n 的子串与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp, n1)</td>
<td>s  从 pos 开始长为 n 的子串与 cp 所指数组前 n1 的子串比较</td>
</tr>
</tbody>
</table>
<h3 id="容器适配器">容器适配器</h3><p>标准库提供三种顺序容器适配器：queue, priority_queue, stack。</p>
<p><strong>初始化</strong></p>
<p>肯定需要包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deq 是 deque&lt;int&gt; 类型</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk(deq);</span><br></pre></td></tr></table></figure>
<p><strong>覆盖适配器的基础容器类型</strong></p>
<p>默认情况下，stack 和 queue 都基于 deque 实现，priority_queue 则基于 vector 实现。通过将一个顺序容器指定为适配器的第二个实参，可以覆盖基础容器类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on vector</span></span><br><span class="line"><span class="built_in">stack</span>&lt; <span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str_stk;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两个相同类型的适配器可以做关系运算，第一个不对等的元素决定大于或小于关系。</p>
</blockquote>
<h4 id="栈适配器">栈适配器</h4><p>栈的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stk.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>stk.size()</td>
<td>返回栈中元素个数</td>
</tr>
<tr>
<td>stk.pop()</td>
<td>删除栈顶元素，但不返回其值</td>
</tr>
<tr>
<td>stk.top()</td>
<td>返回栈顶元素，但不删除其值</td>
</tr>
<tr>
<td>stk.push(item)</td>
<td>将 item 压入栈</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;::size_type sz = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; istk;</span><br><span class="line">	<span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.size() != sz)</span><br><span class="line">	&#123;</span><br><span class="line">		istk.push(ix++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> error_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = istk.top();</span><br><span class="line">		<span class="keyword">if</span> (value != --ix)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; <span class="string">"expected "</span> &lt;&lt; ix &lt;&lt; <span class="string">"recieved "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">			++error_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		istk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"errors: "</span> &lt;&lt; error_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">errors: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="queue_和_priority_queue">queue 和 priority_queue</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>q.size()</td>
<td>返回队列中元素个数</td>
</tr>
<tr>
<td>q.pop()</td>
<td>删除队首元素，但不返回其值</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回队首元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.back()</td>
<td>返回队尾元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.top()</td>
<td>返回优先级最高的元素，但不删除其值。<strong>只适用于priority_queue</strong></td>
</tr>
<tr>
<td>q.push(item)</td>
<td>queue： 将 item 压入队尾<br>priority_queue：基于优先级压入队列</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex9.9]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-11/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-11/</id>
    <published>2016-01-02T06:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.942Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s[] = &#123; <span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span> &#125;;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(s, s + <span class="number">3</span>); </span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = --slist.end();</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cnt &lt; sz) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (++cnt &lt; sz) &#123;</span><br><span class="line">			--iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hey</span></span><br><span class="line"><span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
</feed>
