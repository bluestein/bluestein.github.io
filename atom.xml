<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo's Blog]]></title>
  <subtitle><![CDATA[Everything will be ok]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2015-12-20T14:01:33.141Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[swift: functions]]></title>
    <link href="http://bluestein.github.io/2015/12/swift-functions/"/>
    <id>http://bluestein.github.io/2015/12/swift-functions/</id>
    <published>2015-12-20T11:53:33.000Z</published>
    <updated>2015-12-20T14:01:33.141Z</updated>
    <content type="html"><![CDATA[<p><strong>defining and calling</strong></p>
<p>以定义一个 <code>sayHello(_:)</code> 函数作为例子：该函数将一个人的名字作为输入，以一句问候作为返回值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	<span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<ul>
<li>输入类型: <code>String</code></li>
<li>返回值类型： <code>String</code><blockquote>
<p>说明： 函数的定义，以 <code>func</code> 作为关键字，后面跟该函数的名字，使用 <code>:</code> 指定参数的类型， <code>-&gt;</code> 指定返回值的类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Anna"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Anna!"</span></span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Brian"</span>))</span><br><span class="line"><span class="comment">// prints "Hello, Brian!"</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>使用 <code>print(_:separator:terminator:)</code> 来打印输出。</p>
<p><strong>parameters and return values</strong><br>swift中的函数的参数和返回值可以是任何类型，甚至可以是函数类型（在swift中，函数也是一种类型，后面会讲到）。</p>
<p><strong>without parameters</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span> -&gt; string &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Hello World"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>multiple parameters</strong><br>多个参数时，用逗号隔开即可：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String, alreadyGreeted: Bool)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> already_greeted &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello again, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sayHello(personName)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(sayHello(<span class="string">"Tim"</span>, alreadyGreeted: <span class="literal">false</span>))</span><br></pre></td></tr></table></figure></p>
<p>调用的形式是 <code>sayHello(_:alreadyGreeted:)</code>，通常第一个参数名后面的所有参数名需要标明。</p>
<p><strong>without return value</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func sayBye(personName: String) &#123;</span><br><span class="line">	print("Goodbye, \(personName)!)</span><br><span class="line">&#125;</span><br><span class="line">sayBye("Dave")</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>严格地说，<code>sayBye(_:)</code> 还是有返回值的，为 <code>Void</code> 类型， 记作 <code>()</code>。</p>
</blockquote>
<p><strong>multiple return values</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">		<span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">			currentMin = value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">			currentMax = value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, -<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min: <span class="subst">\(bounds.<span class="built_in">min</span>)</span>, max: <span class="subst">\(bounds.<span class="built_in">max</span>)</span>."</span>)</span><br></pre></td></tr></table></figure></p>
<p>把多个返回值当成一个元组返回。<br>但如果，用户传入的数组为空则会出错，此时需要使用 <code>optional tuple</code>， 即 <code>(Int, Int)?</code>，上述程序改成：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">minMax</span><span class="params">(array: [Int])</span></span> -&gt; (<span class="built_in">min</span>: <span class="type">Int</span>, <span class="built_in">max</span>: <span class="type">Int</span>)? &#123;</span><br><span class="line">	<span class="keyword">if</span> array.isEmpty &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">	<span class="keyword">var</span> currentMin = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">var</span> currentMax = array[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> array[<span class="number">1</span>..&lt;array.<span class="built_in">count</span>] &#123;</span><br><span class="line">		<span class="keyword">if</span> value &lt; currentMin &#123;</span><br><span class="line">			currentMin = value</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> value &gt; currentMax &#123;</span><br><span class="line">			currentMax = value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (currentMin, currentMax)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, -<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> bounds = minMax(array)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"min: <span class="subst">\(bounds.<span class="built_in">min</span>)</span>, max: <span class="subst">\(bounds.<span class="built_in">max</span>)</span>."</span>)</span><br><span class="line"><span class="comment">// as above</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emptyArray = [<span class="type">Int</span>]()</span><br><span class="line"><span class="built_in">print</span>(minMax(emptyArray))</span><br><span class="line"><span class="comment">// prints "nil"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>functon names</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(fisrtParameterName: Int, secondParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>, secondParameterName: <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，省略了第一个参数额外参数，其他则使用 <code>local name</code> 作为 <code>external name</code></p>
<p><strong>external parameter names</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(externalParameterName localParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(externalParameterName: <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>omitting external names</strong><br>使用下划线 <code>_</code> 来替代，则调用时不用标明external names：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(fisrtParameterName: Int, <span class="number">_</span> secondParameterName: Int)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>default parameter values</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">someFuction</span><span class="params">(localParameterName: Int = <span class="number">12</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// function body goes here</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// calling</span></span><br><span class="line">someFuction(<span class="number">1</span>)</span><br><span class="line">someFuction()</span><br></pre></td></tr></table></figure></p>
<p><strong>variadic parameters</strong><br>参数个数可变的情况，在参数的类型后面使用 <code>...</code> 来表示该类型的参数可以不确定：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">arithmeticMean</span><span class="params">(numbers: Double...)</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> total: <span class="type">Double</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</span><br><span class="line">		total += number</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total / <span class="type">Double</span>(numbers.<span class="built_in">count</span>)</span><br><span class="line">&#125;</span><br><span class="line">arithmeticMean(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arithmeticMean(<span class="number">3</span>, <span class="number">1.5</span>, <span class="number">14.75</span>)</span><br></pre></td></tr></table></figure></p>
<p><strong>constant and variable parameter</strong><br>一般来说函数为常量参数，但也可以用变量参数。使用 <code>var</code> 来表明变量参数，这样就可以改变该变量的值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">alignRight</span><span class="params">(<span class="keyword">var</span> sting: String, totalLength: Int, pad: Character)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> amountToPad = totalLength - string.characters.<span class="built_in">count</span></span><br><span class="line">	<span class="keyword">if</span> amountToPad &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> string</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">let</span> padString = <span class="type">String</span>(pad)</span><br><span class="line">	<span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...amountToPad &#123;</span><br><span class="line">		string = padString + string</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> originalString = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">let</span> paddesString = alginRigth(originalString, totalLength: <span class="number">10</span>, pad: </span><br><span class="line"><span class="string">"-"</span>)</span><br><span class="line"><span class="comment">// prints "-----hello"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>in-out parameters</strong><br>上面所说的变量参数，只能在当前函数内可以改变它的值，如果想要永久改变一个值则需要需用 <code>inout</code> 关键字标明。并且调用时需要在变量前加上 <code>&amp;</code> 符号：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">	<span class="keyword">let</span> temporaryA = a</span><br><span class="line">	a = b</span><br><span class="line">	b = a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someInt = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> anotherInt = <span class="number">3</span></span><br><span class="line">swapTwoInts(&amp;someInt, &amp;anotherInt)</span><br></pre></td></tr></table></figure></p>
<p><strong>Function types</strong><br>swift把函数也当作一种类型看待，可以像 <code>Int</code> 那样进行操作：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">addTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a+ b</span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">multiplyTwoInts</span><span class="params">(a: Int, <span class="number">_</span> b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两个函数都可以记作为 <code>(Int, Int) -&gt; Int</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printHelloWorld</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>则可以看做 <code>() -&gt; Void</code>。</p>
<p><strong>using function type</strong><br>把 <code>addTwoInts</code> 函数当成是一种类型赋给 <code>mathFunction</code> 变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mathFunction: (<span class="type">Int</span>, <span class="type">Int</span>) -&gt; <span class="type">Int</span> = addTwoInts</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(<span class="number">1</span>, <span class="number">2</span>)</span>)"</span>)</span><br><span class="line"><span class="comment">// prints "Result: 3"</span></span><br></pre></td></tr></table></figure></p>
<p>前面说到， <code>addTwoInts</code> 和 <code>multiplyTwoInts</code> 函数在形式上是一致的，则下面代码也成立：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mathFunction = multiplyTwoInts</span><br></pre></td></tr></table></figure></p>
<p><strong>function types as parameter type</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">printMathResult</span><span class="params">(mathFunction: <span class="params">(Int, Int)</span></span></span> -&gt; int, <span class="number">_</span> a: <span class="type">Int</span>, <span class="number">_</span> b: <span class="type">Int</span>) &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"Result: <span class="subst">\(mathFunction(a, b)</span>)"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printMathResult(addTwoInts, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">prints <span class="string">"Result: 8"</span></span><br></pre></td></tr></table></figure></p>
<p>很容易看懂， <code>printMathResult(_:_:_:)</code> 函数有三个参数，分别是：<code>(Int, Int) -&gt; int</code>, <code>Int</code> 和 <code>Int</code>。</p>
<p><strong>function types as return types</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStep</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>显然 <code>chooseStep(:)</code> 函数使用 <code>(Int) -&gt; Int</code> 类型的函数作为返回值。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZearo = chooseStep(value &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="keyword">while</span> value != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>..."</span>)</span><br><span class="line">	value = moveNearerToZero(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 3...</span></span><br><span class="line"><span class="comment">// 2...</span></span><br><span class="line"><span class="comment">// 1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Nested function</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">chooseStep</span><span class="params">(backwards: Bool)</span></span> -&gt; (<span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">stepForward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> input + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="func"><span class="keyword">func</span> <span class="title">stepBackward</span><span class="params">(input: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> input - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> backwards ? stepBackward : stepForward</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = -<span class="number">4</span></span><br><span class="line"><span class="keyword">let</span> moveNearerToZearo = chooseStep(value &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Counting to zero:"</span>)</span><br><span class="line"><span class="keyword">while</span> value != <span class="number">0</span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(value)</span>..."</span>)</span><br><span class="line">	value = moveNearerToZero(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"zero!"</span>)</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// -4...</span></span><br><span class="line"><span class="comment">// -3...</span></span><br><span class="line"><span class="comment">// -2...</span></span><br><span class="line"><span class="comment">// -1...</span></span><br><span class="line"><span class="comment">// zero!</span></span><br></pre></td></tr></table></figure></p>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>defining and calling</strong></p>
<p>以定义一个 <code>sayHello(_:)</code> 函数作为例子：该函数将一个人的名字作为输入，以一句问候作为返回值：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="func"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(personName: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">	<span class="keyword">let</span> greeting = <span class="string">"Hello, "</span> + personName + <span class="string">"!"</span></span><br><span class="line">	<span class="keyword">return</span> greeting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="Objective-C" scheme="http://bluestein.github.io/tags/Objective-C/"/>
    
      <category term="Swift" scheme="http://bluestein.github.io/tags/Swift/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Swift" scheme="http://bluestein.github.io/categories/Dev/Swift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[19:语句]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-primer4-19/"/>
    <id>http://bluestein.github.io/2015/12/cpp-primer4-19/</id>
    <published>2015-12-17T08:13:33.000Z</published>
    <updated>2015-12-20T11:58:50.376Z</updated>
    <content type="html"><![CDATA[<p>开始学习第六章《语句》</p>
<h3 id="1、简单语句">1、简单语句</h3><p><strong>空语句</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<p>只有一个分号。在某些条件下使用，如从输入流读入数据，而不需操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> （<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">	;	<span class="comment">// null statement</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用空语句时最好加上注释</p>
</blockquote>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b + <span class="number">1</span>;;</span><br></pre></td></tr></table></figure>
<p>看似非法的分号，其实是一个空语句。但并不意味着就能随便使用，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (iter != vec.end()) ;	<span class="comment">// while循环体为空</span></span><br><span class="line">	++iter;	<span class="comment">// 不是循环体的一部分</span></span><br></pre></td></tr></table></figure>
<p>会无限循环。</p>
<p><strong>复合语句（块）</strong></p>
<p>用花括号括起来的语句序列（也可能为空）。如 for 和 while</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; trans)</span><br><span class="line">	<span class="keyword">if</span> (total.same_isbn(trans))</span><br><span class="line">		total = total + trans;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">		total = trans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>else</code> 分支需要用块语句。</p>
<blockquote>
<p>块语句并不是以分号结束</p>
</blockquote>
<p>也可以是 <strong>空块</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">&#123;&#125;	<span class="comment">// 空块</span></span><br></pre></td></tr></table></figure>
<p><strong>语句作用域</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">int</span> i = get_num())</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="number">0</span>;	<span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p><code>i</code> 超出了作用域。</p>
<p><strong>控制结构中引入的变量是局部变量</strong>，仅在块语句结束前有效。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type index = <span class="number">0</span>;</span><br><span class="line">		index != vec.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> square = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (index % <span class="number">2</span>)</span><br><span class="line">		square = index * index;</span><br><span class="line">	vec[index] = square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != vec.size())	<span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>如果要在控制语句外访问，则需定义在控制语句外<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (; index != vec.size(); ++index)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> square = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (index % <span class="number">2</span>)</span><br><span class="line">		square = index * index;</span><br><span class="line">	vec[index] = square;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index != vec.size())	<span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2、if语句">2、if语句</h3><p><strong>if语句</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">	statement1</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">&#123;</span><br><span class="line">	staement2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	staement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>目前为止，除了 vector 和 string 类型一般不可作为条件外，均可作为if语句的条件，包括 IO 类型。</p>
<blockquote>
<p>各分支语句用 <code>{}</code> 括起来是一个好的习惯</p>
</blockquote>
<p><strong>if语句可以嵌套</strong></p>
<p>例如，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (condition2)</span><br><span class="line">	&#123;</span><br><span class="line">		statement1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		staement2</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// use if statement here also valid</span></span><br><span class="line">	staement3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开始学习第六章《语句》</p>
<h3 id="1、简单语句">1、简单语句</h3><p><strong>空语句</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<p>只有一个分号。在某些条件下使用，如从输入流读入数据，而不需操作：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> （<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != <span class="string">"abc"</span>)</span><br><span class="line">	;	<span class="comment">// null statement</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>使用空语句时最好加上注释</p>
</blockquote>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ demo: if语句]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-4/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-4/</id>
    <published>2015-12-17T07:32:42.000Z</published>
    <updated>2015-12-17T07:41:17.606Z</updated>
    <content type="html"><![CDATA[<p>编写程序：寻找vector中的最小值，并记录这个最小值出现的次数。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		ivec.push_back(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这两步是为了制造最小值</span></span><br><span class="line">	ivec[<span class="number">0</span>] = ivec[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line">	ivec[<span class="number">5</span>] = ivec[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> min_val = ivec[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> min_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ivec.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ivec[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (min_val == ivec[i])</span><br><span class="line">		&#123;</span><br><span class="line">			++min_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (min_val &gt; ivec[i])</span><br><span class="line">		&#123;</span><br><span class="line">			min_val = ivec[i];</span><br><span class="line">			min_cnt = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"min value: "</span>&lt;&lt; min_val &lt;&lt;<span class="string">", count: "</span>&lt;&lt; min_cnt &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">min value: <span class="number">0</span>, count: <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写程序：寻找vector中的最小值，并记录这个最小值出现的次数。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/tags/C-Demo/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/categories/Dev/C-Demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: 账户的创建和配置]]></title>
    <link href="http://bluestein.github.io/2015/12/github-1/"/>
    <id>http://bluestein.github.io/2015/12/github-1/</id>
    <published>2015-12-04T04:54:49.000Z</published>
    <updated>2015-12-03T12:40:09.285Z</updated>
    <content type="html"><![CDATA[<p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p>
<a id="more"></a>
<p><strong>账户的创建和配置</strong></p>
<p>你所需要做的第一件事是创建一个免费账户。 直接访问 <a href="https://github.com" target="_blank" rel="external">Github</a>，选择一个未被占用的用户名，提供一个电子邮件地址和密码，点击写着“Sign up for GitHub”的绿色大按钮即可。</p>
<blockquote>
<p>GitHub 为免费账户提供了完整功能，限制是你的项目都将被完全公开（每个人都具有读权限）。 GitHub 的付费计划可以让你拥有一定数目的私有项目。</p>
</blockquote>
<p><strong>SSH 访问</strong></p>
<p>现在，你完全可以使用 https:// 协议，通过你刚刚创建的用户名和密码访问 Git 版本库。 但是，如果仅仅克隆公有项目，你甚至不需要注册——刚刚我们创建的账户是为了以后 fork 其它项目，以及推送我们自己的修改。</p>
<p>如果你习惯使用 SSH 远程，你需要配置一个公钥 (public key)。</p>
<p>SSH key 的生成过程请查看 <a href="https://help.github.com/articles/generating-ssh-keys/" target="_blank" rel="external">github generating-ssh-keys</a>。</p>
<p>点击头像下得“Settings”，然后在左侧选择“SSH keys”部分。在这个页面点击“Add an SSH key”按钮，给你的公钥起一个名字，将你的 <code>~/.ssh/id_rsa.pub</code>（或者自定义的其它名字）公钥文件的内容粘贴到文本区，然后点击“Add key”。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>GitHub 是最大的 Git 版本库托管商，是成千上万的开发者和项目能够合作进行的中心。 大部分 Git 版本库都托管在 GitHub，很多开源项目使用 GitHub 实现 Git 托管、问题追踪、代码审查以及其它事情。 所以，尽管这不是 Git 开源项目的直接部分，但如果想要专业地使用 Git，你将不可避免地与 GitHub 打交道，所以这依然是一个绝好的学习机会。</p>]]>
    
    </summary>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github" scheme="http://bluestein.github.io/categories/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 分支]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-4/"/>
    <id>http://bluestein.github.io/2015/12/github-git-4/</id>
    <published>2015-12-03T07:54:49.000Z</published>
    <updated>2015-12-03T12:56:13.101Z</updated>
    <content type="html"><![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-3/">Github: Git的使用 - 撤销操作</a>，下面继续介绍git的更多用法。</p>
<h3 id="4、分支">4、分支</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="external">官网教程</a>。</p>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>
<a id="more"></a>
<p>为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象，</p>
<p>为了说得更加形象，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和使用 SHA-1 哈希算法，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add README test.rb LICENSE</span><br><span class="line">$ git commit -m <span class="string">'The initial commit of my project'</span></span><br></pre></td></tr></table></figure>
<p>当使用 <code>git commit</code> 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。</p>
<p>Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 <code>master</code>。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 <code>master</code> 分支。 它会在每次的提交操作中自动向前移动。</p>
<blockquote>
<p>Git 的 “master” 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。 之所以几乎每一个仓库都有 master 分支，是因为 git init 命令默认创建它，并且大多数人都懒得去改动它。</p>
</blockquote>
<p><strong>分支创建</strong></p>
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch testing</span><br></pre></td></tr></table></figure>
<p>这会在当前所在的提交对象上创建一个指针。</p>
<p>那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 <code>HEAD</code> 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 <code>HEAD</code> 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 <code>HEAD</code> 想象为当前分支的别名）。 在本例中，你仍然在 <code>master</code> 分支上。 因为 <code>git branch</code> 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。</p>
<p>你可以简单地使用 <code>git log</code> 命令查看各个分支当前所指的对象。 提供这一功能的参数是 <code>--decorate</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --decorate</span><br></pre></td></tr></table></figure>
<p><strong>分支切换</strong></p>
<p>要切换到一个已存在的分支，你需要使用 <code>git checkout</code> 命令。 我们现在切换到新创建的 <code>testing</code> 分支去：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout testing</span><br></pre></td></tr></table></figure>
<p>这样 HEAD 就指向 <code>testing</code> 分支了。</p>
<h3 id="4、分支的新建与合并">4、分支的新建与合并</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="external">官网教程</a>。</p>
<p>让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：</p>
<ol>
<li>开发某个网站。</li>
<li>为实现某个新的需求，创建一个分支。</li>
<li>在这个分支上开展工作。</li>
</ol>
<p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p>
<ol>
<li>切换到你的线上分支（production branch）。</li>
<li>为这个紧急任务新建一个分支，并在其中修复它。</li>
<li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li>
<li>切换回你最初工作的分支上，继续工作。</li>
</ol>
<p><strong>新建分支</strong></p>
<p>首先，我们假设你正在你的项目上工作，并且已经有一些提交。</p>
<p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 <code>#53</code> 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 <code>-b</code> 参数的 <code>git checkout</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b iss53</span><br><span class="line">Switched to a new branch <span class="string">"iss53"</span></span><br></pre></td></tr></table></figure>
<p>它是下面两条命令的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch iss53</span><br><span class="line">$ git checkout iss53</span><br></pre></td></tr></table></figure>
<p>你继续在 <code>#53</code> 问题上工作，并且做了一些提交。 在此过程中，<code>iss53</code> 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 <code>HEAD</code> 指针指向了 <code>iss53</code> 分支）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="operator">-a</span> -m <span class="string">'added a new footer [issue 53]'</span></span><br></pre></td></tr></table></figure>
<p>现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 <code>iss53</code> 的修改混在一起，你也不需要花大力气来还原关于 <code>53#</code> 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 <code>master</code> 分支。</p>
<p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，保存进度（stashing） 和 修补提交（commit amending）），我们会在 储藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 <code>master</code> 分支了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br></pre></td></tr></table></figure>
<p>这个时候，你的工作目录和你在开始 <code>#53</code> 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。</p>
<p>接下来，你要修复这个紧急问题。 让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b hotfix</span><br><span class="line">Switched to a new branch <span class="string">'hotfix'</span></span><br><span class="line">$ vim index.html</span><br><span class="line">$ git commit <span class="operator">-a</span> -m <span class="string">'fixed the broken email address'</span></span><br><span class="line">[hotfix <span class="number">1</span>fb7853] fixed the broken email address</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span><br></pre></td></tr></table></figure>
<p>你在 hotfix 分支上所做的工作并没有包含到 <code>iss53</code> 分支中。 如果你需要拉取 <code>hotfix</code> 所做的修改，你可以使用 <code>git merge master</code> 命令将 <code>master</code> 分支合并入 <code>iss53</code> 分支，或者你也可以等到 <code>iss53</code> 分支完成其使命，再将其合并回 <code>master</code> 分支。</p>
<p><strong>分支的合并</strong></p>
<p>假设你已经修正了 <code>#53</code> 问题，并且打算将你的工作合并入 <code>master</code> 分支。 为此，你需要合并 <code>iss53</code> 分支到 <code>master</code> 分支，这和之前你合并 <code>hotfix</code> 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 <code>git merge</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">$ git merge iss53</span><br><span class="line">Merge made by the <span class="string">'recursive'</span> strategy.</span><br><span class="line">index.html |    <span class="number">1</span> +</span><br><span class="line"><span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p><strong>遇到冲突时的分支合并</strong></p>
<p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge iss53</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure>
<p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。</p>
<p>如果你想使用图形化工具来解决冲突，你可以运行 <code>git mergetool</code>，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mergetool</span><br></pre></td></tr></table></figure>
<p><strong>分支管理</strong></p>
<p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86" target="_blank" rel="external">官网教程</a>。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-3/">Github: Git的使用 - 撤销操作</a>，下面继续介绍git的更多用法。</p>
<h3 id="4、分支">4、分支</h3><p>详细的可以看<a href="http://www.git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B">官网教程</a>。</p>
<p>几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github" scheme="http://bluestein.github.io/categories/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 撤销操作]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-3/"/>
    <id>http://bluestein.github.io/2015/12/github-git-3/</id>
    <published>2015-12-03T06:54:49.000Z</published>
    <updated>2015-12-03T12:56:14.471Z</updated>
    <content type="html"><![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-2/">Github: Git的使用 - 历史记录</a>的第三小节，下面继续介绍git的更多用法。</p>
<h3 id="3-4、撤消操作">3.4、撤消操作</h3><p><strong>撤消操作</strong></p>
<p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>
<a id="more"></a>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 –amend 选项的提交命令尝试重新提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。</p>
<p>例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">'initial commit'</span></span><br><span class="line">$ git add forgotten_file</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure>
<p>最终你只会有一个提交 - 第二次提交将代替第一次提交的结果。</p>
<p><strong>取消暂存的文件</strong></p>
<p>接下来的两个小节演示如何操作暂存区域与工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 <code>git add *</code> 暂存了它们两个。 如何只取消暂存两个中的一个呢？ <code>git status</code> 命令提示了你：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add *</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>在 “Changes to be committed” 文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code> 来取消暂存。</p>
<p><strong>撤消对文件的修改</strong></p>
<p>如果你并不想保留对 <code>CONTRIBUTING.md</code> 文件的修改怎么办？ 你该如何方便地撤消修改 - 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，<code>git status</code> 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>它非常清楚地告诉了你如何撤消之前所做的修改: 使用 <code>git checkout -- &lt;file&gt;...</code>。</p>
<blockquote>
<p>你需要知道 <code>git checkout -- [file]</code> 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。</p>
</blockquote>
<h3 id="3-5、远程仓库的使用">3.5、远程仓库的使用</h3><p>为了能在任意 Git 项目上协作，你需要知道如何管理自己的远程仓库。 远程仓库是指托管在因特网或其他网络中的你的项目的版本库。 你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。 与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。 管理远程仓库包括了解如何添加远程仓库、移除无效的远程仓库、管理不同的远程分支并定义它们是否被跟踪等等。 在本节中，我们将介绍一部分远程管理的技能。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/bluestein/hexo-theme-allgreen.git</span><br><span class="line">...</span><br><span class="line">$ <span class="built_in">cd</span> hexo-theme-allgreen</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/bluestein/hexo-theme-allgreen.git (fetch)</span><br><span class="line">origin	https://github.com/bluestein/hexo-theme-allgreen.git (push)</span><br></pre></td></tr></table></figure>
<p>如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> grit</span><br><span class="line">$ git remote -v</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit.git (fetch)</span><br><span class="line">bakkdoor  https://github.com/bakkdoor/grit.git (push)</span><br><span class="line">cho45     https://github.com/cho45/grit.git (fetch)</span><br><span class="line">cho45     https://github.com/cho45/grit.git (push)</span><br><span class="line">defunkt   https://github.com/defunkt/grit.git (fetch)</span><br><span class="line">defunkt   https://github.com/defunkt/grit.git (push)</span><br><span class="line">koke      git://github.com/koke/grit.git (fetch)</span><br><span class="line">koke      git://github.com/koke/grit.git (push)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (fetch)</span><br><span class="line">origin    git@github.com:mojombo/grit.git (push)</span><br></pre></td></tr></table></figure>
<p>这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限。</p>
<p><strong>添加远程仓库</strong></p>
<p>我在之前的章节中已经提到并展示了如何添加远程仓库的示例，不过这里将告诉你如何明确地做到这一点。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/schacon/ticgit.git (fetch)</span><br><span class="line">origin	https://github.com/schacon/ticgit.git (push)</span><br><span class="line">pb	https://github.com/paulboone/ticgit.git (fetch)</span><br><span class="line">pb	https://github.com/paulboone/ticgit.git (push)</span><br></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code> 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch pb</span><br></pre></td></tr></table></figure>
<p><strong>从远程仓库中抓取与拉取</strong></p>
<p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="http://bluestein.github.io/2015/12/github-git-4/">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，<code>git clone</code> 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<p><strong>推送到远程仓库</strong></p>
<p>当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：<code>git push [remote-name] [branch-name]</code>。 当你想要将 master 分支推送到 <code>origin</code> 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<p><strong>查看远程仓库</strong></p>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show [remote-name]</code> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote show origin</span><br></pre></td></tr></table></figure>
<p>这个命令列出了当你在特定的分支上执行 <code>git push</code> 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 <code>git pull</code> 时哪些分支会自动合并。</p>
<p><strong>远程仓库的移除与重命名</strong></p>
<p>如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>
<p>值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 <code>git remote rm</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-2/">Github: Git的使用 - 历史记录</a>的第三小节，下面继续介绍git的更多用法。</p>
<h3 id="3-4、撤消操作">3.4、撤消操作</h3><p><strong>撤消操作</strong></p>
<p>在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github" scheme="http://bluestein.github.io/categories/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 历史记录]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-2/"/>
    <id>http://bluestein.github.io/2015/12/github-git-2/</id>
    <published>2015-12-03T05:54:49.000Z</published>
    <updated>2015-12-03T12:56:14.468Z</updated>
    <content type="html"><![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-1/">Github: Git的使用 - 安装配置</a>的第二小节，下面继续介绍git的更多用法。</p>
<h3 id="3-3、查看提交历史">3.3、查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史. 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>
<a id="more"></a>
<p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。</p>
<p><code>git log</code> 有许多选项可以帮助你搜寻你所要找的提交， 接下来我们介绍些最常用的。</p>
<p>一个常用的选项是 <code>-p</code>，用来显示每次提交的内容差异。 你也可以加上 <code>-2</code> 来仅显示最近两次提交</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p -<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>该选项除了显示基本信息之外，还在附带了每次 commit 的变化。 当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 <code>git log</code> 附带一系列的总结性选项。 比如说，如果你想看到每次提交的简略的统计信息，你可以使用 <code>--stat</code> 选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --stat</span><br></pre></td></tr></table></figure>
<p><code>--stat</code> 选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。</p>
<p>另外一个常用的选项是 <code>--pretty</code>。 这个选项可以指定使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如用 <code>oneline</code> 将每个提交放在一行显示，查看的提交数很大时非常有用。 另外还有 short，full 和 fuller 可以用，展示的信息或多或少有些不同，请自己动手实践一下看看效果如何。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure>
<p>但最有意思的是 format，可以定制要显示的记录格式。 这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着Git的更新而发生改变：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span><br></pre></td></tr></table></figure>
<p><code>git log --pretty=format</code> 常用的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%H</td>
<td>提交对象（commit）的完整哈希字串</td>
</tr>
<tr>
<td>%h</td>
<td>提交对象的简短哈希字串</td>
</tr>
<tr>
<td>%T</td>
<td>树对象（tree）的完整哈希字串</td>
</tr>
<tr>
<td>%t</td>
<td>树对象的简短哈希字串</td>
</tr>
<tr>
<td>%P</td>
<td>父对象（parent）的完整哈希字串</td>
</tr>
<tr>
<td>%p</td>
<td>父对象的简短哈希字串</td>
</tr>
<tr>
<td>%an</td>
<td>作者（author）的名字</td>
</tr>
<tr>
<td>%ae</td>
<td>作者的电子邮件地址</td>
</tr>
<tr>
<td>%ad</td>
<td>作者修订日期（可以用 –date= 选项定制格式）</td>
</tr>
<tr>
<td>%ar</td>
<td>作者修订日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%cn</td>
<td>提交者(committer)的名字</td>
</tr>
<tr>
<td>%ce</td>
<td>提交者的电子邮件地址</td>
</tr>
<tr>
<td>%cd</td>
<td>提交日期</td>
</tr>
<tr>
<td>%cr</td>
<td>提交日期，按多久以前的方式显示</td>
</tr>
<tr>
<td>%s</td>
<td>提交说明</td>
</tr>
</tbody>
</table>
<p><code>git log</code> 的常用选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>按补丁格式显示每个更新之间的差异。</td>
</tr>
<tr>
<td>–stat</td>
<td>显示每次更新的文件修改统计信息。</td>
</tr>
<tr>
<td>–shortstat</td>
<td>只显示 –stat 中最后的行数修改添加移除统计。</td>
</tr>
<tr>
<td>–name-only</td>
<td>仅在提交信息后显示已修改的文件清单。</td>
</tr>
<tr>
<td>–name-status</td>
<td>显示新增、修改、删除的文件清单。</td>
</tr>
<tr>
<td>–abbrev-commit</td>
<td>仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td>
</tr>
<tr>
<td>–relative-date</td>
<td>使用较短的相对时间显示（比如，“2 weeks ago”）。</td>
</tr>
<tr>
<td>–graph</td>
<td>显示 ASCII 图形表示的分支合并历史。</td>
</tr>
<tr>
<td>–pretty</td>
<td>使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）。</td>
</tr>
</tbody>
</table>
<p><strong>限制输出长度</strong></p>
<p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。 之前你已经看到过 <code>-2</code> 了，它只显示最近的两条提交， 实际上，这是 <code>-&lt;n&gt;</code> 选项的写法，其中的 <code>n</code> 可以是任何整数，表示仅显示最近的若干条提交。 不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>另外还有按照时间作限制的选项，比如 <code>--since</code> 和 <code>--until</code> 也很有用。 例如，下面的命令列出所有最近两周内的提交：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --since=<span class="number">2</span>.weeks</span><br></pre></td></tr></table></figure>
<p>这个命令可以在多种格式下工作，比如说具体的某一天 “2008-01-15”，或者是相对地多久以前 “2 years 1 day 3 minutes ago”。</p>
<p>还可以给出若干搜索条件，列出符合的提交。 用 <code>--author</code> 选项显示指定作者的提交，用 <code>--grep</code> 选项搜索提交说明中的关键字。 （请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 <code>--all-match</code> 选项。否则，满足任意一个条件的提交都会被匹配出来）</p>
<p>限制 <code>git log</code> 输出的选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-(n)</td>
<td>仅显示最近的 n 条提交</td>
</tr>
<tr>
<td>–since, –after</td>
<td>仅显示指定时间之后的提交。</td>
</tr>
<tr>
<td>–until, –before</td>
<td>仅显示指定时间之前的提交。</td>
</tr>
<tr>
<td>–author</td>
<td>仅显示指定作者相关的提交。</td>
</tr>
<tr>
<td>–committer</td>
<td>仅显示指定提交者相关的提交。</td>
</tr>
<tr>
<td>–grep</td>
<td>仅显示含指定关键字的提交</td>
</tr>
<tr>
<td>-S</td>
<td>仅显示添加或移除了某个关键字的提交</td>
</tr>
</tbody>
</table>
<p>来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，提交过的但未合并的测试文件，可以用下面的查询命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=<span class="string">"%h - %s"</span> --author=gitster --since=<span class="string">"2008-10-01"</span> \</span><br><span class="line">   --before=<span class="string">"2008-11-01"</span> --no-merges -- t/</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>接上一节 <a href="http://bluestein.github.io/2015/12/github-git-1/">Github: Git的使用 - 安装配置</a>的第二小节，下面继续介绍git的更多用法。</p>
<h3 id="3-3、查看提交历史">3.3、查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史. 完成这个任务最简单而又有效的工具是 <code>git log</code> 命令。</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github" scheme="http://bluestein.github.io/categories/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github: Git的使用 - 安装配置]]></title>
    <link href="http://bluestein.github.io/2015/12/github-git-1/"/>
    <id>http://bluestein.github.io/2015/12/github-git-1/</id>
    <published>2015-12-03T01:54:49.000Z</published>
    <updated>2015-12-03T13:04:50.510Z</updated>
    <content type="html"><![CDATA[<p><strong>Github 是什么？</strong></p>
<blockquote>
<p>GitHub is the best place to share code with friends, co-workers, classmates, and complete strangers.<br>（GitHub是和朋友、同学、同事或完全陌生的人分享代码最好的地方）</p>
</blockquote>
<p>本着我一直以来推崇的 <strong>够用就好</strong> 原则，本篇文章不会过多去说专业术语，而是要成为让新手也能直接上手使用的教程。下面开始正文内容：</p>
<a id="more"></a>
<p>说到 <strong>github</strong>，能看出来这个词是 git+hub 的组合，hub 就不用多说了，就是字面意思 “枢纽、中心”之类的，我们首先主要关注的是 <strong>git</strong> 。</p>
<h2 id="Git">Git</h2><p>官网有这么一句话，说明了git到底是何方神圣：</p>
<blockquote>
<p>Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>
</blockquote>
<p>这句话的意思是：Git是一个免费开源的分布式版本控制系统，用于高效地处理从小型到大型项目的所有东西。</p>
<ul>
<li>它能够保留文件的或项目的更新版本记录，并且能回滚至某一个历史记录的状态。举个栗子，比如今天你把上次能够正确运行的程序修改后down掉了，这时你就可以使用 <strong>回滚</strong>功能。</li>
<li>所谓 <strong>分布式版本控制</strong> 就是指每个参与人员都可以拥有一份项目的源代码，每个成员在自己的这份copy上进行修改、增加而不影响其他人，然后在提交至仓库中（个人理解，勿喷 =_=）</li>
<li>git具有分支（branch）功能。比如你想开发点新奇的功能但又不想影响主项目时，就可以新建一个分支。</li>
</ul>
<h3 id="1、安装git">1、安装git</h3><p>git支持不同的操作系统，可以通过软件包或源码安装。</p>
<p><strong>windows系统</strong></p>
<p>在<a href="http://www.git-scm.com/download/win" title="git for windows" target="_blank" rel="external">git官网下载可安装程序</a>，然后按提示安装即可。安装完后开始菜单应该会出现如下目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Git Bash</span><br><span class="line">- Git GUI</span><br></pre></td></tr></table></figure>
<p><strong>Linux系统</strong></p>
<p>在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。 如果以 Fedora 上为例，你可以使用 yum：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure>
<p>如果你在基于 Debian 的发行版上，请尝试用 apt-get：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>
<p><strong>Mac系统</strong></p>
<p>跟windows一样，<a href="http://www.git-scm.com/download/mac" title="git for mac" target="_blank" rel="external">官网下载安装</a>即可。</p>
<blockquote>
<p>下面所有内容仅适用于windows系统</p>
</blockquote>
<h3 id="2、配置Git">2、配置Git</h3><blockquote>
<p>我的git版本是1.9.5，不过新的版本也大同小异。</p>
</blockquote>
<p>当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改，打开 <code>Git Bash</code> 输入下面命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"your-name"</span></span><br><span class="line">$ git config --global user.email your-name@example.com</span><br></pre></td></tr></table></figure>
<p><code>--global</code> 命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 <code>--global</code> 选项的命令来配置，即</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config user.name <span class="string">"your-name"</span></span><br><span class="line">$ git config user.email your-name@example.com</span><br></pre></td></tr></table></figure>
<p><strong>检查配置信息</strong></p>
<p>如果想要检查你的配置，可以使用 <code>git config --list</code> 命令来列出所有 Git 当时能找到的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">user.name=your-name</span><br><span class="line">user.email=your-name@example.com</span><br><span class="line">color.status=auto</span><br><span class="line">color.branch=auto</span><br><span class="line">color.interactive=auto</span><br><span class="line">color.diff=auto</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>获取帮助</strong></p>
<p>若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">help</span> &lt;verb&gt;</span><br><span class="line">$ git &lt;verb&gt; --help</span><br><span class="line">$ man git-&lt;verb&gt;</span><br></pre></td></tr></table></figure>
<p>例如，要想获得 config 命令的手册，执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">help</span> config</span><br></pre></td></tr></table></figure>
<h3 id="3、使用Git">3、使用Git</h3><h3 id="3-1、生成仓库">3.1、生成仓库</h3><p><strong>在现有目录中初始化仓库</strong></p>
<p>如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code> 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p>
<p>如果你是在一个已经存在文件的文件夹（而不是空文件夹）中初始化 Git 仓库来进行版本控制的话，你应该开始跟踪这些文件并提交。 你可通过 <code>git add</code> 命令来实现对指定文件的跟踪，然后执行 <code>git commit</code> 提交到仓库：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add LICENSE</span><br><span class="line">$ git commit -m <span class="string">'initial project version'</span></span><br></pre></td></tr></table></figure>
<p><strong>克隆现有的仓库</strong></p>
<p>如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code> 命令。 如果你对其它的 VCS 系统（比如说Subversion）很熟悉，请留心一下你所使用的命令是”clone”而不是”checkout”。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p>
<p>克隆仓库的命令格式是 <code>git clone [url]</code> 。 比如，要克隆 Git 的可链接库 hexo-theme-allgreen，可以用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/bluestein/hexo-theme-allgreen.git</span><br></pre></td></tr></table></figure>
<p>这会 <strong>在当前目录下</strong> 创建一个名为 “hexo-theme-allgreen” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 hexo-theme-allgreen 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/bluestein/hexo-theme-allgreen.git myallgreen</span><br></pre></td></tr></table></figure>
<p>这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 myallgreen。</p>
<h3 id="3-2、更新到仓库">3.2、更新到仓库</h3><p>现在我们手上有了一个真实项目的 Git 仓库，并从这个仓库中取出了所有文件的工作拷贝。 接下来，对这些文件做些修改，在完成了一个阶段的目标之后，提交本次更新到仓库。</p>
<p><strong>检查当前文件状态</strong></p>
<p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">nothing to commit, working directory clean</span><br></pre></td></tr></table></figure>
<p>这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。</p>
<p>现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 <code>git status</code> 命令，你将看到一个新的未跟踪文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure>
<p>在状态报告中可以看到新建的 README 文件出现在 <code>Untracked files</code> 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”， 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。</p>
<p><strong>跟踪新文件</strong></p>
<p>使用命令 <code>git add</code> 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<p>此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>
<p>只要在 <code>Changes to be committed</code> 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。 你可能会想起之前我们使用 <code>git init</code> 后就运行了 <code>git add (files)</code> 命令，开始跟踪当前目录下的文件。 <code>git add</code> 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p>
<p><strong>暂存已修改文件</strong></p>
<p>现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 <code>git status</code> 命令，会看到下面内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>文件 CONTRIBUTING.md 出现在 <code>Changes not staged for commit</code> 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 <code>git add</code> 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 <code>git add</code> 将”CONTRIBUTING.md”放到暂存区，然后再看看 <code>git status</code> 的输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git add CONTRIBUTING.md</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>现在两个文件都已暂存，下次提交时就会一并记录到仓库。</p>
<p><strong>状态简览</strong></p>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。 如果你使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，你将得到一种更为紧凑的格式输出。 运行 <code>git status -s</code> ，状态报告输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status <span class="operator">-s</span></span><br><span class="line"> M README</span><br><span class="line">MM Rakefile</span><br><span class="line">A  lib/git.rb</span><br><span class="line">M  lib/simplegit.rb</span><br><span class="line">?? LICENSE.txt</span><br></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。 你可能注意到了 <code>M</code> 有两个可以出现的位置，出现在右边的 M 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 M 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： <code>README</code> 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,<code>lib/simplegit.rb</code> 文件被修改了并将修改后的文件放入了暂存区。 而 <code>Rakefile</code> 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。</p>
<p><strong>忽略文件</strong></p>
<p>一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 <code>.gitignore</code> 的文件，列出要忽略的文件模式。 来看一个实际的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ touch .gitignore</span><br></pre></td></tr></table></figure>
<p>然后再在<code>.gitignore</code> 文件添加以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.[oa]</span><br><span class="line">*~</span><br></pre></td></tr></table></figure>
<p>第一行告诉 Git 忽略所有以 <code>.o</code> 或 <code>.a</code> 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。</p>
<p>文件 <code>.gitignore</code> 的格式规范如下：</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略（可以理解为注释）。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<p>我们再看一个 <code>.gitignore</code> 文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略 .a 文件</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使上面已经忽略 .a 文件, 还是不跟踪 lib.a，任性！ </span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只忽略当前文件夹下的TODO文件，不是子文件夹/TODO</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 build/ 文件夹中的所有文件</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/notes.txt, 但不会忽略 doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 doc/ 文件夹下所有 .pdf 文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>
<p><strong>查看已暂存和未暂存的修改</strong></p>
<p>如果 <code>git status</code> 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 <code>git diff</code> 命令。 稍后会详细介绍 <code>git diff</code>，你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ 尽管 <code>git status</code> 已经通过在相应栏下列出文件名的方式回答了这个问题，<code>git diff</code> 将通过文件补丁的格式显示具体哪些行发生了改变。</p>
<p>假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Initial commit</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git rm --cached &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   CONTRIBUTING.md</span><br></pre></td></tr></table></figure>
<p>要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 <code>git diff</code>。此命令比较的是工作目录中当前文件和暂存区域快照之间的差异， 也就是修改之后还没有暂存起来的变化内容。若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code> 命令。</p>
<p><strong>提交更新</strong></p>
<p>现在的暂存区域已经准备妥当可以提交了。 在此之前，请一定要确认还有什么修改过的或新建的文件还没有 <code>git add</code> 过，否则提交的时候不会记录这些还没暂存起来的变化。 这些修改过的文件只保留在本地磁盘。 所以，每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"提交说明"</span></span><br></pre></td></tr></table></figure>
<p>如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"Story 182: Fix benchmarks for speed"</span></span><br><span class="line">[master &lt;root-commit&gt; <span class="number">463</span>dc4f] Story <span class="number">182</span>: Fix benchmarks <span class="keyword">for</span> speed</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">2</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> README</span><br></pre></td></tr></table></figure>
<p><strong>跳过使用暂存区域</strong></p>
<p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="operator">-a</span> -m <span class="string">'added new benchmarks'</span></span><br><span class="line">[master <span class="number">83</span>e38c7] added new benchmarks</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">5</span> insertions(+), <span class="number">0</span> deletions(-)</span><br></pre></td></tr></table></figure>
<p><strong>移动文件</strong></p>
<p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。 如果在 Git 中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 不过 Git 非常聪明，它会推断出究竟发生了什么，至于具体是如何做到的，我们稍后再谈。</p>
<p>既然如此，当你看到 Git 的 <code>mv</code> 命令时一定会困惑不已。 要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git mv file_from file_to</span><br></pre></td></tr></table></figure>
<p>它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git mv README.md README</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    renamed:    README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>其实，运行 git mv 就相当于运行了下面三条命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mv README.md README</span><br><span class="line">$ git rm README.md</span><br><span class="line">$ git add README</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>Github 是什么？</strong></p>
<blockquote>
<p>GitHub is the best place to share code with friends, co-workers, classmates, and complete strangers.<br>（GitHub是和朋友、同学、同事或完全陌生的人分享代码最好的地方）</p>
</blockquote>
<p>本着我一直以来推崇的 <strong>够用就好</strong> 原则，本篇文章不会过多去说专业术语，而是要成为让新手也能直接上手使用的教程。下面开始正文内容：</p>]]>
    
    </summary>
    
      <category term="git" scheme="http://bluestein.github.io/tags/git/"/>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="Github" scheme="http://bluestein.github.io/categories/Github/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ demo: vector存放指针]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-3/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-3/</id>
    <published>2015-12-02T14:01:42.000Z</published>
    <updated>2015-12-02T14:14:39.579Z</updated>
    <content type="html"><![CDATA[<p>编写程序：定义vector对象，其每个元素指向string类型的指针；输出每个元素的内容及长度。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt; v;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(s);</span><br><span class="line">		v.push_back(sp);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt;::iterator iter = v.begin();</span><br><span class="line">	<span class="keyword">while</span> (iter != v.end()) &#123;</span><br><span class="line">		<span class="built_in">string</span> *tmp = *iter;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; tmp-&gt;size() &lt;&lt; <span class="string">", "</span> &lt;&lt; *tmp &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span> tmp;</span><br><span class="line">		iter++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world!↙</span><br><span class="line">^Z↙</span><br><span class="line"><span class="number">5</span>, hello</span><br><span class="line"><span class="number">6</span>, world!</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写程序：定义vector对象，其每个元素指向string类型的指针；输出每个元素的内容及长度。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/tags/C-Demo/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/categories/Dev/C-Demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo3.1.1 + github pages教程：添加多说评论系统]]></title>
    <link href="http://bluestein.github.io/2015/11/hexo-github-1/"/>
    <id>http://bluestein.github.io/2015/11/hexo-github-1/</id>
    <published>2015-11-30T07:54:49.000Z</published>
    <updated>2015-11-30T15:28:16.283Z</updated>
    <content type="html"><![CDATA[<h3 id="一、添加多说ID(必须)">一、添加多说ID(必须)</h3><p>在根目录的 <code>_config.yml</code> 中定义 <code>duoshuo_shortname: (你的多说ID)</code> 形如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comments</span><br><span class="line">duoshuo_shortname: (你的多说ID)</span><br></pre></td></tr></table></figure>
<h3 id="二、引入多说JS(必须)">二、引入多说JS(必须)</h3><a id="more"></a>
<p>将 <code>themes/(你的主题)/layout/_partial/after-footer.ejs</code> 中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (config.disqus_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">  <span class="keyword">var</span> disqus_shortname = <span class="string">'&lt;%= config.disqus_shortname %&gt;'</span>;</span><br><span class="line">  &lt;% <span class="keyword">if</span> (page.permalink)&#123; %&gt;</span><br><span class="line">  <span class="keyword">var</span> disqus_url = <span class="string">'&lt;%= page.permalink %&gt;'</span>;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dsq = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">    dsq.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    dsq.async = <span class="literal">true</span>;</span><br><span class="line">    dsq.src = <span class="string">'//'</span> + disqus_shortname + <span class="string">'.disqus.com/&lt;% if (page.comments) &#123; %&gt;embed.js&lt;% &#125; else &#123; %&gt;count.js&lt;% &#125; %&gt;'</span>;</span><br><span class="line">    (document.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>] || document.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(dsq);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>部分修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> duoshuoQuery = &#123;short_name:<span class="string">"你的多说ID"</span>&#125;;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ds = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    ds.type = <span class="string">'text/javascript'</span>;ds.async = <span class="literal">true</span>;</span><br><span class="line">    ds.src = (<span class="built_in">document</span>.location.protocol == <span class="string">'https:'</span> ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">'//static.duoshuo.com/embed.js'</span>;</span><br><span class="line">    ds.charset = <span class="string">'UTF-8'</span>;</span><br><span class="line">    (<span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>] </span><br><span class="line">     || <span class="built_in">document</span>.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>]).appendChild(ds);</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这个步骤是全局引入多说js，后面就可以直接使用了。</p>
<h3 id="三、引入多说评论窗口(必须)">三、引入多说评论窗口(必须)</h3><p><strong>首先，</strong>将 <code>themes/(你的主题)/layout/_partial/article.ejs</code> 中的下面部分</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-footer"</span>&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span> <span class="attribute">data-id</span>=<span class="value">"&lt;%= post._id %&gt;"</span> <span class="attribute">class</span>=<span class="value">"article-share-link"</span>&gt;</span>Share<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">config.disqus_shortname</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"&lt;%- post.permalink %&gt;#disqus_thread"</span> <span class="attribute">class</span>=<span class="value">"article-comment-link"</span>&gt;</span>Comments<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%-</span> <span class="attribute">partial</span>('<span class="attribute">post</span>/<span class="attribute">tag</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer <span class="class"><span class="keyword">class</span></span>=<span class="string">"article-footer"</span>&gt;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span> <span class="attribute">data-id</span>=<span class="value">"&lt;%= post._id %&gt;"</span> <span class="attribute">class</span>=<span class="value">"article-share-link"</span>&gt;</span>Share<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">post.comments</span> &amp;&amp; <span class="attribute">config.duoshuo_shortname</span>)&#123; %&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"&lt;%- post.permalink %&gt;#duoshuo_thread"</span> <span class="attribute">class</span>=<span class="value">"article-comment-link"</span>&gt;</span>评论<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">%-</span> <span class="attribute">partial</span>('<span class="attribute">post</span>/<span class="attribute">tag</span>') %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>其次，</strong>将同一文件，即 <code>article.ejs</code> 中的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"disqus_thread"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">noscript</span>&gt;</span>Please enable JavaScript to view the <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"//disqus.com/?ref_noscript"</span>&gt;</span>comments powered by Disqus.<span class="tag">&lt;/<span class="title">a</span>&gt;</span><span class="tag">&lt;/<span class="title">noscript</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>修改成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"comments"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"duoshuo_thread"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-thread"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span>&gt;</span><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>至此，多说的评论功能基本可以用了。</p>
<h3 id="四、引入多说的分享插件(可选)">四、引入多说的分享插件(可选)</h3><p>在 <code>themes/(你的主题)/layout/_partial/article.ejs</code> 文件的末尾添加下列代码即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;</span><br><span class="line"></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share"</span> <span class="attribute">data-thread-key</span>=<span class="value">"&lt;%= post.slug %&gt;"</span> <span class="attribute">data-title</span>=<span class="value">"&lt;%= post.title %&gt;"</span> <span class="attribute">data-images</span>=<span class="value">""</span> <span class="attribute">data-content</span>=<span class="value">"&lt;%= post.content %&gt;"</span> <span class="attribute">data-url</span>=<span class="value">"&lt;%- post.permalink %&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-right"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-inner"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"ds-share-aside-toggle"</span>&gt;</span>分享<span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：请注意替换 <code>你的多说ID</code> 和 <code>你的主题</code></p>
</blockquote>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="一、添加多说ID(必须)">一、添加多说ID(必须)</h3><p>在根目录的 <code>_config.yml</code> 中定义 <code>duoshuo_shortname: (你的多说ID)</code> 形如</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Comments</span><br><span class="line">duoshuo_shortname: (你的多说ID)</span><br></pre></td></tr></table></figure>
<h3 id="二、引入多说JS(必须)">二、引入多说JS(必须)</h3>]]>
    
    </summary>
    
      <category term="github" scheme="http://bluestein.github.io/tags/github/"/>
    
      <category term="github pages" scheme="http://bluestein.github.io/tags/github-pages/"/>
    
      <category term="hexo" scheme="http://bluestein.github.io/tags/hexo/"/>
    
      <category term="Hexo" scheme="http://bluestein.github.io/categories/Hexo/"/>
    
      <category term="guide" scheme="http://bluestein.github.io/categories/Hexo/guide/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[18:类型转换]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-18/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-18/</id>
    <published>2015-11-28T08:50:29.000Z</published>
    <updated>2015-12-17T07:07:45.024Z</updated>
    <content type="html"><![CDATA[<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">val = <span class="number">3.14</span> + <span class="number">3</span>;	<span class="comment">//val = 6</span></span><br></pre></td></tr></table></figure>
<p>上面称为 <strong>隐式类型转换</strong>。</p>
<a id="more"></a>
<p><strong>1、发生隐式转换</strong></p>
<ul>
<li><p>混合表达式中，操作数被转化为相同类型</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iv;</span><br><span class="line"><span class="keyword">double</span> dv;</span><br><span class="line">iv += dv;	<span class="comment">//iv会被转换为double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为条件表达式转换为bool</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="keyword">if</span>(val)	<span class="comment">//int to bool</span></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>)	<span class="comment">//cin to bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用表达式初始化某变量，该表达式结果被转换为该变量的类型</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iv = <span class="number">3.14</span>;	<span class="comment">//3.14 to int</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>2、算术转换</strong></p>
<p><strong>signed 与 unsigned 类型间的转换</strong></p>
<ul>
<li><p>如果包含 short 和 int 类型的表达式，short 转换为int。如果 int 足够表示所有 unsigned short ，则将 unsigned short 转换为 int。</p>
</li>
<li><p>long 和 unsigned int 转换也一样，如果 long 足够表示所有 unsigned int ，则将 unsigned int 转换为 long。</p>
</li>
</ul>
<blockquote>
<p>在32机器中，long和int通常使用一个字长表示，因此包含 unsigned int 和 long 类型的表达式，都应该转换为 unsigned long</p>
</blockquote>
<ul>
<li>signed 和 unsigned int，signed转换成 unsigned int。</li>
</ul>
<p><strong>举例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> bv;</span><br><span class="line"><span class="keyword">char</span> cv;</span><br><span class="line"><span class="keyword">short</span> siv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> usiv;</span><br><span class="line"><span class="keyword">int</span> iv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> uiv;</span><br><span class="line"><span class="keyword">long</span> lv;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulv;</span><br><span class="line"><span class="keyword">float</span> fv;</span><br><span class="line"><span class="keyword">double</span> dv;</span><br><span class="line"><span class="number">3.14L</span> + <span class="string">'a'</span>;	<span class="comment">//'a' 先转换成 int，再转换成double</span></span><br><span class="line">dv + iv;	<span class="comment">//iv to double</span></span><br><span class="line">dv + fv;	<span class="comment">//fv to double</span></span><br><span class="line">iv = dv;	<span class="comment">//dv to(截断) int</span></span><br><span class="line">bv = dv;	<span class="comment">//if dv=0, bv = false, else bv = true</span></span><br><span class="line">cv + fv;	<span class="comment">//cv to int, then, int to float</span></span><br><span class="line">siv + cv;	<span class="comment">//siv and cv to int</span></span><br><span class="line">cv + lv;	<span class="comment">//cv to long</span></span><br><span class="line">iv + ulv;	<span class="comment">//iv to unsigned long</span></span><br><span class="line">usiv + iv;	<span class="comment">//依赖于 unsigned short 和 int 的大小</span></span><br><span class="line">uiv + lv;	<span class="comment">//依赖于 unsigned int 和 long 的大小</span></span><br></pre></td></tr></table></figure>
<p><strong>3、其他隐式转换</strong></p>
<p><strong>指针转换</strong></p>
<p>使用数组时，大多数情况下数组都会自动转化为指向第一个元素的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];	<span class="comment">//数组</span></span><br><span class="line"><span class="keyword">int</span> *ip = ia;	<span class="comment">//转化成指向第一个元素的指针</span></span><br></pre></td></tr></table></figure>
<p>还有另外两种指针转换：</p>
<ul>
<li>指向任意数据类型的指针都能够转化成 void*类型；</li>
<li>整型字面常量值 0 可以转换为任意指针类型；</li>
</ul>
<p><strong>转换为bool类型</strong></p>
<p>算术值和指针纸都可以转为bool类型。如果指针或算术值为0，则其bool值为false，其他则为true：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cp)	<span class="comment">/*...*/</span> <span class="comment">//true if not zero</span></span><br><span class="line"><span class="keyword">while</span>(*cp)	<span class="comment">/*...*/</span> <span class="comment">//convert char to bool</span></span><br></pre></td></tr></table></figure>
<p>while 语句对 <code>cp</code> 解引用，如果结果为 null ，则转化成false，否则转化成true</p>
<p><strong>算术类型与bool类型的转换</strong></p>
<p>可将算术类型转换成bool型，也可将bool型转换成int型。算术类型转bool时，0转换成false，其他转换成true；bool转int时，true转成1，false转成0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> ival = b;	<span class="comment">//ival == 1</span></span><br><span class="line"><span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = pi;	<span class="comment">//b2 is true</span></span><br><span class="line">pi = <span class="literal">false</span>; <span class="comment">//pi == 0</span></span><br></pre></td></tr></table></figure>
<p><strong>转化与枚举</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p3 = 3; p4 = 4</span></span><br><span class="line"><span class="keyword">enum</span> points &#123;p1 = <span class="number">2</span>, p3, p3 = <span class="number">3</span>, p4&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>转化为const类型</strong></p>
<p>使用非const对象初始化const对象的引用时，系统将非const对象转化成const对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;	<span class="comment">//ok: 将非const对象转化成const对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;ci;	<span class="comment">//ok: 将非const对象的地址转化为指向const类型的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>由标准库类型定义的转换</strong></p>
<p>典型的例子就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; s)</span><br></pre></td></tr></table></figure>
<p>该表达式 <code>cin&gt;&gt;s</code> 的结果 <code>cin</code> 对象，为istream对象，所以此时会将其转化成bool类型。</p>
<h3 id="4、显式转换">4、显式转换</h3><p>显式转换也称为<strong>强制类型转换（cast）</strong>，有以下操作符：static_cast, dynamic_cast, const_cast, reinterpret_cast。</p>
<p><strong>何时需要强制转换</strong></p>
<p>例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line">ival *= dval;</span><br></pre></td></tr></table></figure>
<p>上述程序首先会将 ival 转换为 double 型，乘法操作后又将double型的结果转成int型。为了避免不必要的转换，可以如下操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ival *= <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(dval);</span><br></pre></td></tr></table></figure>
<p><strong>命名的强制类型转换</strong></p>
<p>形式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>
<p>cast-name的选择有</p>
<ul>
<li><p>static_cast: 编译器隐式执行的任何类型转换都可以通过 static_cast 显式完成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">char</span> ch = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(d);</span><br><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);	<span class="comment">//可以找回存在void*中的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dynamic_cast: 支持运行时识别指针或引用所指的对象。</p>
</li>
<li><p>const_cast: 去掉表达式的const性质</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ccp;</span><br><span class="line"><span class="keyword">char</span> *cp = string_copy(<span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(ccp));</span><br><span class="line"><span class="comment">//使string_copy接受const char*类型的参数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>reinterpret_cast: 通常为操作数的位模式提供较低层次的重新解释</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>cp 所指的真实对象时 int 类型，所以不能用来初始化 string 对象。</p>
<p>type表示目标类型，expression表示被转换的表达式。</p>
<blockquote>
<p>避免使用强制类型转换</p>
</blockquote>
<p><strong>旧式的强制转换</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = (<span class="keyword">char</span>*) ip;</span><br></pre></td></tr></table></figure>
<p>这种方式不容易错误跟踪，可视性差。</p>
<blockquote>
<p>C++仍旧支持旧式强制转换，但不推荐这样做。除非在C语言下，或旧式编译器上才使用。</p>
</blockquote>
<p>END.</p>
<hr>
<p>Github Pages同步更新<br>Github Pages: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">val = <span class="number">3.14</span> + <span class="number">3</span>;	<span class="comment">//val = 6</span></span><br></pre></td></tr></table></figure>
<p>上面称为 <strong>隐式类型转换</strong>。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[17:new & delete]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-17/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-17/</id>
    <published>2015-11-27T08:50:24.000Z</published>
    <updated>2015-11-30T02:57:58.047Z</updated>
    <content type="html"><![CDATA[<p><strong>1、动态创建对象的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>);	<span class="comment">//*ip = 1024</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">'9'</span>)</span></span>;	<span class="comment">//s = "9999999999"</span></span><br><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>);	<span class="comment">//*sp = "9999999999"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>2、动态创建对象的默认初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>;	<span class="comment">//空string</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;	<span class="comment">//未初始化</span></span><br></pre></td></tr></table></figure>
<p>可以利用下列方式进行默认初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>();	<span class="comment">//空string</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>();	<span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p><strong>3、撤销动态创建对象</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;i;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"str"</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="keyword">int</span> *ip0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> s;	<span class="comment">//error: s是非动态对象</span></span><br><span class="line"><span class="keyword">delete</span> ip;	<span class="comment">//error: ip指向本地对象</span></span><br><span class="line"><span class="keyword">delete</span> dp;	<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">delete</span> ip0;	<span class="comment">//ok: 但没什么意义</span></span><br></pre></td></tr></table></figure>
<p>C++未明确定义如何释放非new分配的内存地址。</p>
<p><strong>4、delete后重设指针的值</strong></p>
<p>执行delete语句后，尽管指针变成未定义，但仍存放了之前所指对象的地址，称为 <strong>悬挂指针（dangling pointer）</strong> 。这种指针往往容易出错。</p>
<blockquote>
<p>一旦delete指针，立即将其置为0，就可以避免悬挂指针。</p>
</blockquote>
<p><strong>5、const对象的动态分配和回收</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cip = <span class="keyword">new</span> <span class="function"><span class="keyword">const</span> <span class="title">int</span><span class="params">(<span class="number">1024</span>)</span></span>;	<span class="comment">//必须初始化，且不能再修改</span></span><br></pre></td></tr></table></figure>
<p>如果有默认构造函数，则可以隐式初始化，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *csp = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>尽管不能改变const对象的值，但可撤销对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> cip;	<span class="comment">//ok</span></span><br><span class="line">cip = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、动态创建对象的初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">i</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span> (<span class="number">1024</span>);	<span class="comment">//*ip = 1024</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">'9'</span>)</span></span>;	<span class="comment">//s = "9999999999"</span></span><br><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>);	<span class="comment">//*sp = "9999999999"</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[16:赋值操作和自增自减]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-16/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-16/</id>
    <published>2015-11-26T08:50:15.000Z</published>
    <updated>2015-11-30T02:57:58.044Z</updated>
    <content type="html"><![CDATA[<p>本次内容是：复合表达式的求值。尤其是 <strong>优先级</strong> 和 <strong>结合性</strong> 部分可以作为字典查看。</p>
<h3 id="1、优先级">1、优先级</h3><p>在表达式求解过程中，优先级关系到表示如何分组，会影响整个表达式的值。其次是结合性，当优先级相同时，结合性决定求解次序。算术操作符具有左结合性，即从左至右结合</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">2</span> * <span class="number">3</span> / <span class="number">2</span> - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = <span class="number">2</span> * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> tmp2 = tmp / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> tmp3 = tmp2 + <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> result = tmp3 - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>括号可以改变优先级，括号内的表达式先行计算。</p>
</blockquote>
<h3 id="2、结合性">2、结合性</h3><p>结合性规定了具有相同优先级的操作符如何分组。如 <strong>赋值操作符</strong> <code>=</code> 具有右结合性，所以允许将多个赋值操作串连起来：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 = val2 = val3;</span><br><span class="line">(val1 = (val2 = val3));	<span class="comment">//与上式等价</span></span><br></pre></td></tr></table></figure>
<p>而 <strong>算术操作符</strong> 具有右结合性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val1 * val2 / val3;</span><br><span class="line">((val1 * val2) / val3);	<span class="comment">//与上式等价</span></span><br></pre></td></tr></table></figure>
<p>下表是按照优先级顺序给出操作符，并用空行分成不同的段，每段内的优先级相同，且都高于后面各段的优先级。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>结合性</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>::</td>
<td>L</td>
<td>全局作用域</td>
<td>::name</td>
</tr>
<tr>
<td>::</td>
<td>L</td>
<td>类作用域</td>
<td>class::name</td>
</tr>
<tr>
<td>::</td>
<td>L</td>
<td>名字空间作用域</td>
<td>namespace::name</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>.</td>
<td>L</td>
<td>成员选择</td>
<td>object.member</td>
</tr>
<tr>
<td>-&gt;</td>
<td>L</td>
<td>成员选择</td>
<td>pointer-&gt;member</td>
</tr>
<tr>
<td>[]</td>
<td>L</td>
<td>下标</td>
<td>variable[expr]</td>
</tr>
<tr>
<td>()</td>
<td>L</td>
<td>函数调用</td>
<td>name(expr_list)</td>
</tr>
<tr>
<td>()</td>
<td>L</td>
<td>函数构造</td>
<td>type(expr_list)</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>++</td>
<td>R</td>
<td>后自增</td>
<td>lvalue++</td>
</tr>
<tr>
<td>–</td>
<td>R</td>
<td>后自减</td>
<td>lvalue–</td>
</tr>
<tr>
<td>typeid</td>
<td>R</td>
<td>类型ID</td>
<td>typeid(type)</td>
</tr>
<tr>
<td>typeid</td>
<td>R</td>
<td>运行时ID</td>
<td>typeid(expr)</td>
</tr>
<tr>
<td>显式强制类型转换</td>
<td>R</td>
<td>类型转换</td>
<td>cast_name<type>(expr)</type></td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>sizeof</td>
<td>R</td>
<td>对象大小</td>
<td>sizeof expr</td>
</tr>
<tr>
<td>sizeof</td>
<td>R</td>
<td>类型大小</td>
<td>sizeof(type)</td>
</tr>
<tr>
<td>++</td>
<td>R</td>
<td>前自增</td>
<td>++lvalue</td>
</tr>
<tr>
<td>–</td>
<td>R</td>
<td>前自减</td>
<td>–lvalue</td>
</tr>
<tr>
<td>~</td>
<td>R</td>
<td>位求反</td>
<td>~expr</td>
</tr>
<tr>
<td>!</td>
<td>R</td>
<td>逻辑非</td>
<td>!expr</td>
</tr>
<tr>
<td>-</td>
<td>R</td>
<td>一元负号</td>
<td>-expr</td>
</tr>
<tr>
<td>+</td>
<td>R</td>
<td>一元正号</td>
<td>+expr</td>
</tr>
<tr>
<td>*</td>
<td>R</td>
<td>解引用</td>
<td>*expr</td>
</tr>
<tr>
<td>&amp;</td>
<td>R</td>
<td>取地址</td>
<td>&amp;expr</td>
</tr>
<tr>
<td>()</td>
<td>R</td>
<td>类型转换</td>
<td>(type)expr</td>
</tr>
<tr>
<td>new</td>
<td>R</td>
<td>创建对象</td>
<td>new type</td>
</tr>
<tr>
<td>delete</td>
<td>R</td>
<td>释放对象</td>
<td>delete expr</td>
</tr>
<tr>
<td>delete[]</td>
<td>R</td>
<td>释放数组</td>
<td>delete[] expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>-&gt;*</td>
<td>L</td>
<td>指向成员操作的指针</td>
<td>ptr-&gt;*ptr_to_member</td>
</tr>
<tr>
<td>.*</td>
<td>L</td>
<td>指向成员操作的指针</td>
<td>obj.*ptr_to_member</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>*</td>
<td>L</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>/</td>
<td>L</td>
<td>除法</td>
<td>expr / expr</td>
</tr>
<tr>
<td>%</td>
<td>L</td>
<td>求模（求余）</td>
<td>expr % expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>+</td>
<td>L</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>L</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>L</td>
<td>位左移</td>
<td>expr &lt;&lt; expr</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>L</td>
<td>为右移</td>
<td>expr &gt;&gt; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&lt;</td>
<td>L</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>&lt;=</td>
<td>L</td>
<td>小等于</td>
<td>expr &lt;= expr</td>
</tr>
<tr>
<td>&gt;</td>
<td>L</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>&gt;=</td>
<td>L</td>
<td>大等于</td>
<td>expr &gt;= expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>==</td>
<td>L</td>
<td>等于</td>
<td>expr == expr</td>
</tr>
<tr>
<td>!=</td>
<td>L</td>
<td>不等于</td>
<td>expr != expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&amp;</td>
<td>L</td>
<td>位与</td>
<td>expr &amp; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>^</td>
<td>L</td>
<td>位异或</td>
<td>expr ^ expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&#124;</td>
<td>L</td>
<td>位或</td>
<td>expr &#124; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>L</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>&#124;&#124;</td>
<td>L</td>
<td>逻辑或</td>
<td>expr &#124;&#124; expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>?:</td>
<td>R</td>
<td>条件操作</td>
<td>expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>=</td>
<td>R</td>
<td>赋值操作</td>
<td>lvalue = expr</td>
</tr>
<tr>
<td>*=, /=, %=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr *= expr等</td>
</tr>
<tr>
<td>+=, -=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr += expr等</td>
</tr>
<tr>
<td>&lt;&lt;=, &gt;&gt;=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr &lt;&lt;= expr等</td>
</tr>
<tr>
<td>&amp;=, &#124;=, ^=</td>
<td>R</td>
<td>复合赋值操作</td>
<td>expr &amp;= expr等</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>throw</td>
<td>R</td>
<td>抛出异常</td>
<td>throw expr</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>,</td>
<td>R</td>
<td>逗号</td>
<td>expr, expr</td>
</tr>
</tbody>
</table>
<p><strong>举例</strong></p>
<p>考虑：如果字符串不是以’s’结尾则加上’s’，分析下列语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = s + s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>;</span><br></pre></td></tr></table></figure>
<p>分析：</p>
<p>根据上表知道优先级为：<code>.</code> = <code>()</code> = <code>[]</code> &gt; <code>-</code> = <code>+</code> &gt; <code>==</code> &gt; <code>?:</code> &gt; <code>=</code>；可知上述语句的结合顺序是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">string</span> s = (((s + (s[(s.size()) - <span class="number">1</span>])) == <span class="string">'s'</span>) ? <span class="string">""</span> : <span class="string">"s"</span>));</span><br></pre></td></tr></table></figure>
<p>很明显不能得到想要的结果，改成如下形式即可</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = s + (s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>);</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本次内容是：复合表达式的求值。尤其是 <strong>优先级</strong> 和 <strong>结合性</strong> 部分可以作为字典查看。</p>
<h3 id="1、优先级">1、优先级</h3><p>在表达式求解过程中，优先级关系到表示如何分组，会影响整个表达式的值。其次是结合性，当优先级相同时，结合性决定求解次序。算术操作符具有左结合性，即从左至右结合</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ demo: 输入多个string对象，并存放在vector中]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-demo-2/"/>
    <id>http://bluestein.github.io/2015/11/cpp-demo-2/</id>
    <published>2015-11-25T14:01:42.000Z</published>
    <updated>2015-12-03T07:06:20.728Z</updated>
    <content type="html"><![CDATA[<p>编写程序：读入一组string类型数据，将它们存储在vector中，然后将vector中的对象复制给一个字符指针数组。即为vector中的每个元素创建一个新的字符数组，然后把vector元素的数据复制到相应的字符数组中，最后将指针插入到指针数组中。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">		svec.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> **cp_arr = <span class="keyword">new</span> <span class="keyword">char</span>*[svec.size()];<span class="comment">//指针数组</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = svec.begin(); iter != svec.end(); ++iter) &#123;</span><br><span class="line">		<span class="built_in">string</span> s = *iter;</span><br><span class="line">		<span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[s.size()+<span class="number">1</span>];<span class="comment">//+1表示为null结束符预留空间</span></span><br><span class="line">		<span class="built_in">strncpy</span>(cp, s.c_str(), s.size()+<span class="number">1</span>);</span><br><span class="line">		cp_arr[cnt] = cp;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != cnt; ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cp_arr[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] cp_arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] cp_arr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world↙</span><br><span class="line">^Z↙</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写程序：读入一组string类型数据，将它们存储在vector中，然后将vector中的对象复制给一个字符指针数组。即为vector中的每个元素创建一个新的字符数组，然后把vector元素的数据复制到相应的字符数组中，最后将指针插入到指针数组中。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/tags/C-Demo/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/categories/Dev/C-Demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[15:赋值操作和自增自减]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-15/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-15/</id>
    <published>2015-11-25T08:50:10.000Z</published>
    <updated>2015-11-30T02:57:58.041Z</updated>
    <content type="html"><![CDATA[<p><strong>1、赋值操作</strong></p>
<p>赋值的左操作数必须是非const左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;	<span class="comment">//ok</span></span><br><span class="line"><span class="number">1024</span> = val;		<span class="comment">//error: 字面值是右值</span></span><br><span class="line">i + j = val;	<span class="comment">//error: 算术运算结果是右值</span></span><br><span class="line">ci = val;		<span class="comment">//error: 不能赋值</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>右结合性</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val1, val2;</span><br><span class="line">val1 = val2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>上述语句将 val2 赋给 val1.但下面是错误的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val, *p;</span><br><span class="line">val = p = <span class="number">0</span>;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>上面: <code>p=0</code> 成立，但 <code>val = p</code> 出错。</p>
<p><strong>复合赋值操作符</strong></p>
<table>
<thead>
<tr>
<th>说明</th>
<th>操作符</th>
</tr>
</thead>
<tbody>
<tr>
<td>算术操作符</td>
<td>+= -= *= /= %=</td>
</tr>
<tr>
<td>位操作符</td>
<td>&lt;&lt;= &gt;&gt;= &amp;= ^= &#124;=</td>
</tr>
</tbody>
</table>
<p>使用方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a op= b;	<span class="comment">//op表示操作符</span></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = a op b;</span><br></pre></td></tr></table></figure>
<p><strong>2、自增自减</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;	<span class="comment">//j = 1, i = 1; ++i返回自增后的结果</span></span><br><span class="line">j = i++;	<span class="comment">//j = 1, i = 2; i++返回未自增的结果</span></span><br></pre></td></tr></table></figure>
<p><strong>组合使用解引用和自增</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = ivec.begin();</span><br><span class="line"><span class="keyword">while</span>(iter != ivec.end())&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++　&lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自增的优先级高于解引用，即相当于 <code>*(iter++)</code>。</p>
<p><strong>箭头操作符</strong></p>
<p>C++为包含 <strong>点操作</strong> 和 <strong>解引用</strong> 的表达式提供 <strong>箭头操作符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Item *p = &amp;item1;</span><br><span class="line">(*p).func();	<span class="comment">//1</span></span><br><span class="line">p-&gt;func();		<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>1,2 等价。</p>
<p><strong>举例</strong></p>
<p>编写程序：定义vector对象，其每个元素指向string类型的指针；输出每个元素的内容及长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt; v;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(s);</span><br><span class="line">	v.push_back(sp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt;::iterator iter = v.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != v.end()) &#123;</span><br><span class="line">	<span class="built_in">string</span> *tmp = *iter;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; tmp-&gt;size() &lt;&lt; <span class="string">", "</span> &lt;&lt; *tmp &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> tmp;</span><br><span class="line">	iter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world!↙</span><br><span class="line">^Z↙</span><br><span class="line"><span class="number">5</span>, hello</span><br><span class="line"><span class="number">6</span>, world!</span><br></pre></td></tr></table></figure>
<p><strong>条件操作符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<p>先计算 <code>cond</code> 的值，如果为true，则计算 <code>expr1</code>，否则计算 <code>expr2</code>。可以嵌套使用，如：求三个数的最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = i &gt; j</span><br><span class="line">	? i &gt; k ? i : k</span><br><span class="line">	: j &gt; k ? j : k;</span><br></pre></td></tr></table></figure>
<p>但并不推荐这样做，可以换成下列代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> max = i;</span><br><span class="line"><span class="keyword">if</span> (j &gt; max)</span><br><span class="line">	max = j;</span><br><span class="line"><span class="keyword">if</span> (k &gt; max)</span><br><span class="line">	max = k;</span><br></pre></td></tr></table></figure>
<p>输出表达式中使用条件操作符</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j?i:j) &lt;&lt;endl;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j)?i:j;	<span class="comment">//打印1或0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i&lt;j?i:j &lt;&lt;endl;		<span class="comment">//error: 将cout与int比较</span></span><br></pre></td></tr></table></figure>
<p>第二句相当于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (i&lt;j);	<span class="comment">//打印1或0，然后返回cout对象</span></span><br><span class="line"><span class="built_in">cout</span> ? i : j;	<span class="comment">//检测cout，然后计算i或j</span></span><br></pre></td></tr></table></figure>
<p><strong>sizeof操作符</strong></p>
<p>返回一个对象或类型名的长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type_name);</span><br><span class="line"><span class="keyword">sizeof</span>(expr);</span><br><span class="line"><span class="keyword">sizeof</span> expr;</span><br></pre></td></tr></table></figure>
<ul>
<li>对char类型或char类型值做sizeof结果为1；</li>
<li>对指针，返回存放该指针所需的内存；若需要获得指针所指内容，需要解引用操作；</li>
<li>对数组，等价于对数组元素做sizeof再乘以元素的个数；</li>
</ul>
<p><strong>逗号操作符</strong></p>
<p>是一组由逗号分隔的表达式，这些表达式从左至右计算，结果是其最右边的表达式值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt = vec.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != vec.size(); ++ix, --cnt)</span><br><span class="line">	vec[ix] = cnt;</span><br></pre></td></tr></table></figure>
<p>每次循环，ix自增1，cnt自减1.</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>1、赋值操作</strong></p>
<p>赋值的左操作数必须是非const左值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j, val;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;	<span class="comment">//ok</span></span><br><span class="line"><span class="number">1024</span> = val;		<span class="comment">//error: 字面值是右值</span></span><br><span class="line">i + j = val;	<span class="comment">//error: 算术运算结果是右值</span></span><br><span class="line">ci = val;		<span class="comment">//error: 不能赋值</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[14:位操作符]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-14/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-14/</id>
    <published>2015-11-24T08:50:05.000Z</published>
    <updated>2015-11-30T02:57:58.038Z</updated>
    <content type="html"><![CDATA[<p>位操作符：位操作符操作的整数可以是有符号或无符号数。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>求位反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>&#124;</td>
<td>位或</td>
<td>expr1 &#124; expr2</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>下面的例子，假设unsigned char有8位：</p>
<ul>
<li><p><code>~</code>: 类似于bitset的flip操作，即将操作数的每一个二进制位取反，将0置为1,1置为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">0227</span>;	<span class="comment">//八进制数，二进制形式：10010111</span></span><br><span class="line">bits = ~bits;	<span class="comment">//二进制形式：01101000</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>: 向右或向左移动若干位，并丢弃移出去的位，一般来说空位补零</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = <span class="number">1</span>;	<span class="comment">//二进制形式：00000001</span></span><br><span class="line">bits = bits &lt;&lt; <span class="number">6</span>;	<span class="comment">//二进制形式：01000000；对应十进制：64</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt;endl;	<span class="comment">//64对应的字符为 bits = '@'</span></span><br><span class="line"><span class="keyword">int</span> n = bits;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; endl;	<span class="comment">//n = 64</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>&amp;</code>: 两操作数都为1时，结果为1，否则为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c1 = <span class="number">0145</span>;	<span class="comment">//八进制数，二进制形式：01100101</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c2 = <span class="number">0257</span>;	<span class="comment">//八进制数，二进制形式：10101111</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 &amp; c2;	<span class="comment">//二进制形式：00100101</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为37，字符为 '÷'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>^</code>: 两个操作数中只有一个位1时（不能同时两个为1），结果为1，否则为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 ^ c2;	<span class="comment">//二进制形式：11001010</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为202</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>|</code>: 两个操作数都为0时，结果为0，否则为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> bits = c1 | c2;	<span class="comment">//二进制形式：11101011</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; bits &lt;&lt; endl;	<span class="comment">//对应的十进制为239</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>bitset对象或整型值的使用</strong></p>
<p>unsigned long 有 32 位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span>&lt;30&gt; bset;	<span class="comment">//大小为30的bitset，每一位默认值0</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果要将第27位设为1，有如下两种方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bset.<span class="built_in">set</span>(<span class="number">27</span>);		<span class="comment">//法1</span></span><br><span class="line">val |= <span class="number">1U</span>L &lt;&lt; <span class="number">27</span>;	<span class="comment">//法2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>法1简单明了；</li>
<li>法2：将val与另一个整数坐位或 <code>|</code> 比较。即需要一个只有第27位为1其他位为0的无符号长整型（unsigned long）整数，可以用下面方法生成<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1U</span>L &lt;&lt; <span class="number">27</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果要将第27位重新设为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &amp;= ~(<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p>而要测试第27位是否为1，则可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_1 = val &amp; (<span class="number">1U</span>L &lt;&lt; <span class="number">27</span>);</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> val1 = <span class="number">3</span>, val2 = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (val1 &amp; val2) &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (val1 | val2) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>因为unsigned long有32位，所以 3 对应二进制位为：<code>0(30个0)11</code>； 8 的二进制：<code>0(28个0)1000</code></p>
<ul>
<li><code>val1 &amp; val2</code>: 0(28个0)0000; 对应的十进制为 0</li>
<li><code>val1 | val2</code>: 0(28个0)1011; 对应的十进制为 11</li>
</ul>
<blockquote>
<p>通常来说，bitset更易阅读和理解。</p>
</blockquote>
<p><strong>将移位操作符用于IO</strong></p>
<p>一直再用的 <code>cout&lt;&lt;</code> 和 <code>cin&gt;&gt;</code> 就用到了移位操作符，IO操作符是左结合的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"he"</span> &lt;&lt; <span class="string">"llo"</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="built_in">cout</span> &lt;&lt; <span class="string">"he"</span>) &lt;&lt; <span class="string">"llo"</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span>+<span class="number">10</span>;	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">10</span>&gt;<span class="number">2</span>);	<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> &gt; <span class="number">2</span>;	<span class="comment">//error: 试图将 cout 与 2 比较</span></span><br></pre></td></tr></table></figure>
<p>上例因为 <code>+</code> 优先级高于<code>&gt;&gt;</code>， 而  <code>&gt;</code> 低于 <code>&gt;&gt;</code>。 </p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>位操作符：位操作符操作的整数可以是有符号或无符号数。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>~</td>
<td>求位反</td>
<td>~expr</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>expr1 &lt;&lt; expr2</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>expr1 &gt;&gt; expr2</td>
</tr>
<tr>
<td>&amp;</td>
<td>位与</td>
<td>expr1 &amp; expr2</td>
</tr>
<tr>
<td>^</td>
<td>位异或</td>
<td>expr1 ^ expr2</td>
</tr>
<tr>
<td>&#124;</td>
<td>位或</td>
<td>expr1 &#124; expr2</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[13:算术操作符]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-13/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-13/</id>
    <published>2015-11-23T08:50:00.000Z</published>
    <updated>2015-11-30T02:57:58.035Z</updated>
    <content type="html"><![CDATA[<p>这里开始第五章《表达式》的内容。下面是 <strong>算术操作符</strong> 的内容</p>
<p>C++有丰富的操作符，并定义了当操作数是内置类型时操作符的含义。而且C++还支持操作符重载，标准库正是使用该功能定义。</p>
<a id="more"></a>
<p>表达式是由一个或多个 <strong>操作数（operand）</strong> 通过 <strong>操作符（operator）</strong> 组合而成。每个表达式会产生一个结果，如果表达式中无操作符，则表达式的结果就是操作数本身。如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val)</span><br><span class="line">	<span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>将 <code>val</code> 看作是if语句的条件表达式。</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>一元正号</td>
<td>+ expr</td>
</tr>
<tr>
<td>-</td>
<td>一元负号</td>
<td>- expr</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td>expr * expr</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td>expr / expr</td>
</tr>
<tr>
<td>%</td>
<td>求余（操作数只能为整型）</td>
<td>expr % expr</td>
</tr>
<tr>
<td>+</td>
<td>加法</td>
<td>expr + expr</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td>expr - expr</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注： expre 为表达式</p>
</blockquote>
<p>求模 <code>%</code> 符号：</p>
<ul>
<li>当两个操作数都是正数（或0）时，结果为正；</li>
<li>当两个操作数都是负数，结果为负（或0）</li>
<li>一正一负时，求模结果的符号取决于机器；</li>
</ul>
<p>在我的机器上有</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">10</span> % -<span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> % -<span class="number">3</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看出：我的机器上，求模结果的符号随分子确定（除出来的值向负无穷一侧取整）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; -<span class="number">30</span>/<span class="number">3</span>*<span class="number">21</span>%<span class="number">4</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">30</span>/<span class="number">3</span>*<span class="number">21</span>%<span class="number">5</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>关系操作符和逻辑运算符</strong></p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>功能</th>
<th>用法</th>
</tr>
</thead>
<tbody>
<tr>
<td>!</td>
<td>逻辑非</td>
<td>! expr</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
<td>expr &lt; expr</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小等于</td>
<td>expr &lt;= expr</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
<td>expr &gt; expr</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大等于</td>
<td>expr &gt;= expr</td>
</tr>
<tr>
<td>==</td>
<td>相等</td>
<td>expr == expr</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
<td>expr != expr</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
<td>expr &amp;&amp; expr</td>
</tr>
<tr>
<td>(两个竖线)</td>
<td>逻辑或</td>
<td>expr (两个竖线) expr</td>
</tr>
</tbody>
</table>
<blockquote>
<p>注： 由于简书markdown格式问题，不能在表格中打出逻辑或 <code>||</code> 符号。</p>
</blockquote>
<p>上述操作符产生的结果均是bool值。</p>
<ul>
<li><code>!</code>: expr为真时， !expr为假；</li>
<li><code>&amp;&amp;</code>: expr1和expr2都为真时， expr1 &amp;&amp; expr2 结果为真，否则为假；</li>
<li><code>||</code>: expr1和expr2都为假时， expr1 &amp;&amp; expr2 结果为假，否则为真；</li>
</ul>
<p>其中，<code>&amp;&amp;</code> 与 <code>||</code> 操作符只有当 expr1的值不能确定整个表达式的值时，才会解第二个expr2的值，称为 <strong>短路求值（short-circuit evaluation）</strong>。</p>
<blockquote>
<p>不能串接使用关系操作符（逻辑操作符可以）： <code>if(i &lt; j &lt; k)</code> 是错误的。</p>
</blockquote>
<p>下面有一个很有趣的程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">while</span> (cp &amp;&amp; *cp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cp &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">	++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">h</span><br><span class="line">ello</span><br><span class="line">e</span><br><span class="line">llo</span><br><span class="line">l</span><br><span class="line">lo</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
<p><strong>举例</strong></p>
<p>编写程序：判断四个值a、b、c、d是否满足 a&gt;b、b&gt;c且c&gt;d。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">2</span>, c = <span class="number">1</span>, d = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (a &gt; b &amp;&amp; b &gt; c &amp;&amp; c &gt; d) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述 <code>&amp;&amp;</code> 表达式也会采用 <strong>短路求值</strong> 法求解</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这里开始第五章《表达式》的内容。下面是 <strong>算术操作符</strong> 的内容</p>
<p>C++有丰富的操作符，并定义了当操作数是内置类型时操作符的含义。而且C++还支持操作符重载，标准库正是使用该功能定义。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[12:C风格字符串]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-12/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-12/</id>
    <published>2015-11-22T08:49:54.000Z</published>
    <updated>2015-11-30T02:57:58.033Z</updated>
    <content type="html"><![CDATA[<p>前面的内容我们使用过字符串字面值，并了解字符串字面值的类型是字符常量的数组，现在可以更加明确的认识到：<strong>字符串字面值的类型就是 const char 类型的数组</strong>。C++从C继承下来的一种通用的结构是<strong>C风格字符串（C-Style character string）</strong>，字符串字面值就是该类型的实例。实际上，C风格字符串既不能确切的归结为C语言类型，也不能归结为C++的类型，而是以空字符 <code>null</code> 结束的字符数组：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;		<span class="comment">//c1 维数为3，not c-style</span></span><br><span class="line"><span class="keyword">char</span> c2[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;	<span class="comment">//c2 维数为4</span></span><br><span class="line"><span class="keyword">char</span> c3[] = <span class="string">"C++"</span>;					<span class="comment">//c3 维数为4，自动添加空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"C++"</span>;		<span class="comment">//自动添加空字符</span></span><br><span class="line"><span class="keyword">char</span> *cp1 = c1;		<span class="comment">//指向c1数组的第一个元素，not c-style</span></span><br><span class="line"><span class="keyword">char</span> *cp2 = c2;		<span class="comment">//指向c1数组的第一个元素，以空字符 `null` 结束的字符数组</span></span><br></pre></td></tr></table></figure>
<p><code>c1</code> 和 <code>cp1</code> 都不是C风格字符串：<code>c1</code> 是不带结束符 <code>null</code> 的字符数组。其他都是C风格字符串。</p>
<h3 id="1、C风格字符串的使用">1、C风格字符串的使用</h3><hr>
<p>C++通过 (const) char* 类型的指针来操作C风格的字符串。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">	++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C</span><br><span class="line">+</span><br><span class="line">+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果cp指向的字符数组没有 null 结束符，作为循环会失败。这时循环继续进行，知道遇到内存中某处的 null 结束符。</p>
</blockquote>
<h3 id="2、C风格字符串的标准库函数">2、C风格字符串的标准库函数</h3><hr>
<p>下表类除了C语言标准库函数提供的一系列处理C风格字符串的库函数，这些库函数包含在 string.h 中。</p>
<table>
<thead>
<tr>
<th>库函数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>strlen(s)</td>
<td>返回s的长度，不包括null结束符</td>
</tr>
<tr>
<td>strcmp(s1, s2)</td>
<td>比较s1和s2是否相同。s1等于s2,返回0;s1大于s2，返回正数；s1小于s2，返回负数</td>
</tr>
<tr>
<td>strcat(s1, s2)</td>
<td>将字符串s2连接到s1后面，返回s1</td>
</tr>
<tr>
<td>strcpy(s1, s2)</td>
<td>将s2复制给s2，返回s1</td>
</tr>
<tr>
<td>strncat(s1, s2, n)</td>
<td>将s2的前n个字符连接到s1后面，并返回s1</td>
</tr>
<tr>
<td>strncpy(s1, s2, n</td>
<td>将s2的前n个字符赋给s1，并返回s1</td>
</tr>
</tbody>
</table>
<p>传递给这些函数的指针必须具有非零值，并且指向以null结束的字符数组中的第一个元素。并且要确保目标字符串必须有足够大的空间存放结果串。</p>
<p><strong>字符串的比较和比较结果都必须使用标准库函数 strcmp 进行</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp1 = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp2 = <span class="string">"C"</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="built_in">strcmp</span>(cp1, cp2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl; </span><br><span class="line">i = <span class="built_in">strcmp</span>(cp2, cp1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="built_in">strcmp</span>(cp1, cp1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line">-<span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>不要忘记字符串结束符null</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123; <span class="string">'c'</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(c) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出结果是不可预料的，因为会一直寻找null结束符，然后再输出。比如在我的电脑是输出是 <code>324</code>，这明显是错误的，在不同的电脑会输出不同的值。</p>
<p><strong>必须确保目标字符串有足够的大小</strong></p>
<p>库函数 strcat 和 strcpy 的第一个参数必须有足够大的空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp1 = <span class="string">"C++"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp2 = <span class="string">"C"</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, cp1);</span><br><span class="line"><span class="built_in">strcat</span>(str, <span class="string">" "</span>);</span><br><span class="line"><span class="built_in">strcat</span>(str, cp2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C++ C</span><br></pre></td></tr></table></figure>
<p>上述程序就目前来看是完全没问题的，但如果 cp1 和 cp2 指向的字符串大小发生了改变，str 所需的大小就不满足要求了。会导致严重的安全漏洞。</p>
<p><strong>strn函数处理C风格的字符串</strong></p>
<p>如果必须处理C风格字符串，strncat，strncpy会比strcat，strcpy更安全</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">3</span> + <span class="number">1</span> + <span class="number">2</span>];</span><br><span class="line"><span class="built_in">strncpy</span>(str, cp1, <span class="number">4</span>);	<span class="comment">//1. 包含null</span></span><br><span class="line"><span class="built_in">strncat</span>(str, <span class="string">" "</span>, <span class="number">2</span>);	<span class="comment">//2. 包含null，看起来冗余，但是个好习惯</span></span><br><span class="line"><span class="built_in">strncat</span>(str, cp2, <span class="number">2</span>);	<span class="comment">//3. 要包含null</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>分步骤解释：</p>
<ul>
<li><ol>
<li>strncpy cp1 时需要复制 4 个字符：cp1 中所有字符，加上 null 结束符；此时 strlen(str) = 3.</li>
</ol>
</li>
<li><ol>
<li>strncat “ “ 时需要复制 2 个字符：一个空格字符，加上 null 结束符；此时空格符会把步骤1复制的 null 结束符覆盖。此时 strlen(str) = 4.</li>
</ol>
</li>
<li><ol>
<li>strncat cp2 时需要复制 2 个字符：cp2 中所有字符，加上 null 结束符；此时 strlen(str) = 6.</li>
</ol>
</li>
</ul>
<p>最后 str 的内容：cp1 和 cp2 中所有字符，一个空格，和一个null结束符。</p>
<p><strong>尽可能使用string类型</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = cp1;</span><br><span class="line">str += <span class="string">" "</span>;</span><br><span class="line">str += cp2;</span><br></pre></td></tr></table></figure>
<p>可以达到上面一样的效果。</p>
<h3 id="3、创建动态数组">3、创建动态数组</h3><hr>
<p>数组类型的限制：长度不变；编译时须知道长度；数组只在定义它的语句内存在。可以使用动态分配解决这一问题，跟C中的malloc和free类似，C++中使用 <strong>new</strong> 和 <strong>delete</strong> 实现。</p>
<h4 id="3-1、定义">3.1、定义</h4><p>数组变量需要指定类型、数组名和维数定义，而动态分配的数组只需指定类型和长度，不必为数组对象命名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h4 id="3-2、初始化">3.2、初始化</h4><p>动态分配的数组，如果有类型，则使用类型的默认构造函数初始化；如果是内置类型，则无初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];	<span class="comment">//初始化为10个空字符串</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];		<span class="comment">//不初始化</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">10</span>]();	<span class="comment">//初始化为10个0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>圆括号要求编译器对数组进行初始化；<br>动态分配的数组，其元素只能初始化为默认值，而不能像变量一样提供初始化列表进行初始化</p>
</blockquote>
<h4 id="3-3、const对象的动态数组">3.3、const对象的动态数组</h4><p>必须为该数组提供初始化值，因为数组内都是const对象，无法赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *caip_bad = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>];	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *caip_ok = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>]();	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>也可以定义类类型的const数组，但该类型必须提供默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *csp = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>[<span class="number">10</span>];	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4、动态分配空数组">3.4、动态分配空数组</h4><p>有时候，编译时并不知道数组的长度，这时可以动态分配空数组。看如下程序</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = get_size();</span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *q = p; q != p + n; ++q)</span><br><span class="line">	<span class="comment">//process the array</span></span><br></pre></td></tr></table></figure>
<p>即使 <code>get_size()</code> 返回 0 也是可以的。例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> arr[<span class="number">0</span>];	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">0</span>];	<span class="comment">//ok，但不能被解引用</span></span><br></pre></td></tr></table></figure>
<p>上述 <code>cp</code> 指针 <strong>允许</strong> 的操作有：比较；本身加（减）0。</p>
<h4 id="3-5、动态空间释放">3.5、动态空间释放</h4><p>动态分配的空间必须释放，不然内存会被逐渐耗尽</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] cp;</span><br></pre></td></tr></table></figure>
<p>该语句回收了 <code>cp</code> 所指向的数组。把相应的内存返还给自由存储区。</p>
<blockquote>
<p>理论上，如果少了 <code>[]</code> 应该会导致少释放空间，从而产生内存泄露，因此，释放动态数组时，不能忘记 <code>[]</code></p>
</blockquote>
<h4 id="3-6、动态数组的使用">3.6、动态数组的使用</h4><p>长度不一样的两个字符串，赋给同一个新的字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt1 = <span class="string">"HAHAHA"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt2 = <span class="string">"HEHEHEHEHEHE"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *txt;</span><br><span class="line"><span class="keyword">if</span>(condition)	<span class="comment">//condition表示某个条件</span></span><br><span class="line">	txt = txt1;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	txt = txt2;</span><br><span class="line"><span class="keyword">size_t</span> demension = <span class="built_in">strlen</span>(txt) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> *msg = <span class="keyword">new</span> <span class="keyword">char</span>[demension];</span><br><span class="line"><span class="built_in">strncpy</span>(msg, txt, demension);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; msg &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="4、新旧代码的兼容">4、新旧代码的兼容</h3><h4 id="4-1、混合使用string库和C风格字符串">4.1、混合使用string库和C风格字符串</h4><p>可用字符串字面值初始化string对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常，C风格字符串与字符串字面值有相同的数据类型，而且都是以空字符null结束，因此可以把C风格字符串用在任何可以使用字符串字面值的地方：</p>
<ul>
<li>C风格字符串对string对象进行赋值或初始化；</li>
<li>C风格字符串可以作为string类型的加法操作两个参数中的一个；</li>
</ul>
<p>但反之不成立，但可以通过名为 <code>c_str()</code> 的函数转化为C风格字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str1 = str;	<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str2 = str.c_str();	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2、使用数组初始化vector对象">4.2、使用数组初始化vector对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> int_arr[arr_size] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(int_arr, int_arr + arr_size);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//相当于用 int_arr[1], int_arr[2], int_arr[3] 初始化 ivec1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p><strong>举例1</strong></p>
<p>编写程序: 从标准输入设备读入字符串，并把字符串存放在字符数组中（输入的字符串长度不定）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> arry_size = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> *p_str = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//统计输入的字符数</span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//存放字符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter some chars:"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.get(c))<span class="comment">//每次读取一个字符赋给c</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count + <span class="number">1</span> &gt;= arry_size)<span class="comment">//超出预设长度</span></span><br><span class="line">		&#123;</span><br><span class="line">			arry_size += <span class="number">10</span>;<span class="comment">//长度增加10</span></span><br><span class="line">			<span class="keyword">char</span> *p_temp = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];<span class="comment">//申请新空间</span></span><br><span class="line">			<span class="built_in">strncpy</span>(p_temp, p_str, count);<span class="comment">//将就空间的内容拷贝到新空间</span></span><br><span class="line">			<span class="keyword">delete</span>[] p_str;<span class="comment">//销毁以前的p_str(p_temp)</span></span><br><span class="line">			p_str = p_temp;<span class="comment">//将新空间p_temp赋给p_str</span></span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		p_str[count] = c;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	p_str[count] = <span class="string">'\0'</span>;<span class="comment">//添加null结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"outputs:"</span> &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="built_in">strlen</span>(p_str); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p_str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p_str &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] p_str;<span class="comment">//最后销毁p_str</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"end"</span> &lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter some chars:</span><br><span class="line">asdfghjklqwertyuiop↙</span><br><span class="line">^Z↙</span><br><span class="line">outputs:</span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>举例2</strong></p>
<p>编写程序：读入一组string类型数据，将它们存储在vector中，然后将vector中的对象复制给一个字符指针数组。即为vector中的每个元素创建一个新的字符数组，然后把vector元素的数据复制到相应的字符数组中，最后将指针插入到指针数组中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">		svec.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> **cp_arr = <span class="keyword">new</span> <span class="keyword">char</span>*[svec.size()];<span class="comment">//指针数组</span></span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = svec.begin(); iter != svec.end(); ++iter) &#123;</span><br><span class="line">		<span class="built_in">string</span> s = *iter;</span><br><span class="line">		<span class="keyword">char</span> *cp = <span class="keyword">new</span> <span class="keyword">char</span>[s.size()+<span class="number">1</span>];<span class="comment">//+1表示为null结束符预留空间</span></span><br><span class="line">		<span class="built_in">strncpy</span>(cp, s.c_str(), s.size()+<span class="number">1</span>);</span><br><span class="line">		cp_arr[cnt] = cp;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != cnt; ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; cp_arr[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span>[] cp_arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] cp_arr;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello↙</span><br><span class="line">world↙</span><br><span class="line">^Z↙</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure>
<h3 id="5、多维数组">5、多维数组</h3><blockquote>
<p>严格的讲，C++中没有多维数组，只有<strong>数组的数组</strong></p>
</blockquote>
<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">	&#123;<span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>且等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>而下面情况只初始化第一个元素，则其余初始化为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">2</span>, <span class="number">0</span>&#125;, &#123;<span class="number">3</span>, <span class="number">0</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>但不会等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;<span class="comment">//等价于int ia[3][2] = &#123;1, 2, 3, 0, 0, 0&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>下标引用</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> rsz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> csz = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rsz][csz];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != rsz; ++i) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j != csz; ++j) &#123;</span><br><span class="line">		ia[i][j] = i + j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问特定元素时，必须提供行下标与列下标</p>
<p><strong>指针与多维数组</strong></p>
<p>与普通数组一样，多为数组名也是指向第一个元素的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123; <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">		&#123; <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">		&#123; <span class="number">4</span>, <span class="number">5</span> &#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">int</span> (*ip)[<span class="number">2</span>];	<span class="comment">//ok: 一个指向包含2个int值的数组的指针</span></span><br><span class="line">	ip = &amp;ia[<span class="number">1</span>];	<span class="comment">//ok: ia[1] 包含2个int值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (*ip)[<span class="number">0</span>] &lt;&lt; <span class="string">","</span> &lt;&lt; (*ip)[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>,<span class="number">3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>int (<em>ip)[2];//指向数组的指针；即ip是指向包含两个int值的数组的指针<br>int </em>ip[2];//指针的数组；即ip是包含两个指针的数组</p>
</blockquote>
<p><strong>typedef简化多维数组指针</strong></p>
<p>指向 <code>ia</code> 的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">2</span>];</span><br><span class="line">int_arr *ip = ia;</span><br></pre></td></tr></table></figure>
<p>用 <code>int_arr</code> 输出 <code>ia</code> 的元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">	&#123; <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">	&#123; <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">	&#123; <span class="number">4</span>, <span class="number">5</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_arr[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (int_arr *p = ia; p != ia + <span class="number">3</span>; ++p) &#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q != *p + <span class="number">2</span>; ++q)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面的内容我们使用过字符串字面值，并了解字符串字面值的类型是字符常量的数组，现在可以更加明确的认识到：<strong>字符串字面值的类型就是 const char 类型的数组</strong>。C++从C继承下来的一种通用的结构是<strong>C风格字符串（C-Style character string）</strong>，字符串字面值就是该类型的实例。实际上，C风格字符串既不能确切的归结为C语言类型，也不能归结为C++的类型，而是以空字符 <code>null</code> 结束的字符数组：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[c++ demo: 输入可变长字符串]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-demo-1/"/>
    <id>http://bluestein.github.io/2015/11/cpp-demo-1/</id>
    <published>2015-11-21T14:01:42.000Z</published>
    <updated>2015-12-03T07:06:02.557Z</updated>
    <content type="html"><![CDATA[<p>编写程序: 从标准输入设备读入字符串，并把字符串存放在字符数组中（输入的字符串长度不定）。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">size_t</span> arry_size = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">char</span> *p_str = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//统计输入的字符数</span></span><br><span class="line">	<span class="keyword">char</span> c;<span class="comment">//存放字符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Enter some chars:"</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>.get(c))<span class="comment">//每次读取一个字符赋给c</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (count + <span class="number">1</span> &gt;= arry_size)<span class="comment">//超出预设长度</span></span><br><span class="line">		&#123;</span><br><span class="line">			arry_size += <span class="number">10</span>;<span class="comment">//长度增加10</span></span><br><span class="line">			<span class="keyword">char</span> *p_temp = <span class="keyword">new</span> <span class="keyword">char</span>[arry_size];<span class="comment">//申请新空间</span></span><br><span class="line">			<span class="built_in">strncpy</span>(p_temp, p_str, count);<span class="comment">//将就空间的内容拷贝到新空间</span></span><br><span class="line">			<span class="keyword">delete</span>[] p_str;<span class="comment">//销毁以前的p_str(p_temp)</span></span><br><span class="line">			p_str = p_temp;<span class="comment">//将新空间p_temp赋给p_str</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p_str[count] = c;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	p_str[count] = <span class="string">'\0'</span>;<span class="comment">//添加null结束符</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"outputs:"</span> &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>;i != <span class="built_in">strlen</span>(p_str); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; p_str[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; p_str &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span>[] p_str;<span class="comment">//最后销毁p_str</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"end"</span> &lt;&lt;endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行测试</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Enter some chars:</span><br><span class="line">asdfghjklqwertyuiop↙</span><br><span class="line">^Z↙</span><br><span class="line">outputs:</span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">asdfghjklqwertyuiop(输出换行符)</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>编写程序: 从标准输入设备读入字符串，并把字符串存放在字符数组中（输入的字符串长度不定）。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/tags/C-Demo/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++ Demo" scheme="http://bluestein.github.io/categories/Dev/C-Demo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[11:指针]]></title>
    <link href="http://bluestein.github.io/2015/11/cpp-primer4-11/"/>
    <id>http://bluestein.github.io/2015/11/cpp-primer4-11/</id>
    <published>2015-11-21T08:49:49.000Z</published>
    <updated>2015-11-30T02:57:58.030Z</updated>
    <content type="html"><![CDATA[<p>指针跟迭代器类似，也可以对指针进行 <strong>解引用</strong>（<code>*</code>） 和 <strong>自增</strong>（<code>++</code>） 操作，其含义和迭代器类似。</p>
<p>指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;s;		<span class="comment">//指针 p 保存 s 的地址</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 是取地址符号，该符号只能用于左值。只有变量作为左值时，才能取其地址。</p>
<h3 id="1、指针的定义和初始化">1、指针的定义和初始化</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *vp;	<span class="comment">//指向 vector&lt;int&gt; 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *ip;			<span class="comment">//指向 int 对象的指针</span></span><br><span class="line"><span class="built_in">string</span> *sp; 		<span class="comment">//指向 string 对象的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>另一种风格的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip;</span><br></pre></td></tr></table></figure>
<p>但容易引起误解，会认为 <code>int*</code> 是一种类型。但下例只有 <code>ip1</code> 是指针，<code>ip2</code> 是普通的整型变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip1, ip2;</span><br></pre></td></tr></table></figure>
<p><strong>指针的取值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = <span class="number">0</span>;		<span class="comment">//ip1 不指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = &amp;val;	<span class="comment">//ip2 指向val</span></span><br><span class="line"><span class="keyword">int</span> *ip3;			<span class="comment">//ip3 未初始化</span></span><br><span class="line">ip1 = ip2;			<span class="comment">//ip1 指向 val</span></span><br><span class="line">ip2 = <span class="number">0</span>;			<span class="comment">//ip2 不指向任何对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免使用未初始化的指针</p>
</blockquote>
<p><strong>初始化的约束</strong></p>
<p>对指针初始化或赋值只能使用下列四种类型的值：</p>
<ul>
<li>0常量表达式(编译时能获得0值得const对象或字面值常量0)；</li>
<li>类型匹配的对象的地址；</li>
<li>另一对象之后的下一地址；</li>
<li>同一类型的另一有效指针；</li>
</ul>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> czero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">double</span> *dp;</span><br><span class="line"></span><br><span class="line">ip = ival;		<span class="comment">//error</span></span><br><span class="line">ip = zero;		<span class="comment">//error</span></span><br><span class="line">ip = czero;		<span class="comment">//ok：编译时可以获得 0</span></span><br><span class="line">ip = <span class="number">0</span>；			<span class="comment">//ok：字面值常量 0</span></span><br><span class="line">ip = &amp;ival;		<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">dp = ip;		<span class="comment">//error：类型不匹配</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">当然 <span class="number">0</span> 值还可以使用从C语言继承下来的预处理器变量 `<span class="literal">NULL</span>`，它在 cstdlib 头文件中定义，其值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="literal">NULL</span>;	<span class="comment">//相当于 int *ip = 0;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NULL</code> 不是标准库中定义的，所以不需要 <code>std::</code>。</p>
</blockquote>
<p><strong>void*指针</strong></p>
<p>void* 指针可以保存任何类型对象的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;</span><br><span class="line"><span class="keyword">void</span> *vp = &amp;dval;	<span class="comment">//ok</span></span><br><span class="line">vp = dp;			<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>但 void* 指针只允许有限的操作：</p>
<ul>
<li>与另一指针比较；</li>
<li>向函数传递 void<em> 指针，或函数返回 void</em> 指针；</li>
<li>给另一个 void* 指针赋值。</li>
</ul>
<blockquote>
<p>不允许 void* 指针操作所指向的对象。</p>
</blockquote>
<h3 id="3、指针的操作">3、指针的操作</h3><hr>
<p><strong>*操作符</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s1("hello");</span><br><span class="line">string s2("world")；</span><br><span class="line">string *sp = &amp;s1;</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">sp = &amp;s2;				//改变指针所指对象</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">*sp = "hello world";	//改变所指的内容</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>对 <code>sp</code> 的解引用可以获得 <code>s</code> 的值，因为 <code>sp</code> 指向 <code>s</code>，所以给 <code>*sp</code> 赋值可以改变 <code>s</code> 的值。</p>
<p><strong>指针和引用的比较</strong></p>
<p>虽然引用（reference）和指针都可以间接访问另一个值，但有区别：</p>
<ul>
<li>定义引用时没有初始化时错误的；</li>
<li>赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，并不是与另一个对象关联；</li>
<li>引用一经初始化，就始终指向同一个特定的对象</li>
</ul>
<p>指针的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival1 = <span class="number">1024</span>, ival2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = &amp;ival1, *ip2 = &amp;ival2;</span><br><span class="line">ip1 = ip2;		<span class="comment">//ip1 此时指向 ival2</span></span><br></pre></td></tr></table></figure>
<p>而引用的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;r1 = ival1; <span class="keyword">int</span> &amp;r2 = ival2;</span><br><span class="line">r1 = r2;		<span class="comment">//将 ival2 赋给 ival1</span></span><br></pre></td></tr></table></figure>
<p>上面的修改只会修改引用所关联的对象，并不会改变改变引用本身。并且修改后，两个引用还是指向原来关联的对象。</p>
<p><strong>指向指针的指针</strong></p>
<p>指针本身也是需要占内存的对象，所以指针也可以被指针访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> **ipp = &amp;ip;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; **ipp &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>可以用三种方式输出ival的值。</p>
<p>最后举一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i, *p2 = &amp;j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p2 = *p1 * *p2;			<span class="comment">//改变 p2 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p1 *= *p1;				<span class="comment">//改变 p1 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="4、使用指针访问数组">4、使用指针访问数组</h3><hr>
<p>指针与数组密切相关。特别是在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = val;	<span class="comment">//p 指向 val[0]</span></span><br><span class="line">p = &amp;val[<span class="number">3</span>];	<span class="comment">//p 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<p><strong>指针的算术运算</strong></p>
<p>上面的 <code>p = &amp;val[3];</code> 使用下标操作，也可以通过 <strong>指针的算术操作（pointer arithmetic）</strong> 来获取指定的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = val;			<span class="comment">//p 指向 val[0]</span></span><br><span class="line"><span class="keyword">int</span> *p2 = p + <span class="number">3</span>;	<span class="comment">//p2 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针的算术操作只有在计算过后的新指针还是指向同一数组的元素才算合法，且不能越界，比如上面 <code>int *p2 = p + 3;</code> 改成 <code>int *p2 = p + 4;</code> 就会出错，因为数组 <code>val</code> 的大小为 4，最大的下标为 3。</p>
</blockquote>
<p>两个指针之间还可以做减法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ptrdiff_t</span> n = p2 - p1;	<span class="comment">//n = 3</span></span><br></pre></td></tr></table></figure>
<p><code>p1</code> 和 <code>p2</code> 之间相差3个对象，所以 <code>n = 3</code>。 <code>n</code> 是标准库类型（library type） <strong>ptrdiff_t</strong> 类型。与 size_t 类型一样，ptrdiff_t 也是一种与机器相关类型，在cstddef头文件中定义。</p>
<p>允许在指针上加减 0，使指针保持不变。</p>
<p><strong>解引用和指针算术操作之间的相互作用</strong></p>
<p>在指针上加上一个整数值，其结果仍是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last = *(val + <span class="number">3</span>);	<span class="comment">//相当于 val[3]</span></span><br></pre></td></tr></table></figure>
<p>需要写括号，如果写成 <code>int last = *val + 3;</code> 则相当于 <code>val[0] + 3</code>。</p>
<p><strong>下标和指针</strong></p>
<p>使用下标访问数组时，它实际上是使用下标访问指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = val[<span class="number">0</span>]	<span class="comment">//val 指向数组 val[] 的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;val[<span class="number">2</span>];	<span class="comment">//ok: p 指向第二个元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];		<span class="comment">//ok: p[1] 相当于 *(p + 1), j = val[3]</span></span><br><span class="line"><span class="keyword">int</span> k = p[-<span class="number">2</span>];		<span class="comment">//ok: p[-2] 相当于 val[0]</span></span><br></pre></td></tr></table></figure>
<p><strong>计算数组的超出末端指针</strong></p>
<p>vector 类型提供的end操作将返回指向超出 vector 末端位置的一个迭代器。类似的，可以计算数组的超出末端指针的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">int</span> *p2 = p + arr_size;	<span class="comment">//ok:超出末端的指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端之后或数组首地址之前的地址都是不合法的。</p>
</blockquote>
<p><code>p2</code> 不能解引用操作，但能与其他指针比较，或者用作指针算术表达式的操作数。</p>
<p><strong>输出数组元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *begin = arr, *end = arr + arr_size; begin != end; ++begin)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *begin &lt;&lt; <span class="string">","</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针是数组的迭代器。上面的程序与迭代器程序非常相似，事实上，内置类型具有标准库容器的许多性质，指针就是数组的迭代器。</p>
</blockquote>
<h3 id="5、指针与const限定符">5、指针与const限定符</h3><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p><strong>指针和typedef</strong></p>
<p>在typedef中使用指针往往会带来意外的结果，下面是一个几乎所有初学者都会搞错的问题：请问 <code>cstr</code> 变量是什么类型？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="keyword">const</span> sp cstr;</span><br></pre></td></tr></table></figure>
<p>简单的回答是：const sp 类型的指针。进一步：const sp 所表示的真实类型是什么？可能会认为是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *cstr;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>但这是错误的，原因是：声明const sp时，const修饰的是 sp 类型，而 sp 是一个指针。所以等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解const声明：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1 和 s2 都是const</span></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">const</span> s1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> s2;</span><br></pre></td></tr></table></figure>
<p>用typedef写const类型定义时，const限定符加在类型前面容易引起误解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="comment">//下面三种定义时等价的</span></span><br><span class="line"><span class="keyword">const</span> sp cstr1 = &amp;s;	<span class="comment">//容易误解</span></span><br><span class="line">sp <span class="keyword">const</span> cstr2 = &amp;s;</span><br><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr3 = &amp;s;</span><br></pre></td></tr></table></figure>
<hr>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic = i;				<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pic = &amp;ic; 			<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> cpi = &amp;ic;			<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> cpic = &amp;ic;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>指针跟迭代器类似，也可以对指针进行 <strong>解引用</strong>（<code>*</code>） 和 <strong>自增</strong>（<code>++</code>） 操作，其含义和迭代器类似。</p>
<p>指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://bluestein.github.io/tags/C/"/>
    
      <category term="C++ primer" scheme="http://bluestein.github.io/tags/C-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="C++" scheme="http://bluestein.github.io/categories/Dev/C/"/>
    
  </entry>
  
</feed>
