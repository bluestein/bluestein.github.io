<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Humooo]]></title>
  <subtitle><![CDATA[Humooo's Blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://bluestein.github.io/"/>
  <updated>2016-03-09T03:29:27.145Z</updated>
  <id>http://bluestein.github.io/</id>
  
  <author>
    <name><![CDATA[Humooo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Efficient Online Evaluation of Big Data Stream Classifiers]]></title>
    <link href="http://bluestein.github.io/2016/03/evaluation-of-data-stream/"/>
    <id>http://bluestein.github.io/2016/03/evaluation-of-data-stream/</id>
    <published>2016-03-09T01:57:05.000Z</published>
    <updated>2016-03-09T03:29:27.145Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372" target="_blank" rel="external">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>
<a id="more"></a>
<p>如今，几乎所有研究者都需要有效的评价他们自己模型的有效性。然而，数据流领域的评价标准面临很多挑战。数据流中的实例是随着时间到来的，并且这些数据所包含的概念（concept）也可能也时间有关。再者，大量的数据还可能面临类别不平衡（class imbalance）问题。现阶段的数据流评价标准一般使用 prequential(predictive sequential?) setting，并且只建立一个模型，不能够实时地计算出统计意义（statistical significance）。</p>
<p>提供统计的意义是非常重要，确保评价结果是有效且没有误导成分。现提出三种突出的有误导性的评价的例子：</p>
<ol>
<li>为了评价两个分类器在数据流上的statistical significance 好坏，会利用McNemar’s test。然而这两个分类器实际上是同一个算法的两个对象（这么理解：C++中的类，new 两个对象），只是使用不同seed 对决策树的随机组合。McNemar’s test对于小型数据来说表现不错，但是使用在大型数据上就是误导。然而，它在数据流分类中却被广泛的使用。</li>
<li>将数据分成独立（disjoint）的两块：training，test，是通常的做法。然而，这种类型的分法，导致一个评价程序仅仅通过分类器的话，不能正确的区分这两块用不同方式构造的数据;</li>
<li>a simple majority class（多类） classifier that keeps the majority class of a sliding window may have positive k statistic and positive harmonic mean accuracy（调和平均精度） for some periods.</li>
</ol>
<p>对于四个问题：</p>
<ol>
<li>Validation methodology（方法验证）</li>
<li>Statistical testing（统计测试）：McNemar’s test 是误导</li>
<li>Unbalanced measure（不平衡衡量标准）：通常的F1-Measure 和Accuracy 会偏向一个类</li>
<li>Forgetting mechanism（遗忘机制）：sliding window（滑动窗口） 和 exponential forgetting 是两种很流行的方法，但是他们都很确定参数。</li>
</ol>
<p>解决方法是：</p>
<ol>
<li>new bootstrap validation</li>
<li>Sign test 和 Wilcoxon signed-rank test</li>
<li>κ_{m} statistic </li>
<li>new forgetting mechanism for prequential evaluation based<br>on ADWIN </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>原文 <a href="http://dl.acm.org/citation.cfm?id=2783372">Efficient Online Evaluation of Big Data Stream Classifiers (ACM)</a></p>
<p>数据流模型分类器的评价标准至关重要，以便分辨出效果不佳的那些模型，并因此对其进行改进或替换成其他表现更好的模型。</p>]]>
    
    </summary>
    
      <category term="big data" scheme="http://bluestein.github.io/tags/big-data/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/tags/data-stream/"/>
    
      <category term="evaluation" scheme="http://bluestein.github.io/tags/evaluation/"/>
    
      <category term="Academic" scheme="http://bluestein.github.io/categories/Academic/"/>
    
      <category term="data stream" scheme="http://bluestein.github.io/categories/Academic/data-stream/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阿里电话面试]]></title>
    <link href="http://bluestein.github.io/2016/03/ali-interview-1/"/>
    <id>http://bluestein.github.io/2016/03/ali-interview-1/</id>
    <published>2016-03-08T14:00:05.000Z</published>
    <updated>2016-03-09T02:31:37.347Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>
<a id="more"></a>
<p>关于我答不上来这件事，我知道完全是我自己没准备，以至于错失一次好机会。也总结出关于投递简历的一点小建议（其实是师兄告诉我的。。）：<strong>在deadline之前，在没准备好的情况下，先别冲动投简历！</strong>至于怎么界定“准备好”，就得看大家自己的感觉了。对于我来说，至少需要把基础书看上一遍吧。。不能跟我一样卡壳在基础知识上，以至于面试官认为你根本不是简历上说的那么犀利（excellent？就那意思啦），甚至认为在造假，这种错误我绝不能再犯第二次，嗯，不能。。</p>
<p>下面是今天的问题，大概。。</p>
<p>1，    HTPP中URL由几部分组成<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="external">URL-Wikipedia</a>）</p>
<p>超文本传输协议（HTTP）的统一资源定位符将从因特网获取信息的五个基本元素包括在一个简单的地址中：</p>
<ul>
<li>传送协议。</li>
<li>服务器。（通常为域名，有时为IP地址）</li>
<li>端口号。（以数字方式表示，若为HTTP的预设值“:80”可省略）</li>
<li>路径。（以“/”字元区别路径中的每一个目录名称）</li>
<li>查询。（GET模式的表单参数，以“?”字元为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与资料，通常以UTF8的URL编码，避开字元冲突的问题）</li>
</ul>
<p>2，排序算法<br>答：（参考<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="external">排序算法-Wikipedia</a>）</p>
<h4 id="稳定的排序">稳定的排序</h4><ol>
<li>冒泡排序（bubble sort）— O(n2)</li>
<li>鸡尾酒排序（cocktail sort）—O(n2)</li>
<li>插入排序（insertion sort）—O(n2)</li>
<li>桶排序（bucket sort）—O(n)；需要O(k)额外空间</li>
<li>计数排序（counting sort）—O(n+k)；需要O(n+k)额外空间</li>
<li>归并排序（merge sort）—O(n log n)；需要O(n)额外空间</li>
<li>原地归并排序— O(n log2 n)如果使用最佳的现在版本</li>
<li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li>
<li>鸽巢排序（pigeonhole sort）—O(n+k)；需要O(k)额外空间</li>
<li>基数排序（radix sort）—O(n·k)；需要O(n)额外空间</li>
<li>侏儒排序（gnome sort）— O(n2)</li>
<li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li>
<li>块排序（block sort）— O(n log n)</li>
<li>额外儿童网二对一后退萨大人排序（children two to one additional network Back Sa adults sort）— O(n2)</li>
</ol>
<h4 id="不稳定排序">不稳定排序</h4><ol>
<li>选择排序（selection sort）—O(n2)</li>
<li>希尔排序（shell sort）—O(n log2 n)如果使用最佳的现在版本</li>
<li>Clover排序算法（Clover sort）—O(n)期望时间，O(n2)最坏情况</li>
<li>梳排序— O(n log n)</li>
<li>堆排序（heap sort）—O(n log n)</li>
<li>平滑排序（smooth sort）— O(n log n)</li>
<li>快速排序（quick sort）—O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li>
<li>内省排序（introsort）—O(n log n)</li>
<li>耐心排序（patience sort）—O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li>
</ol>
<p>3，浏览器输入一个网址，其背后原理解释<br>答：(参考 <a href="http://www.cricode.com/3696.html" target="_blank" rel="external">在浏览器中输入网址后都发生了什么</a>)</p>
<p>从输入一个网址到显示，包括dns解析，http协议解析，html解析，js解析，以及各种内容渲染</p>
<ol>
<li><p>浏览器发起DNS查询请求<br>在广域网中，我们是基于IP地址进行通信的。但通常客户访问的是一个网址，为此，我们需要先得到网址对应的IP地址，这就需要域名服务系统将域名转换成IP地址。</p>
</li>
<li><p>域名服务器向客户端返回查询结果域名，从而完成域名到IP地址的转换</p>
</li>
<li><p>客户端向web服务器发送HTTP请求<br>在得到了域名对应的IP地址后，客户端便可以向真正的web服务器发生HTTP请求。<br>HTTP请求是一个基于TCP协议之上的应用层协议——超文本传输协议。浏览器通过DNS获取到web服务器真的IP地址后，便向web服务器发起tcp连接请求，通过TCP三次握手建立好连接后，浏览器便可以将HTTP请求数据通过发送给服务器了。</p>
</li>
<li><p>发送响应数据给客户端<br>Web服务器通常通过监听80端口，来获取客户端的HTTP请求。与客户端建立好TCP连接后，web服务器开始接受客户端发来的数据，并通过HTTP解码，从接受到的网络数据中解析出请求的url信息以前其他诸如Accept-Encoding、Accept-Language等信息。<br>至此，一个HTTP通信过程完成。web服务器会根据HTTP请求头中的Connection字段值决定是否关闭TCP链接通道，当Connection字段值为keep-alive时，web服务器不会立即关闭此连接。</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>今天（2016-03-08）是我人生中接受的第一次面试，并不是想象中的那么顺利（意思是不行hhh）。当我看到电话上“浙江-杭州”四个字时，手就开始抖了，即使是现在（接完电话1个小时）心也还未平静下来。因为我知道我没准备好，不是说仅仅心理上没准备好，而是心理上、身体上（嗯，身体上）和知识储备上完完全全、彻彻底底的没准备好！所以我方了，以至于听不清对方讲话，听清了也回答不上来。。。尴尬症都犯了。。。不过面试官人好、态度好，想必是个帅哥、暖男？（我是男的！没那种意思。。），问的问题虽然简单，但是我答不上来啊hhh。</p>]]>
    
    </summary>
    
      <category term="alibaba" scheme="http://bluestein.github.io/tags/alibaba/"/>
    
      <category term="hhh" scheme="http://bluestein.github.io/tags/hhh/"/>
    
      <category term="interview" scheme="http://bluestein.github.io/tags/interview/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="experience" scheme="http://bluestein.github.io/categories/Odds-Ends/experience/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[KMP: 字符串匹配算法]]></title>
    <link href="http://bluestein.github.io/2016/03/Algorithm-KMP/"/>
    <id>http://bluestein.github.io/2016/03/Algorithm-KMP/</id>
    <published>2016-03-08T07:23:05.000Z</published>
    <updated>2016-03-08T08:01:38.905Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm" target="_blank" rel="external">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="external">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>
<a id="more"></a>
<h3 id="1">1</h3><p><img src="/images/kmp/kmp_1.png" alt=""></p>
<p>首先，字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。</p>
<h3 id="2">2</h3><p><img src="/images/kmp/kmp_2.png" alt=""></p>
<p>因为B与A不匹配，搜索词再往后移。</p>
<h3 id="3">3</h3><p><img src="/images/kmp/kmp_3.png" alt=""></p>
<p>就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。</p>
<h3 id="4">4</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>直到字符串有一个字符，与搜索词对应的字符不相同为止。</p>
<h3 id="5">5</h3><p><img src="/images/kmp/kmp_6.png" alt=""></p>
<p>这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较就像上图所示。<strong>这样做虽然可行，但是效率很差</strong>，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。</p>
<p>一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。</p>
<h3 id="6">6</h3><p><img src="/images/kmp/kmp_8.png" alt=""></p>
<p>可以针对搜索词，算出一张<strong>部分匹配表</strong>（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。</p>
<h3 id="7">7</h3><p><img src="/images/kmp/kmp_5.png" alt=""></p>
<p>已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">　　移动位数 </span>=<span class="string"> 已匹配的字符数 - 对应的部分匹配值</span></span><br></pre></td></tr></table></figure>
<p>因为 6 - 2 等于4，所以将搜索词向后移动4位。</p>
<h3 id="8">8</h3><p><img src="/images/kmp/kmp_10.png" alt=""></p>
<p>因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。</p>
<h3 id="9">9</h3><p><img src="/images/kmp/kmp_11.png" alt=""><br>因为空格与A不匹配，继续后移一位。</p>
<h3 id="10">10</h3><p><img src="/images/kmp/kmp_12.png" alt=""></p>
<p>逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。</p>
<h3 id="11">11</h3><p><img src="/images/kmp/kmp_13.png" alt=""></p>
<p>逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p>
<h2 id="Partial_Match_Table：部分匹配表">Partial Match Table：部分匹配表</h2><p><img src="/images/kmp/kmp_14.png" alt=""></p>
<p>首先，要了解两个概念：”前缀”和”后缀”。 “前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。</p>
<p>“部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例</p>
<ul>
<li>“A”的前缀和后缀都为空集，共有元素的长度为0；</li>
<li>“AB”的前缀为[A]，后缀为[B]，共有元素的长度为0；</li>
<li>“ABC”的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；</li>
<li>“ABCD”的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；</li>
<li>“ABCDA”的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为”A”，长度为1；</li>
<li>“ABCDAB”的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为”AB”，长度为2；</li>
<li>“ABCDABD”的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。</li>
</ul>
<p>“部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p>
<p>参考 @阮一峰 <a href="http://kb.cnblogs.com/page/176818/" target="_blank" rel="external">KMP-cnblog</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="KMP搜索">KMP搜索</h2><p>字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，我想知道，里面是否包含另一个字符串”ABCDABD”？</p>
<p>许多算法可以完成这个任务，<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">Knuth-Morris-Pratt</a>算法（简称KMP）是最常用的之一。它以三个发明者命名，起头的那个K就是著名科学家<a href="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</a>。下面用图例的方法展示一个搜索过程：</p>]]>
    
    </summary>
    
      <category term="KMP" scheme="http://bluestein.github.io/tags/KMP/"/>
    
      <category term="algorithm" scheme="http://bluestein.github.io/tags/algorithm/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Algorithm" scheme="http://bluestein.github.io/categories/Dev/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[const与指针、函数]]></title>
    <link href="http://bluestein.github.io/2016/03/const-pointer-function/"/>
    <id>http://bluestein.github.io/2016/03/const-pointer-function/</id>
    <published>2016-03-05T01:23:05.000Z</published>
    <updated>2016-03-05T02:46:17.003Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>2. const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>3. 指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p>关于指针的其他内容，请参考本站文章<a href="http://bluestein.github.io/2015/11/cpp-primer4-11/">指针</a>。</p>
<h2 id="const与函数">const与函数</h2><hr>
<p><strong>1. 用const修饰函数的参数</strong></p>
<p>如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。const 只能修饰输入参数：</p>
<p><strong>如果输入参数采用“指针传递”，那么加 const 修饰可以防止意外地改动该指针，起到保护作用。</strong></p>
<p>例如 StringCopy 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringCopy</span><span class="params">(<span class="keyword">char</span> *destination, <span class="keyword">const</span> <span class="keyword">char</span> *source)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>source</code> 是输入参数，<code>destination</code> 是输出参数。给 <code>destination</code> 加上 const 修饰后，<strong>如果函数体内的语句试图改动 source 的内容，编译器将指出错误。</strong></p>
<p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，则输入参数无需保护，所以不要加 const 修饰。</p>
<p>例如， void func(int x) 而不是 void func(const int x) 。同理，同理不要将函数 void fun2(A a) 写成 void func2(const A a)。其中 A 为用户自定义的数据类型。</p>
<p>对于非内部数据类型的参数而言，象 void func(A a) 这样声明的函数注定效率比较底。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p><strong>为了提高效率，可以将函数声明改为 void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数 void func(A &amp;a) 存在一个缺点:</strong></p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p>
<p>以此类推，是否应将 void func(int x) 改写为 void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p>总结一下：</p>
<ol>
<li>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将 void func(A a) 改为 void func(const A &amp;a)。</li>
<li>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如 void func(int x) 不应该改为void func(const int &amp;x)。</li>
</ol>
<p><strong>2. 用const 修饰函数的返回值</strong></p>
<p>如果给以“指针传递”方式的函数返回值加 const 修饰，那么函数返回值（即指针）的内容不能被修改，<strong>该返回值只能被赋给加const 修饰的同类型指针</strong>。</p>
<p>如下语句将出现编译错误：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="keyword">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>正确的用法是</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> *<span class="built_in">str</span> = getString();</span><br></pre></td></tr></table></figure>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。</p>
<p>例如，不要把函数 int getInt(void) 写成 const int getInt(void)。同理不要把函数 A getA(void) 写成 const A getA(void)，其中 A 为用户自定义的数据类型。</p>
<p>如果返回值不是内部数据类型，将函数 A getA(void) 改写为 const A &amp; getA(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="type">A</span> &amp; operate = (const <span class="type">A</span> &amp;other); <span class="comment">// 赋值函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span> a, b, <span class="built_in">c</span>; <span class="comment">// a, b, c 为 A 的对象</span></span><br><span class="line">a = b = <span class="built_in">c</span>; <span class="comment">// 正常的链式赋值</span></span><br><span class="line">(a = b) = <span class="built_in">c</span>; <span class="comment">// 不正常的链式赋值，但合法</span></span><br></pre></td></tr></table></figure>
<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p>
<p><strong>3. const 成员函数</strong></p>
<p>任何不会修改数据成员的函数都应该声明为 const 类型。如果在编写 const 成员函数时，不慎修改了数据成员，或者调用了其它非 const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p>
<p>以下程序中，类 Stack 的成员函数 GetCount 仅用于计数，从逻辑上讲 GetCount 应当为 const 函数。编译器将指出 GetCount 函数中的错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">int</span> elem)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">Pop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">GetCount</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// const 成员函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_num;</span><br><span class="line">	<span class="keyword">int</span> m_data[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Stack::GetCount(<span class="keyword">void</span>) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">	++m_num; <span class="comment">// 编译错误，企图修改数据成员 m_num</span></span><br><span class="line">	Pop(); <span class="comment">// 编译错误，企图调用非 const 函数</span></span><br><span class="line">	<span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>const 成员函数的声明看起来怪怪的：const 关键字只能放在函数声明的尾部，大概是因为其它地方都已经被占用了。</p>
<p>关于 const 函数的几点规则：</p>
<ol>
<li>const 对象只能访问 const 成员函数,而非 const 对象可以访问任意的成员函数,包括 const 成员函数.</li>
<li>const 对象的成员是不可修改的,然而 const 对象通过指针维护的对象却是可以修改的.</li>
<li>const 成员函数不可以修改对象的数据,不管对象是否具有 const 性质.它在编译时,以是否修改成员数据为依据,进行检查.</li>
<li>然而加上 mutable 修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的 const 成员函数是可以修改它的</li>
</ol>
<p>该部分,参考<a href="http://www.cnblogs.com/Fancyboy2004/archive/2008/12/23/1360810.html" target="_blank" rel="external">原文</a></p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h2 id="const与指针">const与指针</h2><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>1. 指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="const" scheme="http://bluestein.github.io/tags/const/"/>
    
      <category term="指针" scheme="http://bluestein.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[冬跑]]></title>
    <link href="http://bluestein.github.io/2016/02/winter-running/"/>
    <id>http://bluestein.github.io/2016/02/winter-running/</id>
    <published>2016-02-25T07:15:05.000Z</published>
    <updated>2016-03-05T02:44:53.849Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>
<a id="more"></a>
<h3 id="1、跑鞋">1、跑鞋</h3><p>我个人觉得，要跑步的话必须现有一双好的跑鞋。我在网络上看到，这个网站 <a href="http://www.myprecisionfit.com" title="myprecisionfit" target="_blank" rel="external">myprecisionfit</a> 能够根据自身情况进行跑鞋推荐。这个网站推荐了好几双，各种价位的都有，但考虑到刚入门和能不坚持下去都是个问题就选了一双经济承受范围内 wave 系列。在京东和天猫都有官方旗舰店，可自行选择购买。我的选择是：（切记，要根据自身情况选择跑鞋，我列出我的选择是为了理清预算）</p>
<ul>
<li>MIZUNO Wave Laser 2 ￥329</li>
</ul>
<h3 id="2、服饰装备">2、服饰装备</h3><h4 id="2-1、上身">2.1、上身</h4><p>看到网络大部分意见上说冬天需要三层：</p>
<ul>
<li>最里层：速干T；</li>
<li>中层：保暖；</li>
<li>最外层：防风；</li>
<li>其他：臂包，袜子，手套，帽子等；</li>
</ul>
<p>上面所说的所有装备均可以在 <a href="http://www.decathlon.com.cn/zh/running" title="迪卡侬" target="_blank" rel="external">迪卡侬</a> 买到，而且性价比不错。先声明，绝对不是打广告。我选择的是</p>
<ul>
<li>速干T：KALENJI EKIDEN TS ￥19.9</li>
<li>保暖：KALENJI EKIDEN LS ￥69.9</li>
<li>防风：<ul>
<li>KALENJI COMFORT PROTECT WIND ￥79.0</li>
<li>其他</li>
</ul>
</li>
<li>其他：<ul>
<li>臂包：KALENJI ARMBAND ￥49.9</li>
<li>袜子：暂未购买</li>
<li>其他</li>
</ul>
</li>
</ul>
<h4 id="2-2、下身">2.2、下身</h4><p>也有说不用特别选下身的，只要是普通运动裤都可以。但是我个人觉得别人有这个卖的话顺便也买一条，反正也不贵呀。对于下身来说，分两层就可以了吧。</p>
<ul>
<li>内层：快干内裤；</li>
<li>外层：运动长裤（冬天当然是长裤）；</li>
</ul>
<p>同样的，也可以在迪卡侬选购，再说一遍，我真的不是打广告的（=_=）。我的选择是：</p>
<ul>
<li>内层：暂时未买，试试看再说；</li>
<li>外层：KALENJI EKIDEN PANT ￥99.0</li>
</ul>
<p><strong>总预算：329 + 19.9 + 69.9 + 79.0 + 49.9 + 99.0 = ￥646.7</strong></p>
<h3 id="3、开跑">3、开跑</h3><p>以下内容参考了知乎</p>
<h4 id="3-1、空气环境">3.1、空气环境</h4><p>一般来说PM2.5超过100就要慎重，比100低基本问题不大；大于100，小于150，属于轻度污染，如果对雾霾比较敏感的人不太适宜跑步，如果不是很敏感，勉强可以接受；但是如果是150～200，这属于中度污染，跑步这个时候对人体是不健康的；如果追求健康就不要跑了。超过200逼近300的话，无论如何是不能出去跑的，等个合适的天再出门跑步，实在熬不住，那就跑步机或去周围空气好的城市或山区跑一下，这里提醒大家PM2.5指数以当时指数为准。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</p>
<h4 id="3-2、跑步流程：热身→跑步→拉伸">3.2、跑步流程：热身→跑步→拉伸</h4><ul>
<li>跑步姿势可以参考 <a href="http://www.zhihu.com/question/31089103/answer/61288749" target="_blank" rel="external">缺个口子的大苹果 - 正确的跑步姿势是怎样的？</a>。</li>
<li>预热：晨跑前先喝大概250cc糖水或香蕉，防止低血糖。然后先可以先走一走，比如出家门走到运动场。通过血液循环，使身体由内而外地热起来。然后只要再做做准备动作，身体就可以充分放松了。注意不要像散步一样随意走，要保持正确的姿势，从骨盆开始带动腿。（<a href="http://www.zhihu.com/question/36505010/answer/67853152" target="_blank" rel="external">袁超 - 冬天了，跑步方便吗？</a>）</li>
<li>跑步：调整呼吸开跑，完成预定目标。</li>
<li>拉伸：要充分的拉伸。</li>
</ul>
<h4 id="3-3、注意事项">3.3、注意事项</h4><ol>
<li>如果喜欢一边跑步一边听歌的话最好换个蓝牙耳机。北京冬天早上空气冷，普通耳机橡胶线遇冷容易变硬，弹性减小，再加上跑步运动，很容易把耳机线拉断。</li>
<li>记得带个润唇膏，暴漏在干冷天气里的嘴唇很容易干裂。如果遇到大风天，可以戴防风眼镜。</li>
<li>秋季空气中湿度减少，容易引起咽喉干燥、口舌少津、嘴唇干裂、鼻子出血、大便干燥等症状。再加上运动时丧失的水分会加重人体缺乏水分的反应，所以，运动后一定要多喝开水，多吃梨、苹果、乳类、芝麻、新鲜蔬菜等柔润食物，或是平时多喝冰糖梨水、冬瓜汤等食物来保持上呼吸道黏膜的正常分泌，防止咽喉肿痛。</li>
<li>如果运动量较大，出汗过多，可在开水中加少量食盐，以维持体内酸碱平衡，有条件的可以喝一些含电解质的运动饮料，防止肌肉出现痉挛。</li>
<li>如进行长跑锻炼，还要饮用适量的糖开水，以防低血糖，出现头晕、出虚汗、四肢乏力等不良生理反应。</li>
<li>运动时补水不能在运动前或运动后一下子喝很多，运动前喝多了容易造成肠胃负担加重，而且一动起来胃里咣咣响也影响锻炼。运动后猛喝会带走大量的电解质，部分流出体外，对身体不好，运动时饮水最好能分次少量饮用，比如锻炼20分钟，喝150到200毫升，饮料浓度为6-8%的低渗饮料（含糖、钠、钾、钙、镁）。（参考 <a href="http://www.zhihu.com/question/36505010/answer/68519392" target="_blank" rel="external">缺个口子的大苹果 - 冬天了，跑步方便吗？</a>）</li>
</ol>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近，身体越来越差了。。。每天凌晨1点睡，8:30起，发现自己总不在工作状态，完全不能搞科研（我说的是真的(。・＿・。)）。为了克服晚睡晚起的缺点，选择了晨跑。不过是否能坚持就要看我自己了，不过我现在元气满满。现在快接近冬天了，要跑步就必须要一些装备，排汗、保暖和好的跑鞋是很重要的。下面是我在网络上搜寻了两天得到的一些东西，将依次介绍。</p>]]>
    
    </summary>
    
      <category term="running" scheme="http://bluestein.github.io/tags/running/"/>
    
      <category term="sport" scheme="http://bluestein.github.io/tags/sport/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="兴趣" scheme="http://bluestein.github.io/categories/Odds-Ends/%E5%85%B4%E8%B6%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[单词转换程序]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-12/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-12/</id>
    <published>2016-01-14T12:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.938Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; trans_map;</span><br><span class="line">	<span class="built_in">string</span> key, value;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"wrong number of arguments"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream map_file;</span><br><span class="line">	map_file.open(argv[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!map_file) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no transformation file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (map_file &gt;&gt; key &gt;&gt; value) &#123;</span><br><span class="line">		trans_map.insert(make_pair(key, value));</span><br><span class="line">	&#125;</span><br><span class="line">	ifstream input;</span><br><span class="line">	input.open(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"no input file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">string</span> line;</span><br><span class="line">	<span class="keyword">while</span> (getline(input, line)) &#123;</span><br><span class="line">		<span class="function"><span class="built_in">istringstream</span> <span class="title">s</span><span class="params">(line)</span></span>;</span><br><span class="line">		<span class="built_in">string</span> word;</span><br><span class="line">		<span class="keyword">bool</span> first = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">while</span> (s &gt;&gt; word) &#123;</span><br><span class="line">			<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::const_iterator map_citer = trans_map.find(word);</span><br><span class="line">			<span class="keyword">if</span> (map_citer != trans_map.end()) &#123;</span><br><span class="line">				word = map_citer-&gt;second;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (first) &#123;</span><br><span class="line">				first = <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>源代码</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关联容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-associative_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-associative_container/</id>
    <published>2016-01-14T06:49:02.000Z</published>
    <updated>2016-03-05T02:41:48.583Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>
<a id="more"></a>
<ol>
<li>map 以 key-value（键-值） 的形式组织：键作为元素在 map 中的索引，而值则表示所要存储和读取的元素。</li>
<li>set 仅包含键，可以看成含有很多键值得集合。</li>
</ol>
<table>
<thead>
<tr>
<th>关联容器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map</td>
<td>关联数组</td>
</tr>
<tr>
<td>set</td>
<td>集合</td>
</tr>
<tr>
<td>multimap</td>
<td>一个键可出现多次的 map 类型</td>
</tr>
<tr>
<td>multiset</td>
<td>一个键可出现多次的 set 类型</td>
</tr>
</tbody>
</table>
<p>一般来说，<strong>如果想有效的存储不同值得集合</strong>，使用 set 比较合适；而 map 容器则更适合用于存储键关联值得情况。<br>比如在文本处理时，可以使用 set 来存储要忽略的词，而 map 可以使用作字典：单词本身是键，其解释是值。</p>
<blockquote>
<p>set 和 map 的键是唯一的，每个键只能出现一次。如果想使用一个键对应多个值得情况，那么使用 multiset 和 multimap 类型。</p>
</blockquote>
<h3 id="pair_类型">pair 类型</h3><p>在介绍关联容器之前，必须先了解一种与之相关的简单的标准库类型——pair 类型，在 <code>utility</code> 头文件中定义</p>
<table>
<thead>
<tr>
<th>pair 类型所提供的操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>pair<t1, t2=""> p1</t1,></td>
<td>创建一个空的 pair 对象，它的两个元素分别是 T1 和 T2 类型，采用<strong>值初始化</strong></td>
</tr>
<tr>
<td>pair<t1, t2=""> p1(v1,v2)</t1,></td>
<td>创建一个 pair 对象，它的两个元素类型分别是 T1 和 T2。其中 first 成员初始化为 v1，second 成员初始化为 v2</td>
</tr>
<tr>
<td>make_pair(v1, v2)</td>
<td>用 v1 和 v2 创建一个 pair 对象，其元素的类型分别是 v1 和 v2 的类型。</td>
</tr>
<tr>
<td>p1 &lt; p2</td>
<td>两个 pair 对象的小于运算，其定义遵循字典次序：如果 <code>p1.first &lt; p2.first</code> 或 <code>!(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second</code> 则返回 true</td>
</tr>
<tr>
<td>p1 == p2</td>
<td>等于操作</td>
</tr>
<tr>
<td>p.first</td>
<td>返回 p 中的 first（第一个） 成员</td>
</tr>
<tr>
<td>p.second</td>
<td>返回 p 中的 second（第二个） 成员</td>
</tr>
</tbody>
</table>
<h4 id="pair_的创建和初始化">pair 的创建和初始化</h4><p>在创建 pair 对象时，必须提供两个类型名，这两个类型名不必相同：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; anon;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; line;</span><br></pre></td></tr></table></figure>
<p><strong>创建 pair 时，如果不提供初始化式，则调用默认构造函数进行值初始化。</strong>所以，<code>anon</code> 是包含两个空 string 成员的 pair 对象； <code>word_count</code> 中的 int 型成员获得 0 值； <code>line</code> 则是存储一个空 string 和一个空 vector 类型的对象。</p>
<p>也可以提供初始化式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author(<span class="string">"James"</span>, <span class="string">"Joyce"</span>);</span><br></pre></td></tr></table></figure>
<p>pair 类型使用起来较繁琐，可以使用 typedef 简化声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; Author;</span><br><span class="line"><span class="function">Author <span class="title">proust</span><span class="params">(<span class="string">"Marcel"</span>, <span class="string">"Proust"</span>)</span></span>;</span><br><span class="line"><span class="function">Author <span class="title">joyce</span><span class="params">(<span class="string">"James"</span>, <span class="string">"Joyce"</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="pair_对象操作">pair 对象操作</h4><p>与其他标准库类型不同，对于 pair 类型，<strong>可以直接访问其数据成员，它的成员都是公有的</strong>。分别命名为 first 和 second。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> firstBook;</span><br><span class="line"><span class="keyword">if</span> (author.first == <span class="string">"James"</span> &amp;&amp; author == <span class="string">"Joyce"</span>)</span><br><span class="line">	firstBook = <span class="string">"Stephen Hero"</span>;</span><br></pre></td></tr></table></figure>
<p>除了构造函数之外，标准库还提供一个 make_pair 函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="built_in">string</span> first, last;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; first &gt;&gt; last) &#123;</span><br><span class="line">	next_auth = make_pair(first, last);</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为成员是公有的，所以可以直接输入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; next_auth;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; next_auth.first &gt;&gt; next_auth.second) &#123;</span><br><span class="line">	<span class="comment">// process next_auth...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联容器">关联容器</h3><p>关联容器与顺序容器共享大部分的操作，但并不是全部。关联容器不支持 <strong>front, push_front, pop_front, back, push_back, pop_back</strong> 等操作。共享的包括：</p>
<ol>
<li><p>三种构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C&lt;T&gt; c;</span><br><span class="line">C&lt;T&gt; c1(c2);</span><br><span class="line">C&lt;T&gt; c(begin, end);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算</p>
</li>
<li>begin，end，rbegin，rend</li>
<li>typedef。注意：对于 map 类型，<strong>value_type 的类型是 pair 类型。</strong></li>
<li>swap 和 赋值操作。<strong>但不提供 assign 函数</strong>。</li>
<li>clear，erase。<strong>关联容器 erase 操作返回 void 类型</strong>。</li>
<li>容器大小的操作。<strong>不支持 resize 操作</strong>。</li>
</ol>
<p>对于与顺序容器相同的操作，关联容器重新定义了这些操作的含义或返回类型，主要区别在于关联容器中使用了键。</p>
<blockquote>
<p>元素在关联容器中根据键的顺序排列。</p>
</blockquote>
<h3 id="map_类型">map 类型</h3><p>map 可以理解为 <strong>关联数组</strong>，但是通过键获取元素值，而不是位置。</p>
<h4 id="map_的定义">map 的定义</h4><p>要使用 map 需包含 map 头文件</p>
<table>
<thead>
<tr>
<th>map 的构造函数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v=""> m;</k,></td>
<td>空 map 对象，键和值得类型分别为 k 和 v</td>
</tr>
<tr>
<td>map<k, v=""> m(m1)</k,></td>
<td>创建 m1 的副本</td>
</tr>
<tr>
<td>map<k, v=""> m(begin, end);</k,></td>
<td>创建 begin 至 end 范围内所有元素的副本</td>
</tr>
</tbody>
</table>
<p><strong>键类型的约束</strong></p>
<p>在使用关联容器时，<strong>它的键类型必须要有一个比较函数</strong>。所使用的比较函数必须在键类型上<strong>严格弱排序</strong>。所谓严格弱排序，可以理解为键类型数据上的“小于”关系，不能出现相互“小于”的情况。</p>
<blockquote>
<p>在实际应用中，键类型必须定义 &lt; 操作符，而且该操作符能正确的工作。</p>
</blockquote>
<h4 id="map_定义的类型">map 定义的类型</h4><p>map 对象是键-值对，每个元素分为两个部分：键和其关联的值。map 的 value_type 可以很清楚的表示这种情况，该类型是 pair 类型。</p>
<table>
<thead>
<tr>
<th>map 定义的类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>map<k, v="">::key_type</k,></td>
<td>键的类型</td>
</tr>
<tr>
<td>map<k, v="">::mapped_type</k,></td>
<td>值的类型</td>
</tr>
<tr>
<td>map<k, v="">::value_type</k,></td>
<td>键-值的类型：pair类型。有 first 和 second 两个公有成员</td>
</tr>
</tbody>
</table>
<p>对 map 的迭代器解引用会产生一个 pair 类型值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator map_it = word_count.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;second;</span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>; <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h4 id="向_map_添加元素">向 map 添加元素</h4><p><strong>下标</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line">word_count[<span class="string">"Anna"</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上面程序会发生：</p>
<ol>
<li>在 <code>word_count</code> 中查找键为 Anna 的元素，没有找到；</li>
<li>将一个键为 Anna 的 pair 插入到 <code>word_count</code>，该 pair 的值为 (“Anna”, 0)。</li>
<li>读取新插入的元素，并将它赋值为 1.</li>
</ol>
<blockquote>
<p>故使用下标访问 map 中没有的元素会导致向该容器中添加一个新元素。</p>
</blockquote>
<p><strong>insert</strong></p>
<table>
<thead>
<tr>
<th>insert 操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.insert(p);</td>
<td>p 是 value_type 类型的值，如果 p.first 不存在，则插入 p 到 m，否则 m 保持不变。该函数返回一个 pair 对象，包含一个指向 p 的 map 的迭代器，和一个 bool 值。</td>
</tr>
<tr>
<td>m.insert(begin, end);</td>
<td>插入 begin 和 end 范围内的值。返回 void 类型</td>
</tr>
<tr>
<td>m.insert(iter, p)</td>
<td>如果 p.first 不在 m 中，则以 iter 为起点搜索 p 的存储位置。返回一个迭代器，指向新插入的 p。</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line">word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<p><strong>insert 的返回值类型</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">// use typedef</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret_type;</span><br><span class="line">ret_type ret = word_count.insert(make_pair(<span class="string">"Anna"</span>, <span class="number">1</span>)); <span class="comment">// equivalent way</span></span><br></pre></td></tr></table></figure>
<h4 id="查找_map_中的元素">查找 map 中的元素</h4><p>读取 map 中一个元素最简单的方法是下标：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; word_count;</span><br><span class="line"><span class="keyword">int</span> occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>但是有个弊端：如果该键不在 map 中，则会插入之。</p>
<p>对于查找或读取元素，map 提供了两个操作： count 和 find。</p>
<ol>
<li>find： <code>m.find(key)</code>, 如果存在 key 索引的元素，返回指向该元素的迭代器，否则返回末端迭代器，即 end()；</li>
<li>count：<code>m.count(key)</code>,  返回 m 中 k 出现的次数；</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (word_count.count(<span class="string">"Anna"</span>))</span><br><span class="line">	occurs = word_count[<span class="string">"Anna"</span>];</span><br></pre></td></tr></table></figure>
<p>这里对元素做了两次查询，在优化性能时可以考虑。find 则更适合查询元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> occurs = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator it = word_count.find(<span class="string">"Anna"</span>);</span><br><span class="line"><span class="keyword">if</span> (it != word_count.end())</span><br><span class="line">	occurs = it-&gt;second;</span><br></pre></td></tr></table></figure>
<h4 id="从_map_删除元素">从 map 删除元素</h4><table>
<thead>
<tr>
<th>删除元素</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.erase(key)</td>
<td>删除键为 k 的元素。返回 size_type 类型的值，表示删除元素的个数</td>
</tr>
<tr>
<td>m.erase(iter)</td>
<td>删除迭代器 iter 指向的元素。iter 必须指向存在的元素，且不能等于 m.end()。返回 void 类型。</td>
</tr>
<tr>
<td>m.erase(begin, end)</td>
<td>删除范围内的元素。返回 void 类型。</td>
</tr>
</tbody>
</table>
<h3 id="set_类型">set 类型</h3><p>set 跟 map 不同，它只是单纯的键的集合。支持：</p>
<ol>
<li>insert</li>
<li>count，find</li>
<li>erase</li>
</ol>
<p>另外：</p>
<ol>
<li>不支持下标操作；</li>
<li>没有 mapped_type 类型；</li>
</ol>
<h4 id="set_类型的定义和使用">set 类型的定义和使用</h4><p>set 存放的是一系列唯一值的集合。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) &#123;</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">	ivec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset(ivec.begin(), ivec.end());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; endl; <span class="comment">// prints 20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; endl; <span class="comment">// prints 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>向 set 添加元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; sset;</span><br><span class="line">sset.insert(<span class="string">"C.X.Q"</span>);</span><br><span class="line">sset.insert(<span class="string">"I L U"</span>);</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; iset;</span><br><span class="line">iset.insert(ivec.begin(), ivec.end());</span><br></pre></td></tr></table></figure>
<p><strong>从 set 中获取元素</strong></p>
<p>set 不提供下标操作，只能使用 find 和 count 函数，count 函数的返回值只能是 1 或 0，因为里面的元素都是唯一的。正如不能修改 map 的键一样，set 中的键也是 const 类型。在获得指向 set 中某元素的迭代器后，只能对其做读操作，不能做写操作。</p>
<h3 id="multiset_和_multimap">multiset 和 multimap</h3><p>map 和 set 中键都是唯一的，而 multimap 和 multiset 类型则允许同一个键多次出现。也就是说每次调用 insert 都会添加一个元素，而 erase 则会删除跟该键有关的所有元素。</p>
<h4 id="multiset_和_multimap_中查找元素">multiset 和 multimap 中查找元素</h4><p>在 multimap 中，同一个键的所有元素都相邻存放。</p>
<p><strong>使用 find 和 count 函数</strong></p>
<p>count 返回某个键的出现的次数，find 返回的是一个迭代器，指向第一个正在查找的键的实例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"C.X.Q."</span>)</span></span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;::size_type sz_type;</span><br><span class="line">sz_type entrise = authors.count(search_item);</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;::iterator iter = authors.find(search_item);</span><br><span class="line"><span class="keyword">for</span> (sz_type cnt = <span class="number">0</span>; cnt != entrise; ++cnt, ++iter)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><strong>另一种解决办法</strong></p>
<table>
<thead>
<tr>
<th>返回迭代器的关联操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>m.lower_cound(key)</td>
<td>返回一个迭代器，指向第一个不小于 key 的元素</td>
</tr>
<tr>
<td>m.upper_bound(key)</td>
<td>返回一个迭代器，指向第一个大于 key 的元素</td>
</tr>
<tr>
<td>m.equal_range(key)</td>
<td>返回一个迭代器的 pair 对象<br>first 成员等价于 m.lower_bound(key),second 成员等价于 m.upper_bound(key)</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>关联容器（associative container）支持通过键（key）来高效地查找和读取元素。它与顺序容器的主要区别在于：<strong>关联容器通过键存储和读取元素，而顺序容器则通过元素在容器中的位置顺序类存储和访问元素</strong>。</p>
<p>两个基本的关联容器是 map 和 set。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LaTeX: LLNCS v2.4]]></title>
    <link href="http://bluestein.github.io/2016/01/LATEX-LLNCS/"/>
    <id>http://bluestein.github.io/2016/01/LATEX-LLNCS/</id>
    <published>2016-01-09T02:02:00.000Z</published>
    <updated>2016-03-05T02:37:36.864Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/" target="_blank" rel="external">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h4 id="Invoke_LLNCS_class">Invoke LLNCS class</h4><p>LLNCS 只是标准 LATEX “article” class 的拓展版本，所以在文章中可以使用所有 “article” 的语法。如果要使用 LLNCS class，则使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\documentclass&#123;llncs&#125;</span><br><span class="line">%</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">&lt;Your contribution&gt;</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<h4 id="文章已经用_LATEX_写好而未使用_LLNCS_格式的情况">文章已经用 LATEX 写好而未使用 LLNCS 格式的情况</h4><p>请不要使用任何会影响文档布局或格式的 LATEX 或 TEX命令（即像 <code>\textheight</code>, <code>\vspace</code>, <code>\headsep</code>, etc）。然而，有可能会有例外的情况下，可以使用一些。</p>
<h3 id="公式输入">公式输入</h3><p>公式会以您文章出现的顺序在右手边使用阿拉伯数字自动编号。当你的工作在数学模式时，都是用斜体字排版。有时候你需要插入非数学元素（例如单词或短语）。这种插入的代码应该使用 roman（即 <code>\mbox</code>）如下例所示： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125; </span><br><span class="line">\left(\frac&#123;a^&#123;<span class="number">2</span>&#125; + b^&#123;<span class="number">2</span>&#125;&#125;&#123;c^&#123;<span class="number">3</span>&#125;&#125; \right) = <span class="number">1</span> \quad</span><br><span class="line">\mbox&#123; <span class="keyword">if</span> &#125; c\neq <span class="number">0</span> \mbox&#123; and <span class="keyword">if</span> &#125; a,b,c\in \bbbr \enspace .</span><br><span class="line">\end&#123;equation&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例：</p>
<p><img src="/images/equation_sample.png" alt=""></p>
<p>如果你想在一个显示公式后立即开始新的段落，插入一个空白行，以产生所需的缩进。如果不插入一个空白行或代码 <code>\noindent</code> 会立即继续之前的文本而没有没有新的段落。</p>
<p>displayed 公式也使用相同的方式处理，其他普通文本则在结束本句前使用 <code>\enspace</code>。</p>
<p>注意括号的尺寸或其他分隔符必须保证是闭合的，使用下面命令可以保证：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\left( 或者 \left[ 和 \right) 或者 \right].</span><br></pre></td></tr></table></figure>
<h4 id="斜体和_Roman_体">斜体和 Roman 体</h4><ol>
<li>在公式中，一般使用斜体，但下标应使用 Roman 体而不是斜体。</li>
<li>确保一些物理标记使用 <code>\mathrm</code> 命令，如 Hz： <code>\mathrm{Hz}</code>。还有一些常用的数学函数，如 log，sin，exp，max和sup应该使用：<code>\log</code>，<code>\sin</code>，<code>\exp</code>，<code>\max</code> 和 <code>\sup</code>。</li>
<li>化学式应该使用 Roman 体，如： H2O。</li>
<li>熟悉的单词或句子不应使用斜体，如： et al., a priori, in situ, bremsstrahlung, eigenvalues。</li>
</ol>
<h3 id="How_to_Edit_Input_(Source)_File">How to Edit Input (Source) File</h3><h4 id="Headings">Headings</h4><p>标题中的所有单词应该都大写，除了连词、介词 (例如 on, of, by, and, or, but, from, with, without, under) 还有定冠词和不定冠词 (the, a, an) 除非他们出现在开头，否则均小写。公式的字母必须在文本内排版。</p>
<h4 id="大写和不大写">大写和不大写</h4><ol>
<li>下面情况均需大写：<ol>
<li>Headings。</li>
<li>文章中的缩写和表达式，如：  Fig(s)., Table(s), Sect(s)., Chap(s)., Theorem, Corollary, Deﬁnition etc. 跟数字一起使用时，如： Fig.3, Table 1, Theorem 2。</li>
</ol>
</li>
<li>下面情况不能大写：<ol>
<li>在文章中，当 ﬁgure(s), table(s), equation(s), theorem(s) 等词没有与编号一起使用时。</li>
<li>图表图例和表格标题，除非是缩写。</li>
</ol>
</li>
</ol>
<h4 id="词的缩写">词的缩写</h4><ol>
<li>下列词除非是出现在句子开头，否则在文章中应该使用缩写： Chap., Sect., Fig.。例如： The results are depicted in Fig.5. Figure 9 reveals that …. <blockquote>
<p>注： 公式一般使用括号跟数字代替，但出现在句子开头时需使用 “Equation”。 例如：Equation (14) is very important. However, (15) makes it clear that …. </p>
</blockquote>
</li>
<li>如果文章中有出现全局的缩写，应该在第一次出现的时候标明，如： Plurisubharmonic (PSH) Functions, Strong Optimization (SOPT) Problem.</li>
</ol>
<h3 id="文章的开头">文章的开头</h3><p>文章的标题（必须的）使用如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;&lt;Your contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>标题中所有单词应大写，除了连词、介词和不出现在开头的定冠词和不定冠词。标题没有结束标点。</p>
<p>如果是很长的标题，使用 <code>\\</code> 另起一行。</p>
<p>If you are to produce running heads for a speciﬁc volume the standard (of no such running heads) is overwritten with the [runningheads] option in the \documentclass line. For long titles that do not ﬁt in the single line of the running head a warning is generated. You can specify an abbreviated title for the running head on odd pages with the command：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\titlerunning&#123;&lt;Your abbreviated contribution title&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>There is also a possibility to change the text of the title that goes into the table of contents (that’s for volume editors only – there is no table of contents for a single contribution). For this use the command:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\toctitle&#123;&lt;Your changed title <span class="keyword">for</span> the table of contents&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>副标题使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\subtitle&#123;&lt;subtitle of your contribution&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>作者使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;&lt;author(s) name(s)&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>为每个作者或地址指定标号时，使用： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\inst&#123;&lt;no&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>超过一位作者的话，可以使用 <code>\and</code> 分隔。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是地址（学校，公司）了，多于一个地址，使用 <code>\and</code> 命令会自动编号，请确保跟作者顺序对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\institute&#123;&lt;name of an institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;</span><br><span class="line">\and &lt;name of the next institute&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>\institute</code> 内使用 <code>\email{&lt;email address&gt;}</code> 可以提供email地址。如果在文章的任何地方需要注脚，请使用(immediately after the word where the footnote indicator should be placed)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\thanks&#123;&lt;text&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>\thanks</code> 仅能出现在 <code>\title</code>, <code>\author</code> and <code>\institute</code>中. 如果有两个或更多的脚注使用 <code>\fnmsep</code> (i.e. footnote mark separator) 分隔.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\maketitle</span><br></pre></td></tr></table></figure>
<p>然后 heading 就结束了，到这一步为止，还不会产生任何文本。</p>
<p>接下来就是摘要：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">&lt;Text of the summary of your article&gt;</span><br><span class="line">\end&#123;abstract&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### How to Code Your Text ###</span></span><br><span class="line"></span><br><span class="line">用以下代码的话，标题会自动编号：</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line">\section&#123;This is a First-Order Title&#125; </span><br><span class="line">\subsection&#123;This is a Second-Order Title&#125; </span><br><span class="line">\subsubsection&#123;This is a Third-Order Title.&#125; </span><br><span class="line">\paragraph&#123;This is a Fourth-Order Title.&#125;</span><br></pre></td></tr></table></figure>
<p><code>\section</code> and <code>\subsection</code> 没有 end punctuation。<code>\subsubsection</code> and <code>\paragraph</code> 需要在末尾 punctuate。 </p>
<p>另外，theorem-like environments 会自动编号，如果要使用计数器，只需指定 <code>envcountsame</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountsame]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>例如 <code>\begin{lema}</code>，第一次调用时会编号为1，再次调用编号为2，以此类推。如果需要每个 section 都重新计数，则指定为 <code>envcountreset</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[envcountreset]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h3 id="预定义的_Theorem-like_Environments">预定义的 Theorem-like Environments</h3><p>下面的标题随你选择：</p>
<ol>
<li><p>加粗并带斜体文本的 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;corollary&#125; &lt;text&gt; \end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; &lt;text&gt; \end&#123;lemma&#125; </span><br><span class="line">\begin&#123;proposition&#125; &lt;text&gt; \end&#123;proposition&#125; </span><br><span class="line">\begin&#123;theorem&#125; &lt;text&gt; \end&#123;theorem&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以下的一般表现为斜体 run-in 标题：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;proof&#125; &lt;text&gt; \qed \end&#123;proof&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这不编号，并且在结束前有一个吸引眼球的 square （即 <code>\qed</code>）。</p>
<ol>
<li>更多斜体和加粗体 run-in 标题：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;definition&#125; &lt;text&gt; \end&#123;definition&#125;</span><br><span class="line">\begin&#123;example&#125; &lt;text&gt; \end&#123;example&#125; </span><br><span class="line">\begin&#123;exercise&#125; &lt;text&gt; \end&#123;exercise&#125; </span><br><span class="line">\begin&#123;note&#125; &lt;text&gt; \end&#123;note&#125; </span><br><span class="line">\begin&#123;problem&#125; &lt;text&gt; \end&#123;problem&#125; </span><br><span class="line">\begin&#123;question&#125; &lt;text&gt; \end&#123;question&#125; </span><br><span class="line">\begin&#123;remark&#125; &lt;text&gt; \end&#123;remark&#125; </span><br><span class="line">\begin&#123;solution&#125; &lt;text&gt; \end&#123;solution&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="自定义的_Theorem-like_Environments">自定义的 Theorem-like Environments</h3><p>加强了标准的 <code>\newtheorem</code> 命令，得到两个新的命令 <code>\ spnewtheorem</code> 和 <code>\spnewtheorem*</code>，现在可以使用来定义新的语法。需要两个参数：type style 和 text style。type style 表示所出现的环境，text style 表示新环境的 text style。使用 <code>\ spnewtheorem</code> 的两种方法：</p>
<h4 id="第一种（推荐！）">第一种（推荐！）</h4><p>如果想与其他环境共享计数器，使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;[&lt;num_like&gt;]&#123;&lt;caption&gt;&#125; &#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>[&lt;num_like&gt;]</code> 指定为想要共享的环境。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;mainth&#125;[theorem]&#123;Main Theorem&#125;&#123;\bfseries&#125;&#123;\itshape&#125; </span><br><span class="line">\begin&#123;theorem&#125; The early bird gets the worm. \end&#123;theorem&#125; </span><br><span class="line">\begin&#123;mainth&#125; The early worm gets eaten. \end&#123;mainth&#125;</span><br></pre></td></tr></table></figure>
<p>输出为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Theorem <span class="number">3.</span> The early bird gets the worm. </span><br><span class="line">Main Theorem <span class="number">4.</span> The early worm gets eaten.</span><br></pre></td></tr></table></figure>
<h4 id="第二种">第二种</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;[&lt;within&gt;]</span><br><span class="line">&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会定义一个名为 <code>&lt;env_name&gt;</code> 的环境，它以 <code>&lt;cap_font&gt;</code> 打印标题 <code>&lt;caption&gt;</code>， 它以 <code>&lt;body_font&gt;</code> 打印文本。在每个新 section 指定 <code>&lt;within&gt;</code> 时，会重新编号。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem&#123;joke&#125;&#123;Joke&#125;[subsection]&#123;\bfseries&#125;&#123;\rmfamily&#125;</span><br></pre></td></tr></table></figure>
<p>deﬁnes a new environment called joke which prints the caption Joke in boldface and the text in roman. The jokes are numbered starting from 1 at the beginning of every subsection with the number of the subsection preceding the number of the joke e.g. 7.2.1 for the ﬁrst joke in subsection 7.2.</p>
<h4 id="Unnumbered_Environments">Unnumbered Environments</h4><p>如果想要非编号环境，使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\spnewtheorem*&#123;&lt;env_nam&gt;&#125;&#123;&lt;caption&gt;&#125;&#123;&lt;cap_font&gt;&#125;&#123;&lt;body_font&gt;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="程序代码">程序代码</h3><p>可以使用 verbatim 环境或者 LATEX 的 verbatim package。</p>
<p>文章示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">\title&#123;Hamiltonian Mechanics&#125;</span><br><span class="line">\author&#123;Ivar Ekeland\inst&#123;<span class="number">1</span>&#125; \and Roger Temam\inst&#123;<span class="number">2</span>&#125;&#125;</span><br><span class="line">\institute&#123;Princeton University, Princeton NJ <span class="number">08544</span>, USA</span><br><span class="line">\and </span><br><span class="line">Universit\’&#123;e&#125; de Paris-Sud, </span><br><span class="line">Laboratoire d’Analyse Num\’&#123;e&#125;rique, B\^&#123;a&#125;timent <span class="number">425</span>,\\</span><br><span class="line">F-<span class="number">91405</span> Orsay Cedex, France&#125;</span><br><span class="line"></span><br><span class="line">\maketitle </span><br><span class="line">% </span><br><span class="line">\begin&#123;abstract&#125;</span><br><span class="line">This paragraph shall summarize the contents of the paper in <span class="keyword">short</span> terms. </span><br><span class="line">\end&#123;abstract&#125; </span><br><span class="line">%</span><br><span class="line">\section&#123;Fixed-Period Problems: The Sublinear Case&#125; </span><br><span class="line">% </span><br><span class="line">With <span class="keyword">this</span> chapter, the preliminaries are over, and we begin the search <span class="keyword">for</span> periodic solutions \dots </span><br><span class="line">% </span><br><span class="line">\subsection&#123;Autonomous Systems&#125; </span><br><span class="line">% </span><br><span class="line">In <span class="keyword">this</span> section we will consider the <span class="keyword">case</span> when the Hamiltonian </span><br><span class="line">$H(x)$ \dots </span><br><span class="line">% </span><br><span class="line">\subsubsection*&#123;The General Case: Nontriviality.&#125; </span><br><span class="line">% </span><br><span class="line">We assume that $H$ is </span><br><span class="line">$\left(A_&#123;\infty&#125;, B_&#123;\infty&#125;\right)$-subqua\-dra\-tic </span><br><span class="line">at infinity, <span class="keyword">for</span> some constant \dots </span><br><span class="line">% </span><br><span class="line">\paragraph&#123;Notes and Comments.&#125; </span><br><span class="line">The first results on subharmonics were \dots </span><br><span class="line">% </span><br><span class="line">\begin&#123;proposition&#125;</span><br><span class="line">Assume $H’(<span class="number">0</span>)=<span class="number">0</span>$ and $ H(<span class="number">0</span>)=<span class="number">0</span>$. Set \dots </span><br><span class="line">\end&#123;proposition&#125; </span><br><span class="line">\begin&#123;proof&#125;[of proposition] </span><br><span class="line">Condition (<span class="number">8</span>) means that, <span class="keyword">for</span> every $\delta’&gt;\delta$, there is </span><br><span class="line">some $\varepsilon&gt;<span class="number">0</span>$ such that \dots \qed </span><br><span class="line">\end&#123;proof&#125; </span><br><span class="line">% </span><br><span class="line">\begin&#123;example&#125;[\rmfamily (External forcing)] </span><br><span class="line">Consider the system \dots </span><br><span class="line">\end&#123;example&#125; </span><br><span class="line">\begin&#123;corollary&#125; </span><br><span class="line">Assume $H$ is $C^&#123;<span class="number">2</span>&#125;$ and </span><br><span class="line">$\left(a_&#123;\infty&#125;, b_&#123;\infty&#125;\right)$-subquadratic </span><br><span class="line">at infinity. Let \dots </span><br><span class="line">\end&#123;corollary&#125; </span><br><span class="line">\begin&#123;lemma&#125; </span><br><span class="line">Assume that $H$ is $C^&#123;<span class="number">2</span>&#125;$ on $\bbbr^&#123;<span class="number">2</span>n&#125;\backslash \&#123;<span class="number">0</span>\&#125;$ </span><br><span class="line">and that $H’’(x)$ is \dots </span><br><span class="line">\end&#123;lemma&#125; </span><br><span class="line">\begin&#123;theorem&#125;[(Ghoussoub-Preiss)] </span><br><span class="line">Let $X$ be a Banach Space and $\Phi:X\to\bbbr$ \dots</span><br><span class="line">\end&#123;theorem&#125; </span><br><span class="line">\begin&#123;definition&#125; </span><br><span class="line">We shall say that a $C^&#123;<span class="number">1</span>&#125;$ function $\Phi:X\to\bbbr$ </span><br><span class="line">satisfies \dots </span><br><span class="line">\end&#123;definition&#125;</span><br></pre></td></tr></table></figure>
<p>输出示例如下图，或<a href="http://www.springer.com/computer/lncs/lncs+authors" target="_blank" rel="external">官网</a>下载查看</p>
<p><img src="/images/paper_sample.png" alt=""></p>
<h3 id="文本优化">文本优化</h3><table>
<thead>
<tr>
<th>文本优化</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>\,</td>
<td>产生一个小型空格。例如在数字之间</td>
</tr>
<tr>
<td>—</td>
<td>产生一个横杠。前后无空格</td>
</tr>
<tr>
<td>&nbsp;—&nbsp;</td>
<td>产生一个横杠。前后各一空格</td>
</tr>
<tr>
<td>-</td>
<td>连字符。前后无空格</td>
</tr>
<tr>
<td>$-$</td>
<td>负号。只在文本中使用</td>
</tr>
</tbody>
</table>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>\,$^&#123;\circ&#125;$C etc., </span><br><span class="line">Dr h.\,c.\,Rockefellar-Smith \dots </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>\,km and Prof.\,Dr Mallory \dots </span><br><span class="line"><span class="number">1950</span>--<span class="number">1985</span> \dots </span><br><span class="line"><span class="keyword">this</span> -- written on a computer -- is now printed </span><br><span class="line">$-<span class="number">30</span>$\,K \dots</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>◦C etc., Dr h.c.Rockefellar-Smith ... </span><br><span class="line"><span class="number">20</span>,<span class="number">000</span>km and Prof.Dr Mallory ... </span><br><span class="line"><span class="number">1950</span>–<span class="number">1985</span> ... </span><br><span class="line"><span class="keyword">this</span> – written on a computer – is now printed </span><br><span class="line">−<span class="number">30</span>K ...</span><br></pre></td></tr></table></figure>
<h3 id="特殊字体">特殊字体</h3><p>普通的字体类型（Roman）不需要代码。斜体 (<code>{\em &lt;text&gt;}</code> 或 <code>\emph{&lt;text&gt;}</code>)，如果需要，黑体用于强调：</p>
<table>
<thead>
<tr>
<th>特殊字体</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{\itshape Text}</code></td>
<td>斜体文本</td>
</tr>
<tr>
<td><code>{\em &lt;text&gt;}</code></td>
<td>强调的文本</td>
</tr>
<tr>
<td><code>{\bfseries Text}</code></td>
<td>重要文本</td>
</tr>
<tr>
<td><code>\vec{Symbol}</code></td>
<td>向量只能出现在 math mode。如 <code>$\vec{A \times B\cdot C}</code> 得到 <code>A×B ·C</code></td>
</tr>
</tbody>
</table>
<h3 id="Footnotes">Footnotes</h3><p>注脚应该被包含在下面代码中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\footnote&#123;Text&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote\footnote&#123;The footnote is automatically numbered.&#125; and text continues ...</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Text with a footnote^<span class="number">4</span> and text continues ...</span><br></pre></td></tr></table></figure>
<h3 id="Lists">Lists</h3><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125; </span><br><span class="line">  \item First item </span><br><span class="line">  \item Second item </span><br><span class="line">  \begin&#123;enumerate&#125; </span><br><span class="line">    \item First nested item </span><br><span class="line">    \item Second nested item </span><br><span class="line">  \end&#123;enumerate&#125; \item </span><br><span class="line">  Third item </span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. First item </span><br><span class="line">2. 2. Second item </span><br><span class="line">   (a) First nested item</span><br><span class="line">   (b) Second nested item </span><br><span class="line">3. Third item</span><br></pre></td></tr></table></figure>
<h3 id="插图">插图</h3><p>图片应该插入到第一次提到该图片的段落后（不是段落中），它会被自动编号。图片应该是 PostScript 文件——最好是 EPS 数据，通过 epsfig package 生成。</p>
<p>格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;x cm&#125; </span><br><span class="line">\caption[ ]&#123;...text of caption...&#125; (Do type [ ]) </span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<p><code>x</code>表示图片的高度。 </p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;figure&#125; </span><br><span class="line">\vspace&#123;<span class="number">2.5</span>cm&#125; </span><br><span class="line">\caption&#123;This is the caption of the figure displaying a white eagle and a white horse on a snow field&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更多请参见 LATEX 文档 p. 26 ff. 和 p. 204</p>
</blockquote>
<h3 id="表格">表格</h3><h4 id="使用_LATEX_编写表格">使用 LATEX 编写表格</h4><p>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125; </span><br><span class="line">\caption&#123;Critical $N$ values&#125; </span><br><span class="line">\begin&#123;tabular&#125;&#123;llllll&#125; </span><br><span class="line">\hline\noalign&#123;\smallskip&#125;</span><br><span class="line">$&#123;\mathrm M&#125;_\odot$ &amp; $\beta_&#123;<span class="number">0</span>&#125;$ &amp; $T_&#123;\mathrm c6&#125;$ &amp; $\gamma$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm L&#125;$ </span><br><span class="line">  &amp; $N_&#123;\mathrm&#123;crit&#125;&#125;^&#123;\mathrm&#123;Te&#125;&#125;$\\ </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">\hline </span><br><span class="line">\noalign&#123;\smallskip&#125; </span><br><span class="line">  <span class="number">30</span> &amp; <span class="number">0.82</span> &amp; <span class="number">38.4</span> &amp; <span class="number">35.7</span> &amp; <span class="number">154</span> &amp; <span class="number">320</span> \\ </span><br><span class="line">  <span class="number">60</span> &amp; <span class="number">0.67</span> &amp; <span class="number">42.1</span> &amp; <span class="number">34.7</span> &amp; <span class="number">138</span> &amp; <span class="number">340</span> \\ </span><br><span class="line">  <span class="number">120</span> &amp; <span class="number">0.52</span> &amp; <span class="number">45.1</span> &amp; <span class="number">34.0</span> &amp; <span class="number">124</span> &amp; <span class="number">370</span> \\ </span><br><span class="line">\hline </span><br><span class="line">\end&#123;tabular&#125; </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="/images/table_sample.png" alt=""></p>
<h4 id="不使用_LATEX">不使用 LATEX</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\caption&#123;text of your caption&#125; </span><br><span class="line">\vspace&#123;x cm&#125; % the actual height needed <span class="keyword">for</span> your table </span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Signs_and_Characters">Signs and Characters</h4><p>更多请参见原文档和 LATEX 官方文档 pp.41 ff.</p>
<h4 id="参考文献">参考文献</h4><p>有三种参考文献模式：number only，letter-number， 或 author-year。更多请参见 LATEX 官方文档 p. 71.<br>LLNCS 有一种特殊的 BIBTEX 格式，使用class： splncs.bst。调用代码 <code>\bibliographystyle{splncs}</code>。<br>如果打算使用 author BIBTEX style，请指定 <code>[oribibl]</code> 参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[oribibl]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Letter-Number_或_Number_Only">Letter-Number 或 Number Only</h4><p>在文章中使用 <code>\cite</code> 命令来引用文章，会得到形如：[1]，[E1, S2], [P1] 中之一的格式，这取决于  thebibliography 环境中 <code>\bibitem</code> 的使用。</p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;[MT1]&#125; </span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[CE1]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>会产生类似的效果：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[CE1] Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">[CE2] Clarke, F., Ekeland, I.: Solutions p´eriodiques, du p´eriode donn´ee, des ´equations hamiltoniennes. Note CRAS Paris <span class="number">287</span>, <span class="number">1013</span>–<span class="number">1015</span> (<span class="number">1978</span>)</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of \cite&#123;clar:eke&#125;;</span><br></pre></td></tr></table></figure>
<p>会得到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The results in <span class="keyword">this</span> section are a refined version of [CE1];</span><br></pre></td></tr></table></figure>
<p><strong>Number-Only System</strong></p>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;<span class="number">1</span>&#125; </span><br><span class="line">\bibitem &#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\cite&#123;n1,n3,n2,n3,n4,n5,foo,n1,n2,n3,?,n4,n5&#125;</span><br></pre></td></tr></table></figure>
<p>能够得到：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>-<span class="number">5</span>,foo,<span class="number">1</span>-<span class="number">3</span>,?,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h4 id="Author-Year_System">Author-Year System</h4><p>效果就像这样：<code>(Smith 1970,1980),(Ekelandetal.1985,Theorem2),(JonesandJffe 1986; Farrow 1988, Chap.2)</code>。如果名字作为句子的一部分，那么括号内就可能只出现年份，如，<code>Ekeland et al. (1985, Sect.2.1)</code>。</p>
<p>如果有几个文章属于同一（多）个作者，引用时应列在适当的顺序，表示如下：</p>
<ol>
<li>一个作者：按文章时间排序；</li>
<li>相同的合作作者：按文章时间排序；</li>
<li>和不同的合作作者：按合作作者名字进行字母排序；</li>
</ol>
<p>如果，有多个同样的作者同样的时间的文章，用 “a”, “b”, “c”, etc 区分。</p>
<p><strong>How to Code Author-Year System</strong></p>
<p>要使用这个系统，则需指定 <code>[citeauthoryear]</code> 参数，如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[citeauthoryear]&#123;llncs&#125;</span><br></pre></td></tr></table></figure>
<p>thebibliography 环境:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;thebibliography&#125;&#123;&#125; % (<span class="keyword">do</span> not forget &#123;&#125;)</span><br><span class="line">. </span><br><span class="line">. </span><br><span class="line">\bibitem[<span class="number">1982</span>]&#123;clar:eke&#125; </span><br><span class="line">Clarke, F., Ekeland, I.: </span><br><span class="line">Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> </span><br><span class="line">Hamiltonian systems. </span><br><span class="line">Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>--<span class="number">333</span> (<span class="number">1982</span>) </span><br><span class="line">.</span><br><span class="line">. </span><br><span class="line">\end&#123;thebibliography&#125;</span><br></pre></td></tr></table></figure>
<p>产生样例：<br>cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clarke, F., Ekeland, I.: Nonlinear oscillations and boundary-value problems <span class="keyword">for</span> Hamiltonian systems. Arch. Rat. Mech. Anal. <span class="number">78</span>, <span class="number">315</span>–<span class="number">333</span> (<span class="number">1982</span>)</span><br></pre></td></tr></table></figure></p>
<p>在文章中引用时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(\cite&#123;clar:eke&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>产生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The results in <span class="keyword">this</span> section are a refined version of Clarke and <span class="title">Ekeland</span> <span class="params">(<span class="number">1982</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>END. </p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>最近写的论文需要使用到 LaTeX 格式，故学习一些相关的知识。不过下面的并不是 LaTeX 教程，只是 Springer 的 LLNCS 类，具体的 LaTex 相关请见<a href="http://www.latex-project.org/">官网</a></p>
<h3 id="How_to_proceed">How to proceed</h3><p>下载的压缩包包含如下文件:</p>
<table>
<thead>
<tr>
<th>Files in package</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>history.txt</td>
<td>the version history of the package</td>
</tr>
<tr>
<td>llncs.cls</td>
<td>class ﬁle for LATEX</td>
</tr>
<tr>
<td>llncs.dem</td>
<td>an example showing how to code the text</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document), llncs.doc means latex documentation for Lecture Notes in Computer Science</td>
</tr>
<tr>
<td>llncsdoc.pdf</td>
<td>the documentation of the class (PDF version)</td>
</tr>
<tr>
<td>llncs.doc</td>
<td>general instructions (source of this document)</td>
</tr>
<tr>
<td>llncsdoc.sty</td>
<td>class modiﬁcations to help for the instructions</td>
</tr>
<tr>
<td>llncs.ind</td>
<td>an external (faked) author index ﬁle</td>
</tr>
<tr>
<td>subjidx.ind</td>
<td>subject index demo from the Springer book package</td>
</tr>
<tr>
<td>llncs.dvi</td>
<td>the resultig DVI ﬁle (remember to use binary transfer!)</td>
</tr>
<tr>
<td>sprmindx.sty</td>
<td>supplementary style ﬁle for MakeIndex (usage: <code>makeindex -s sprmindx.sty &lt;yourfile.idx&gt;</code>)</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="LLNCS" scheme="http://bluestein.github.io/tags/LLNCS/"/>
    
      <category term="LaTeX" scheme="http://bluestein.github.io/tags/LaTeX/"/>
    
      <category term="Odds&amp;Ends" scheme="http://bluestein.github.io/categories/Odds-Ends/"/>
    
      <category term="LaTex" scheme="http://bluestein.github.io/categories/Odds-Ends/LaTex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[顺序容器]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-sequential_container/"/>
    <id>http://bluestein.github.io/2016/01/cpp-sequential_container/</id>
    <published>2016-01-02T10:46:49.000Z</published>
    <updated>2016-03-05T02:37:36.895Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>顺序容器</strong></td>
<td>-</td>
</tr>
<tr>
<td>vector</td>
<td>支持快速随机访问</td>
</tr>
<tr>
<td>list</td>
<td>支持快速插入删除</td>
</tr>
<tr>
<td>deque</td>
<td>双端队列</td>
</tr>
<tr>
<td><strong>顺序容器适配器</strong></td>
<td>-</td>
</tr>
<tr>
<td>stack</td>
<td>后进先出（LIFO）</td>
</tr>
<tr>
<td>queue</td>
<td>先进先出（FIFO）</td>
</tr>
<tr>
<td>priority_queue</td>
<td>有优先级管理的队列</td>
</tr>
</tbody>
</table>
<h3 id="顺序容器的定义">顺序容器的定义</h3><p>首先必须包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>所有顺序容器都是类模板</strong>。要定义某种特殊的容器，必须在容器名后添加一对尖括号，尖括号内提供容器将要存放元素的类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist;</span><br><span class="line"><span class="built_in">deque</span>&lt;Sales_item&gt; item;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有容器都有默认构造函数，该构造函数不带任何参数</p>
</blockquote>
<h4 id="初始化">初始化</h4><p>除了默认构造函数，容器类型还提供了其他的构造函数，可以指定其元素的初值</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>C<t> c;</t></td>
<td>创建名为 c 的容器。<br>C 为容器名，如 vector。<br>T为元素类型，如string，int。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c2(c1)</td>
<td>创建容器 c1 的副本。<br>c2 和 c1 必须是相同类型的容器，并存放相同类型的元素。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(begin, end)</td>
<td>使用迭代器 begin 和 end 范围内的元素创建 c。<br><strong>适用于任何容器</strong></td>
</tr>
<tr>
<td>C c(n, t)</td>
<td>用 n 个值为 t 的元素创建容器。<br>t 必须与容器存放的类型匹配，或者可以转化为该类型的值。<br><strong>只适用于顺序容器</strong></td>
</tr>
<tr>
<td>C c(n)</td>
<td>创建 n 个默认初始值的容器。<br><strong>只适用于顺序容器</strong></td>
</tr>
</tbody>
</table>
<p><strong>初始化为另一个容器的副本</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2(ivec1); <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(ivec1); <span class="comment">// error: ivec is not list&lt;int&gt;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; dvec(ivec); <span class="comment">// error: ivec holds int not double</span></span><br></pre></td></tr></table></figure>
<p><strong>初始化为另一容器的部分元素</strong></p>
<p>允许通过传递一对迭代器来初始化容器。使用迭代器时，不需要容器类型相同，容器内的元素类型可以不同，只要相容即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(svec.begin(), svec.end());</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator mid = svec.begin() + svec.size() / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; front(svec.begin(), mid);</span><br></pre></td></tr></table></figure>
<p>因为指针就是迭代器，所以可以用数组中的值对容器进行初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *words1[] = &#123;<span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span>&#125;;</span><br><span class="line"><span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(words1) / <span class="keyword">sizeof</span>(<span class="keyword">char</span> *);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; words2(words1, words1 + sz);</span><br></pre></td></tr></table></figure>
<p><strong>初始化指定数目的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>都是 10 个元素的 list，<code>slist</code> 的每个值初始化为 <strong>hi</strong>， <code>ilist</code> 每个值初始化为 <strong>0</strong>。</p>
<blockquote>
<p>只有当元素类型有默认构造函数时才可以使用 <code>C c(n)</code> 的方式初始化。例如上面的 int 默认初始化为 0。</p>
</blockquote>
<p><strong>容器的容器</strong></p>
<p>支持容器的容器，不过要注意使用空格</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; lines; <span class="comment">// ok</span></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; lines; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>否则被认为是右移操作。</p>
<h3 id="迭代器和迭代器的范围">迭代器和迭代器的范围</h3><p>标准库为所有容器类提供的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*iter</td>
<td>解引用</td>
</tr>
<tr>
<td>iter-&gt;member</td>
<td>解引用，获取指定名为 member 的成员，等价于 (*iter).member</td>
</tr>
<tr>
<td>++iter<br>iter++</td>
<td>使iter指向后一个元素</td>
</tr>
<tr>
<td>–iter<br>iter–</td>
<td>使iter指向前一个元素</td>
</tr>
<tr>
<td>iter1 == iter2<br>iter1 != iter2</td>
<td>比较是否相等</td>
</tr>
</tbody>
</table>
<h4 id="vector,_deque额外的操作">vector, deque额外的操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>iter + n<br>iter - n</td>
<td>使iter指向后（前） n 个元素</td>
</tr>
<tr>
<td>iter1 += iter2<br>iter1 -= iter2<br>iter1 - iter2</td>
<td>迭代器运算</td>
</tr>
<tr>
<td>&gt;, &gt;=, &lt;, &lt;=</td>
<td>关系操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只适用于 vector 和 deque</p>
</blockquote>
<h3 id="顺序容器的操作">顺序容器的操作</h3><p>每种顺序容器都有以下操作</p>
<ol>
<li>向容器添加元素</li>
<li>删除元素</li>
<li>设置容器大小</li>
<li>获取容器第一个或最后一个元素（如果有的话）</li>
</ol>
<h4 id="为容器定义的类型别名">为容器定义的类型别名</h4><table>
<thead>
<tr>
<th>别名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>size_type</td>
<td>无符号整型，足以存储此容器类型的最大可能长度</td>
</tr>
<tr>
<td>iterator</td>
<td>此容器类型的迭代器</td>
</tr>
<tr>
<td>const_iterator</td>
<td>只读类型迭代器</td>
</tr>
<tr>
<td>reverse_iterator</td>
<td>逆序寻址的迭代器</td>
</tr>
<tr>
<td>const_reverse_iterator</td>
<td>只读逆序寻址的迭代器</td>
</tr>
<tr>
<td>difference_type</td>
<td>足够存储两迭代器差值的有符号整型，可为负值</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>reference</td>
<td>元素的左值类型，是 value_type&amp; 的同义词</td>
</tr>
<tr>
<td>const_reference</td>
<td>元素的常量左值类型，等价于 const value_type&amp;</td>
</tr>
</tbody>
</table>
<h4 id="begin_和_end_成员">begin 和 end 成员</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.begin()</td>
<td>返回一个迭代器，指向容器的第一个元素</td>
</tr>
<tr>
<td>c.end()</td>
<td>返回一个迭代器，指向容器最后一个元素的后面一个位置</td>
</tr>
<tr>
<td>c.rbegin()</td>
<td>逆序迭代器，指向容器的最后一个元素</td>
</tr>
<tr>
<td>c.rend()</td>
<td>返回一个逆序迭代器，指向容器第一个元素前面的位置</td>
</tr>
</tbody>
</table>
<h4 id="添加元素">添加元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.push_back(t)</td>
<td>在容器尾部添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.push_front(t)</td>
<td>在容器前端添加值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, t)</td>
<td>在迭代器p所指元素的前面插入一个值为 t 的元素，返回指向新添加元素的迭代器</td>
</tr>
<tr>
<td>c.insert(p, n, t)</td>
<td>在迭代器p所指元素的前面插入 n 个值为 t 的元素，返回 void 类型</td>
</tr>
<tr>
<td>c.insert(p, begin, end)</td>
<td>在迭代器p所指元素的前面插入迭代器 begin 和 end 范围内的元素，返回 void 类型</td>
</tr>
</tbody>
</table>
<blockquote>
<p>迭代器可能会失效。指向新加入元素后面的那个元素的迭代器会失效</p>
</blockquote>
<h4 id="关系操作符">关系操作符</h4><p>要使用类型相同的进行比较</p>
<ol>
<li>如果两容器有相同长度并且所有元素相等，则两个容器相等；</li>
<li>如果两容器有不同长度，但较短容器的元素等于较长容器的子序列，则短容器小于长容器；</li>
<li>如果不存在子序列，则比较第一个不同的元素；</li>
</ol>
<h4 id="容器大小">容器大小</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.size()</td>
<td>返回容器 c 中的元素个数，类型为 c::size_type</td>
</tr>
<tr>
<td>c.max_size()</td>
<td>最多可容纳个数</td>
</tr>
<tr>
<td>c.empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>c.resize(n)</td>
<td>调整 c 的大小，容量为 n</td>
</tr>
<tr>
<td>c.resize(n, t</td>
<td>调整 c 的大小，容量为 n，所有新添加的元素值为 t</td>
</tr>
</tbody>
</table>
<h4 id="访问元素">访问元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.back()</td>
<td>返回 c 的最后一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c.front()</td>
<td>返回 c 的第一个元素的引用，如果 c 为空，则该操作未定义</td>
</tr>
<tr>
<td>c[n]</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
<tr>
<td>c.at(n)</td>
<td>返回 c 的第 n 个元素的引用，如果 n &lt; 0 或 n &gt;= c.size()，则该操作未定义<br><strong>只适用于 vector 和 deque</strong></td>
</tr>
</tbody>
</table>
<p>back 和 front 同样可以用 end 和 begin 迭代器的解引用完成。</p>
<h4 id="删除元素">删除元素</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c.erase(p)</td>
<td>删除迭代器 p 所指元素。<br>返回被删除元素的后一个位置，或最后一个元素的下一个位置</td>
</tr>
<tr>
<td>c.erase(begin, end)</td>
<td>不越界的情况下，删除 begin 和 end 范围内的元素</td>
</tr>
<tr>
<td>c.clear()</td>
<td>删除 c 内所有元素，返回 void</td>
</tr>
<tr>
<td>c.pop_back()</td>
<td>删除最后一个元素，返回 void</td>
</tr>
<tr>
<td>c.pop_front()</td>
<td>删除第一个元素，返回 void<br><strong>只适用于 list 和 deque 类型</strong></td>
</tr>
</tbody>
</table>
<h4 id="赋值和交换">赋值和交换</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1 = c2</td>
<td>将 c2 的内容赋值给 c1。会删除 c1 的内容</td>
</tr>
<tr>
<td>c1.swap(c2)</td>
<td>交换 c1 和 c2 的内容</td>
</tr>
<tr>
<td>c.assign(begin, end)</td>
<td>重设 c，把 begin 和 end 范围内的元素赋给 c</td>
</tr>
<tr>
<td>c.assign(n, t)</td>
<td>重设 c 为 n 个值为 t 的元素</td>
</tr>
</tbody>
</table>
<p>assign 会删除原容器中的元素，然后将所指定的新元素插入到该容器中。如果两个容器类型相同，就可以使用赋值操作符将一个容器赋值给另一个容器。如果在不同容器中，元素类型不同但相互兼容，那么必须使用 assign 函数。</p>
<h3 id="vector容器的自增长">vector容器的自增长</h3><p>vector 以连续的方式存储每一个元素，一个挨着一个。所以当在超过预申请内存时再插入元素时，必须重新申请空间，然后将旧元素赋值到新空间中。此时就要用到 capacity 和 reserve，capacity 表示在必须重新非配空间之前可以存储元素的个数，一般由标准库定义，至少等于容器的大小，但一般来说会更大一些；而 reserve 表示人工预留存储空间（类似于数组大小的声明），当使用过程中超过人工预留空间后，vector会自己重新分配空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>, <span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.push_back(<span class="string">"hi"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line">svec.reserve(<span class="number">50</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; svec.capacity() &lt;&lt; endl;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br></pre></td></tr></table></figure>
<h3 id="容器的选择">容器的选择</h3><p>元素是否连续存储会显著的影响：</p>
<ol>
<li>在容器内部位置添加或删除元素；</li>
<li>执行元素的随机访问的代价；</li>
</ol>
<h4 id="插入操作影响容器的选择">插入操作影响容器的选择</h4><ol>
<li>list 存储在不连续的空间，允许向前向后逐个遍历，<strong>在任何位置可以高效的 insert 和 erase</strong>。不过它不支持随机访问，必须遍历涉及到的元素。</li>
<li>vector 存储在连续区域，除了在尾部插入（删除），其他任何位置插入（删除）时都必须移动其后面的元素。</li>
<li>deque 更加复杂，在两段插入和删除都非常快，但在内部差入或删除时代价会更高。它还同时提供了 list 和 vector 的性质：<ol>
<li>与 vector 一样，在容器内部 insert 和 erase 效率较低；</li>
<li>不同于 vector，deque 可以高效的实现首尾的 insert 和 erase；</li>
<li>deque 支持所有元素的随机访问；</li>
<li>deque 首尾插入不会使任何迭代器失效，而在首尾删除元素时，会使指向被删除元素的迭代器失效。在其他位置插入或删除都会使所有迭代器失效；</li>
</ol>
</li>
</ol>
<h4 id="访问影响">访问影响</h4><p>vector 和 deque 都支持高效的随机访问，而 list 只能顺序的跟随指针，一直遍历。</p>
<h4 id="建议">建议</h4><ol>
<li>要求随机访问，使用 vector 或 deque；</li>
<li>要求内部插入（删除）元素，选择 list；</li>
<li>如果在首部或尾部插入（删除），则选择 deque；</li>
<li>如果只需在输入时在容器中间插入元素，然后需要随机访问。可以考虑输入时存放到 list 中，接着对其排序，然后将其复制到 vector 中；</li>
<li>如果既需要中间插入元素又要随机访问，则选择容器时，考虑下面两种操作的相对代价：<ol>
<li>随机访问 list 的代价；</li>
<li>在 vector 或 deque 内部插入（删除）元素的代价；</li>
</ol>
</li>
</ol>
<h3 id="深入string类型">深入string类型</h3><p>除了前面用过的操作外，string 类型还支持大多数顺序容器操作。在某些方面可将 string 类型视为字符容器，操作也与 vector 类似，不过 string 不支持以栈方式操作容器：即 string 不能使用 front, back, pop_back等操作。下表扼要的介绍了一些 string 的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s;</td>
<td>定义一个空对象</td>
</tr>
<tr>
<td>string s(cp);</td>
<td>定义一个对象，并用 cp 指向的 c 风格的字符串初始化</td>
</tr>
<tr>
<td>string s2(s1);</td>
<td>初始化为s1的副本</td>
</tr>
<tr>
<td>is &gt;&gt; s;</td>
<td>从输入流 is 中读取一个以空白符分隔的字符串，存入 s</td>
</tr>
<tr>
<td>os &lt;&lt; s;</td>
<td>将 s 写到输出流 os</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从输入流 is 中读取一行字符，写入 s</td>
</tr>
<tr>
<td>s1 + s2</td>
<td>将 s1 和 s2 串接起来，产生一个新的 string 对象</td>
</tr>
<tr>
<td>s1 += s2</td>
<td>将 s2 拼接到 s1 后面</td>
</tr>
<tr>
<td>关系操作符</td>
<td>相等运算（== 和 !=）及关系运算（&lt;, &lt;=, &gt;, &gt;=）都可用于 string 对象的比较。等效于（区分大小写）字典次序的比较</td>
</tr>
</tbody>
</table>
<p>string 支持的容器操作有：</p>
<ol>
<li>迭代器类型；</li>
<li>容器的构造函数（参考<a href="#初始化">前面</a>），但是不包含只需一个长度参数的构造函数；</li>
<li>跟 vector 一样的添加元素的操作。无论是 vector 还是 string 都不支持 push_front；</li>
<li>支持长度操作。resize, size, reserve 等；</li>
<li>支持下标和 at 操作；</li>
<li>支持 begin 和 end 操作；</li>
<li>支持 erase 和 clear 操作。但是不支持 pop_back 或 pop_front 操作；</li>
<li>支持<a href="#赋值和交换">前面</a>表中的赋值操作；</li>
<li>与vector容器一样，string也是连续存储的，因此也支持 capacity 和 reserve 操作；</li>
</ol>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hey!"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span>::iterator iter = s.begin();</span><br><span class="line"><span class="keyword">while</span> (iter != s.end()) &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *iter++ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造_string_对象">构造 string 对象</h4><p>string 几乎支持<a href="#初始化">前面</a>所有的构造函数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">string s2(5, 'a'); // s2 == "aaaaa"</span><br><span class="line">string s3(s2); // s3 是 s2 的副本</span><br><span class="line">string s4(s3.begin(),</span><br><span class="line">		s3.begin() + s3.size() / 2); // s4 == "aa"</span><br><span class="line"></span><br><span class="line">char *cp = "hey!";</span><br><span class="line">char carr[] = "Hello!";</span><br><span class="line">char no_null[] = &#123;'H', 'i'&#125;;</span><br><span class="line">string ss1(cp); // ss1 == "hey!"</span><br><span class="line">string ss2(carr,5); // ss2 == "Hello"</span><br><span class="line">string ss3(carr + 2, 3); // ss3 == "llo"</span><br><span class="line">string ss4(no_null); // runtime_error: 没有 null 结束符</span><br><span class="line">string ss5(no_null, 2); // ok</span><br></pre></td></tr></table></figure>
<p>构造 string 对象的其他方法</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>string s(cp, n)</td>
<td>创建用 cp 所指数组的前 n 个字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos)</td>
<td>创建从 s1 的 pos 位置开始的字符的副本</td>
</tr>
<tr>
<td>string s2(s1, pos, len)</td>
<td>创建 s1 的 pos 位置开始长为 len 的字符的副本</td>
</tr>
</tbody>
</table>
<blockquote>
<p>n, len, pos 都是 unsigned 值。</p>
</blockquote>
<h4 id="修改string对象">修改string对象</h4><p><strong>与容器共有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, t)</td>
<td>在迭代器 pos 前插入一个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, n, t)</td>
<td>在迭代器 pos 前插入 n 个值为 t 的元素</td>
</tr>
<tr>
<td>s.insert(pos, begin, end)</td>
<td>在迭代器 pos 前插入迭代器 begin 到 end 之间的值</td>
</tr>
<tr>
<td>s.assign(begin, end)</td>
<td>用迭代器 begin 到 end 之间的值重新初始化 s</td>
</tr>
<tr>
<td>s.assign(n, t)</td>
<td>用 n 个 t 值重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos)</td>
<td>删除迭代器 pos 所指元素</td>
</tr>
<tr>
<td>s.erase(begin, end)</td>
<td>删除迭代器 begin 到 end 之间的值</td>
</tr>
</tbody>
</table>
<p><strong>string 特有的操作</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.insert(pos, n, c)</td>
<td>在下标 pos 前插入 n 个值为 c 的字符</td>
</tr>
<tr>
<td>s.insert(pos, s1)</td>
<td>在下标 pos 前插入一个 s1 的副本</td>
</tr>
<tr>
<td>s.insert(pos, s1, pos1, len)</td>
<td>在下标 pos 前插入 s1 中从 pos1 开始长为 len 的子字符串</td>
</tr>
<tr>
<td>s.insert(pos, cp, len)</td>
<td>在下标 pos 前插入 cp 所指的数组前 n 个字符</td>
</tr>
<tr>
<td>s.insert(pos, cp)</td>
<td>在下标 pos 前插入 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>s.assign(s1)</td>
<td>用 s1 重新初始化 s</td>
</tr>
<tr>
<td>s.assign(s1, pos1, len)</td>
<td>用 s1 中下标 pos1 开始长为 len 的子串重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp, len)</td>
<td>用 cp 所指的数组前 len 个元素重新初始化 s</td>
</tr>
<tr>
<td>s.assign(cp)</td>
<td>用 cp 所指以 null 结束的字符数组重新初始化 s</td>
</tr>
<tr>
<td>s.erase(pos, len)</td>
<td>删除从下标 pos 开始 len 个字符</td>
</tr>
</tbody>
</table>
<h3 id="只适用于_string_的操作">只适用于 string 的操作</h3><ol>
<li>substr 函数；</li>
<li>append 和 replace</li>
<li>find</li>
</ol>
<h4 id="substr">substr</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.substr(pos, n)</td>
<td>返回从 pos 开始的 n 个字符</td>
</tr>
<tr>
<td>s.substr(pos)</td>
<td>返回从位置 pos 开始到结尾的字符</td>
</tr>
<tr>
<td>s.substr()</td>
<td>返回 s 的副本</td>
</tr>
</tbody>
</table>
<h4 id="append_和_replace">append 和 replace</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.append(args)</td>
<td>将 args 拼接在 s 后。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(pos, len, args)</td>
<td>删除 pos 开始的 len 个字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
<tr>
<td>s.replace(begin, end, args)</td>
<td>删除 begin 到 end 之间的字符，用 args 替换。<strong>返回 s 的引用</strong></td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s1</td>
<td>字符串 s1</td>
</tr>
<tr>
<td>s1, pos1, len1</td>
<td>s1 子串</td>
</tr>
<tr>
<td>cp</td>
<td>cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, len1</td>
<td>cp 所指以 null 结束的字符数组前 len1 个元素</td>
</tr>
<tr>
<td>n, c</td>
<td>n 个 字符 c</td>
</tr>
<tr>
<td>begin1, end1</td>
<td>迭代器 begin1 和 end1 间的字符</td>
</tr>
</tbody>
</table>
<h4 id="find">find</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>查找 s 中 args 第一次出现</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>查找 s 中 args 最后一次出现</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>查找 s 中 args 的任意字符第一次出现</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>查找 s 中 args 的任意字符最后一次出现</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>查找 s 中第一个不属于 args 的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>查找 s 中最后一个不属于 args 的字符</td>
</tr>
</tbody>
</table>
<p><strong>上表中的args</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>c, pos</td>
<td>在 s 中从 pos 开始查找字符 c</td>
</tr>
<tr>
<td>s1, pos</td>
<td>在 s 中从 pos 开始查找 string 对象 s1</td>
</tr>
<tr>
<td>cp, pos</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组</td>
</tr>
<tr>
<td>cp, pos, n</td>
<td>在 s 中从 pos 开始查找 cp 所指以 null 结束的字符数组前 n 个字符</td>
</tr>
</tbody>
</table>
<h4 id="string_对象的比较">string 对象的比较</h4><table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.compare(s1)</td>
<td>s 与 s1比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 比较</td>
</tr>
<tr>
<td>s.compare(pos, n, s1, pos1, n1)</td>
<td>s 从 pos 开始长为 n 的子串与 s1 从 pos1 开始长为 n1 的子串比较</td>
</tr>
<tr>
<td>s.compare(cp)</td>
<td>s 与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp)</td>
<td>s 从 pos 开始长为 n 的子串与 cp 所指数组比较</td>
</tr>
<tr>
<td>s.compare(pos, n, cp, n1)</td>
<td>s  从 pos 开始长为 n 的子串与 cp 所指数组前 n1 的子串比较</td>
</tr>
</tbody>
</table>
<h3 id="容器适配器">容器适配器</h3><p>标准库提供三种顺序容器适配器：queue, priority_queue, stack。</p>
<p><strong>初始化</strong></p>
<p>肯定需要包含头文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// deq 是 deque&lt;int&gt; 类型</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk(deq);</span><br></pre></td></tr></table></figure>
<p><strong>覆盖适配器的基础容器类型</strong></p>
<p>默认情况下，stack 和 queue 都基于 deque 实现，priority_queue 则基于 vector 实现。通过将一个顺序容器指定为适配器的第二个实参，可以覆盖基础容器类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on vector</span></span><br><span class="line"><span class="built_in">stack</span>&lt; <span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; str_stk;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>两个相同类型的适配器可以做关系运算，第一个不对等的元素决定大于或小于关系。</p>
</blockquote>
<h4 id="栈适配器">栈适配器</h4><p>栈的操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stk.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>stk.size()</td>
<td>返回栈中元素个数</td>
</tr>
<tr>
<td>stk.pop()</td>
<td>删除栈顶元素，但不返回其值</td>
</tr>
<tr>
<td>stk.top()</td>
<td>返回栈顶元素，但不删除其值</td>
</tr>
<tr>
<td>stk.push(item)</td>
<td>将 item 压入栈</td>
</tr>
</tbody>
</table>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;::size_type sz = <span class="number">10</span>;</span><br><span class="line">	<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; istk;</span><br><span class="line">	<span class="keyword">int</span> ix = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.size() != sz)</span><br><span class="line">	&#123;</span><br><span class="line">		istk.push(ix++);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> error_cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (istk.empty() == <span class="literal">false</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> value = istk.top();</span><br><span class="line">		<span class="keyword">if</span> (value != --ix)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; <span class="string">"expected "</span> &lt;&lt; ix &lt;&lt; <span class="string">"recieved "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">			++error_cnt;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">		istk.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"errors: "</span> &lt;&lt; error_cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line">errors: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="queue_和_priority_queue">queue 和 priority_queue</h4><p>操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>q.empty()</td>
<td>为空，返回 true</td>
</tr>
<tr>
<td>q.size()</td>
<td>返回队列中元素个数</td>
</tr>
<tr>
<td>q.pop()</td>
<td>删除队首元素，但不返回其值</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回队首元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.back()</td>
<td>返回队尾元素，但不删除其值。<strong>只适用于queue</strong></td>
</tr>
<tr>
<td>q.top()</td>
<td>返回优先级最高的元素，但不删除其值。<strong>只适用于priority_queue</strong></td>
</tr>
<tr>
<td>q.push(item)</td>
<td>queue： 将 item 压入队尾<br>priority_queue：基于优先级压入队列</td>
</tr>
</tbody>
</table>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>前面介绍过 vector 容器类型，这里会深入探讨 vector 和其他顺序容器（sequential container）类型，还有 string 类型提供的更多操作，甚至可以将 string 看成是仅包含字符串的特殊容器。</p>
<p>标准库定义了三种顺序容器类型：vector，list 和 deque（double-ended queue，发音同 deck）。差别在于访问元素的方式，以及添加或删除元素的运行代价。标准库还提供了三种容器的适配器（adapter），适配器是根据原始的容器类型所提供的的操作，顺序容器适配器包括：stack，queue 和 priority_queue。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex9.9]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-11/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-11/</id>
    <published>2016-01-02T06:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.942Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> s[] = &#123; <span class="string">"hi"</span>, <span class="string">"hey"</span>, <span class="string">"hello"</span> &#125;;</span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist(s, s + <span class="number">3</span>); </span><br><span class="line">	<span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter = --slist.end();</span><br><span class="line">	<span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(s) / <span class="keyword">sizeof</span>(s[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (cnt &lt; sz) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; (*iter) &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (++cnt &lt; sz) &#123;</span><br><span class="line">			--iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// hey</span></span><br><span class="line"><span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_9-9">Exercise 9.9</h3><p>编写一个循环将 list 以逆序输出</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IO库]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-IO_library/"/>
    <id>http://bluestein.github.io/2016/01/cpp-IO_library/</id>
    <published>2016-01-01T07:11:49.000Z</published>
    <updated>2016-03-05T02:40:48.439Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br>ostream 写到流中去；<br>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br>ofstream 写到文件对象中去，由 ostream 派生而来；<br>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p><strong>国际字符的支持</strong></p>
<p>前面所说的流类（stream class）读写均是 char 类型组成的流，不过，标准库还定义了一套支持 wchar_t 的类型。每个类加上 <strong>w</strong> 前缀，表示宽字符，如 wostream, wistream, wiostream。</p>
<p><strong>IO 对象不可复制或赋值</strong></p>
<p>处于一些原因，标准库不允许赋值或复制操作，原因在后面阐明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2; <span class="comment">// error</span></span><br><span class="line"><span class="comment">// function func: parameter is copied</span></span><br><span class="line"><span class="function">ofstream <span class="title">func</span><span class="params">(ofstream)</span></span>;</span><br><span class="line">out2 = func(out2); <span class="comment">//error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure>
<ol>
<li>由于不能复制，因此不能存储在 vector 等容器中</li>
<li>形参或返回类型也不能为流类型。如果需要传递或返回 IO 类型，则必须使用<strong>指针或引用</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream &amp;<span class="title">func</span><span class="params">(ofstream&amp;)</span></span>; <span class="comment">// ok: takes a reference, no copy</span></span><br><span class="line"><span class="keyword">while</span> (func(out2)) &#123; <span class="comment">/*...*/</span> &#125; <span class="comment">// ok: pass reference to out2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="条件状态">条件状态</h3><p>IO 标准库管理一系列的<strong>条件状态（condition state）</strong>成员，用来标记给定的 IO 对象是否处于可用状态，或者碰到了哪种特定的错误。</p>
<table>
<thead>
<tr>
<th>IO 标准库的条件状态</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>strm::iostate</td>
<td>机器相关的整型名，由各个 iostream 类定义，用于定义条件状态</td>
</tr>
<tr>
<td>strm::badbit</td>
<td>strm::iostate类型的值，用于指出被破坏的流</td>
</tr>
<tr>
<td>strm::failbit</td>
<td>strm::iostate类型的值，用于指出失败的 IO 操作</td>
</tr>
<tr>
<td>strm::eofbit</td>
<td>strm::iostate类型的值，用于指出流已经达到文件的结束符</td>
</tr>
<tr>
<td>s.eof()</td>
<td>如果设置了流 s 的 eofbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.fail()</td>
<td>如果设置了流 s 的 failbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.bad()</td>
<td>如果设置了流 s 的 badbit 值，该函数返回true</td>
</tr>
<tr>
<td>s.good()</td>
<td>如果设置了流 s 处于有效状态，该函数返回true</td>
</tr>
<tr>
<td>s.clear()</td>
<td>将流 s 的所有状态值重设为有效状态</td>
</tr>
<tr>
<td>s.clear(flag)</td>
<td>将流 s 中某个指定的条件状态设置为有效。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.setstate(flag)</td>
<td>给流 s 添加指定条件。flag 类型为 strm::iostate</td>
</tr>
<tr>
<td>s.rdstate()</td>
<td>返回流 s 当前条件。返回值类型为 strm::iostate</td>
</tr>
</tbody>
</table>
<p>流的状态由 bad、fail、eof 或 good 操作揭示。badbit 标志着系统级的错误，如无法读写的错误。其他都设置了 failbit 标志，通常可修正。</p>
<p><strong>流状态的查询和控制</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="comment">// read cin and test only for EOF; loop is executed even if there are IO failures</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ival, !<span class="built_in">cin</span>.eof()) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">cin</span>.bad()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> runtime_error(<span class="string">"IO stream corrupted"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">cin</span>.fail()) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"bad data, try again"</span>;</span><br><span class="line">		<span class="built_in">cin</span>.clear(istream::failbit);</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>条件状态的访问</strong></p>
<p>rdstate 成员函数返回一个 iostate 类型的值，该值对应于流当前的整个条件状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">istream::iostate old_state = <span class="built_in">cin</span>.rdstate();</span><br><span class="line"><span class="built_in">cin</span>.clear();</span><br><span class="line">process_input(); <span class="comment">// use cin</span></span><br><span class="line"><span class="built_in">cin</span>.clear(old_state); <span class="comment">// reset cin to old state</span></span><br></pre></td></tr></table></figure>
<h3 id="输出缓冲区的管理">输出缓冲区的管理</h3><p>每个IO对象管理一个缓冲区，用于存储程序读写的数据。如有下面语句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; <span class="string">"Plz enter a value:"</span>;</span><br></pre></td></tr></table></figure>
<p>系统会将字符串字面值存储在与流 os 关联的缓冲区中。</p>
<p>下面情况将导致缓冲区的内容被刷新，即写入到真实的输出设备或文件中：</p>
<ol>
<li>程序正常结束。作为 main 返回工作的一部分，将清空所有输出缓冲区；</li>
<li>缓冲区已满，写入下一个值时；</li>
<li>用操纵符显示刷新缓冲区，如行结束符 endl；</li>
<li>每次输出操作完成后，用 unitbuf 操纵符设置流内部的状态，从而清空缓冲区；</li>
<li>将输出流与输入流关联起来。在读入流时将刷新其关联的输出缓冲区；</li>
</ol>
<p><strong>输出缓冲区的刷新</strong></p>
<p>除了 <code>endl</code> 之外，还有其他两个类似的操纵符： <code>flush</code>, <code>ends</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; flush; <span class="comment">// flushes the buffer, adds no data;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; ends; <span class="comment">// inserts a null, then flushes the buffer; </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi"</span> &lt;&lt; endl; <span class="comment">// inserts a newline, then flushes the buffer;</span></span><br></pre></td></tr></table></figure>
<p><strong>unitbuf</strong></p>
<p>如果需要刷新所有输出，最好使用 unitbuf 操纵符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf &lt;&lt; <span class="string">"first"</span> &lt;&lt; <span class="string">"second"</span> &lt;&lt; nounitbuf;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"first"</span> &lt;&lt; flush &lt;&lt; <span class="string">"second"</span> &lt;&lt; flush;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序崩溃了，则不刷新缓冲区。</p>
</blockquote>
<p><strong>输入与输出绑定</strong></p>
<p>将 cout 与 cin 绑定，则任何读输入流的操作都将刷新其输出流关联的缓冲区。使用 tie 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);</span><br><span class="line">ostream *old_tie = <span class="built_in">cin</span>.tie();</span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="comment">// 终止绑定</span></span><br><span class="line"><span class="built_in">cin</span>.tie(&amp;<span class="built_in">cerr</span>); <span class="comment">// cin 与 cerr 绑定，但不推荐</span></span><br><span class="line"><span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">cin</span>.tie(old_tie); <span class="comment">// cin 与 cout 重新绑定</span></span><br></pre></td></tr></table></figure>
<h3 id="文件的输入输出">文件的输入输出</h3><h4 id="文件流对象的使用">文件流对象的使用</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// construct an ifstream and bind it to the file named ifile </span><br><span class="line">ifstream infile(ifile.c_str());</span><br><span class="line">// ofstream output file object to write file named ofile</span><br><span class="line">ofstream outfile(ofile.c_str());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>open需要使用C风格字符串</p>
</blockquote>
<p>或者</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ifstream infile; <span class="comment">// input file stream</span></span><br><span class="line">ofstream outfile; <span class="comment">// output file stream</span></span><br><span class="line">infile.open(<span class="string">"in"</span>); <span class="comment">// open file named "in" in current directory</span></span><br><span class="line">outfile.open(<span class="string">"out"</span>); <span class="comment">// open file named "out" in current directory</span></span><br></pre></td></tr></table></figure>
<p><strong>检查文件打开是否成功</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!infile) &#123;</span><br><span class="line">	<span class="built_in">cerr</span> &lt;&lt; <span class="string">"error: unable to open input file:"</span> &lt;&lt; ifle &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与其他文件绑定</strong></p>
<p>如果把现有 fstream 对象与另一个不同的文件关联，则必须先关闭现有文件，然后打开另一个文件</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">"in"</span>)</span></span>;</span><br><span class="line">infile.close();</span><br><span class="line">infile.open(<span class="string">"next"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>清楚文件流的状态</strong></p>
<p>使用 clear() 函数即可。比如有一个vector对象，存放了一些要打开的文件名，程序要对这些文件处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ifstream input;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line"><span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">	input.open(it-&gt;c_str());</span><br><span class="line">	<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">		process(s);</span><br><span class="line">	input.close();</span><br><span class="line">	input.clear();</span><br><span class="line">	++it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果忽略 <code>input.clear()</code> 则循环只能读入一个文件，因为读取文件到达文件的结束或出错时，input 的状态都是 failbit，此时任何尝试读取 input 都会失败。</p>
<h4 id="文件模式">文件模式</h4><table>
<thead>
<tr>
<th>文件模式</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td>打开文件作读操作</td>
</tr>
<tr>
<td>out</td>
<td>打开文件作写操作</td>
</tr>
<tr>
<td>app</td>
<td>每次写之前找到文件尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件尾</td>
</tr>
<tr>
<td>trunc</td>
<td>打开文件时，清空已存在的文件流</td>
</tr>
<tr>
<td>binary</td>
<td>以二进制模式进行IO操作</td>
</tr>
</tbody>
</table>
<ul>
<li>out, trunc, app 模式只能用于指定与 ofstream 或 fstream 对象关联的文件；</li>
<li>in 模式只能用于指定与 ifstream 或 fstream 对象关联的文件；</li>
<li>ate, binary 模式可用于所有文件；</li>
</ul>
<p>默认时，与 ifstream 流对象关联的文件以 in 模式打开；与 ofstream 流对象关联的文件以 out 模式打开；<strong>以out模式打开文件原内容会被清空</strong>，若要保留，则以 app 模式打开：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 会清空file1</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">"file1"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 等价上面，显式清空</span></span><br><span class="line"><span class="function">ofstream <span class="title">outfile2</span><span class="params">(<span class="string">"file1"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 在末尾添加内容</span></span><br><span class="line"><span class="function">ofstream <span class="title">appfile</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>默认情况下，fstream 以 in 和 out 模式同时打开。此时，文件不会被清空。</li>
<li>如果打开 fstream 所关联的文件，只使用 out 模式，而不指定 in 模式，则会被清空。</li>
<li>如果指定了 trunc 模式，则无论如何都会被清空；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open for input and output</span></span><br><span class="line"><span class="function">fstream <span class="title">inOut</span><span class="params">(<span class="string">"copyOut"</span>, fstream::in | fstream::out)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>有效的文件模式组合</strong></p>
<table>
<thead>
<tr>
<th>模式组合</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>out</td>
<td>打开文件做写，清空已有数据</td>
</tr>
<tr>
<td>out &#124; app</td>
<td>打开文件做写，文件尾写入</td>
</tr>
<tr>
<td>out &#124; trunc</td>
<td>同out模式</td>
</tr>
<tr>
<td>in</td>
<td>打开文件做读</td>
</tr>
<tr>
<td>in &#124; out</td>
<td>打开文件做读、写，定位在文件开头</td>
</tr>
<tr>
<td>in &#124; out &#124; trunc</td>
<td>打开文件做读、写，清空已有数据</td>
</tr>
</tbody>
</table>
<p>举例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream&amp; <span class="title">open_file</span><span class="params">(ifstream &amp;in, <span class="keyword">const</span> <span class="built_in">string</span> &amp;file)</span> </span>&#123;</span><br><span class="line">	in.close();</span><br><span class="line">	in.clear();</span><br><span class="line">	in.open(file.c_str());</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于不清楚流 in 的状态，则先调用 close 和 clear 设置为有效状态。然后尝试打开文件，最后返回流 in 对象。此时，in 要么与文件绑定，要么处于错误状态。</p>
<h3 id="字符串流">字符串流</h3><p>标准库定义了三个类型的字符串流：</p>
<ul>
<li>istringstream，由 istream 派生而来，提供读 string 的功能。</li>
<li>ostringstream，由 ostream 派生而来，提供写 string 的功能。</li>
<li>stringstream，由 iostream 派生而来，提供读写 string 的功能</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stringstream</span> strm; <span class="comment">// 创建 stringstream 对象</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">//存储 s 的副本 stringstream 对象，其中 s 是 string 类型的对象</span></span><br><span class="line">strm.str(); <span class="comment">// 返回 strm 中存储的 string 对象</span></span><br><span class="line">strm.str(s); <span class="comment">// 将 string 对象 s 复制给 strm，返回 void</span></span><br></pre></td></tr></table></figure>
<p><strong>操纵每行中的每个单词</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, line)) <span class="comment">// 读取一行到 line 中</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="built_in">istringstream</span> <span class="title">stream</span><span class="params">(line)</span></span>; <span class="comment">// bind strem to the line</span></span><br><span class="line">	<span class="keyword">while</span> (stream &gt;&gt; word) <span class="comment">// 从 line 读取一个单词</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; word &lt;&lt; endl; <span class="comment">// 可以操纵这句话中的每个单词，这里是输出它</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>stringstream提供转换的格式化</strong></p>
<p>把一些数据转换成它们的 string 表示形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v1 = <span class="number">512</span>, v2 = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">ostringstream</span> format_msg;</span><br><span class="line">format_msg &lt;&lt; <span class="string">"v1: "</span> &lt;&lt; v1 &lt;&lt; <span class="string">", v2: "</span> &lt;&lt; v2 ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; format_msg.str();</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// v1: 512, v2: 1024</span></span><br></pre></td></tr></table></figure>
<p>或者反过来</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int v1 = 512, v2 = 1024;</span><br><span class="line">ostringstream format_msg;</span><br><span class="line">format_msg &lt;&lt; "v1: " &lt;&lt; v1 &lt;&lt; ", v2: " &lt;&lt; v2 &lt;&lt; "\n";</span><br><span class="line">cout &lt;&lt; format_msg.str();</span><br><span class="line">istringstream istring(format_msg.str());</span><br><span class="line">string dump;</span><br><span class="line">int new_v1, new_v2;</span><br><span class="line">istring &gt;&gt; dump &gt;&gt; new_v1 &gt;&gt; dump &gt;&gt; dump &gt;&gt; new_v2;</span><br><span class="line">cout &lt;&lt; new_v1 &lt;&lt; " " &lt;&lt; new_v2 &lt;&lt; " " &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; dump &lt;&lt; endl;</span><br><span class="line">// prints:</span><br><span class="line">// v1: 512, v2: 1024</span><br><span class="line">// 512 1024</span><br><span class="line">// v2:</span><br></pre></td></tr></table></figure>
<p>可以发现 istringstream 可以将 string 对象按原来的位置恢复到对应的变量位置。上面程序中 <code>dump</code> 在此过程中相当于一个临时变量，在不断的变化。从输出来看，最后一次 <code>dump</code> 的值为 <code>v2:</code>，前面两次的值依次是：<code>v1:</code>, <code>,</code>（string类型，不带空格）。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="标准库">标准库</h3><p>IO类型在三个独立的头文件中定义：iostream，fstream，sstream</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>iostream</td>
<td>istream 从流中读取；<br/>ostream 写到流中去；<br/>iostream 对流进行读写，由 iostream 和 ostream 派生而来；</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream 从文件对象中读取，由 istream 派生而来；<br/>ofstream 写到文件对象中去，由 ostream 派生而来；<br/>fstream 对文件进行读写，由 iostream 派生而来；</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream 从 string 对象中读取，由 istream 派生而来；<br/>ostringstream 写到 string 对象中去，由 ostream 派生而来；<br/>stringstream 对 string 进行读写，由 iostream 派生而来；</td>
</tr>
</tbody>
</table>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex8.3, 8.7, 8.8]]></title>
    <link href="http://bluestein.github.io/2016/01/cpp-demo-10/"/>
    <id>http://bluestein.github.io/2016/01/cpp-demo-10/</id>
    <published>2016-01-01T06:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.945Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>
<a id="more"></a>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">input</span><span class="params">(istream &amp;in)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">while</span> (in &gt;&gt; val, !in.eof())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	in.clear();</span><br><span class="line">	<span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use cin for test</span></span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 1↙</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2↙</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ^Z↙</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-7">Exercise 8.7</h3><p>vector 容器中存放了将要处理的文件名，当打开失败时，输出警告信息，然后取下一个文件处理。假设当前文件夹下有一个名为 <code>test.txt</code> 的文件，内容是：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test!</span><br></pre></td></tr></table></figure>
<p>则程序及运行测试如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">			++it;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">		<span class="keyword">char</span> s;</span><br><span class="line">		<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">		input.close();</span><br><span class="line">		input.clear();</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br><span class="line"><span class="comment">// willfail.txt: failed to open</span></span><br><span class="line"><span class="comment">// test.txt: test!</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_8-8">Exercise 8.8</h3><p>不用 continue 实现 ex8.7</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	ifstream input;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"willfail.txt"</span>);</span><br><span class="line">	files.push_back(<span class="string">"test.txt"</span>);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator it = files.begin();</span><br><span class="line">	<span class="keyword">while</span> (it != files.end()) &#123;</span><br><span class="line">		input.open(it-&gt;c_str());</span><br><span class="line">		<span class="keyword">if</span> (!input) &#123;</span><br><span class="line">			<span class="built_in">cerr</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": failed to open."</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; it-&gt;c_str() &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">			<span class="keyword">char</span> s;</span><br><span class="line">			<span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">				<span class="built_in">cout</span> &lt;&lt; s;</span><br><span class="line">			<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">			input.close();</span><br><span class="line">			input.clear();</span><br><span class="line">		&#125;</span><br><span class="line">		++it;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_8-3">Exercise 8.3</h3><p>编写一个程序，一个形参和返回值都是 <code>istream&amp;</code> 类型。该函数一直读取直到结束符为止，并且将读取到的内容输出到标准输出中，最后重设流使其有效，并返回该流。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp Code" scheme="http://bluestein.github.io/tags/Cpp-Code/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[函数的声明]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-function_declaration/"/>
    <id>http://bluestein.github.io/2015/12/cpp-function_declaration/</id>
    <published>2015-12-31T07:11:49.000Z</published>
    <updated>2016-03-05T02:40:47.072Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>跟变量一样，函数也需要先声明再使用。同样的，函数的定义和函数的声明也可以分离：一个函数只能定义一次，但可以声明多次。</p>
<p>函数声明必须包含：<strong>返回类型、函数名和形参列表</strong>。形参列表必须包含形参类型，但没强调要包含形参名。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="默认实参">默认实参</h3><p>调用函数时，可以省略有默认值的实参。如果一个参数有默认值，那么它后面的实参都必须有默认值。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screenInit</span><span class="params">(<span class="built_in">string</span>::size_type height = <span class="number">24</span>,</span><br><span class="line">				<span class="built_in">string</span>::size_type width = <span class="number">80</span>,</span><br><span class="line">				<span class="keyword">char</span> background = <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="comment">// 下面调用均正确</span></span><br><span class="line"><span class="built_in">string</span> screen;</span><br><span class="line">screen = screenInit();</span><br><span class="line">screen = screenInit(<span class="number">66</span>);</span><br><span class="line">screen = screenInit(<span class="number">66</span>, <span class="number">256</span>);</span><br><span class="line">screen = screenInit(<span class="number">66</span>, <span class="number">256</span>, <span class="string">'#'</span>);</span><br></pre></td></tr></table></figure>
<p>设置默认形参时，最少使用的默认值放在最前，最多使用的放在最后。</p>
<blockquote>
<p>函数在声明时可以指定默认实参，但是在一个文件中，只能为形参指定一次默认参数。所以可以将声明放在头文件中。</p>
</blockquote>
<h3 id="静态局部对象">静态局部对象</h3><p>上面的形参都会在定义它们的快语句结束时被撤销，如果需要跨越多个作用域，定义为 <strong>static</strong>，它能保证在程序结束前不被撤销：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> count() &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ++cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i!= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; count() &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="内联函数">内联函数</h3><p>一般的函数调用要比求解表达式慢得多，<strong>内联函数可以避免函数调用的开销</strong>。使用 <strong>inline</strong> 关键字定义，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &gt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则在调用 <code>cout &lt;&lt; shorterString(s1, s2) &lt;&lt; endl;</code> 时， 编译时展开为 <code>cout &lt;&lt; (s1.size() &gt; s2.size() ? s1 : s2) &lt;&lt; endl;</code>。</p>
<p>内联机制适用于优化小的、几行的且经常调用的函数。</p>
<h3 id="类的成员函数">类的成员函数</h3><p>和任何函数一样，包含下面四个部分：</p>
<ol>
<li>返回类型</li>
<li>函数名</li>
<li>逗号分隔的形参列表（可为空）</li>
<li>花括号内的函数体</li>
</ol>
<p>1,2,3 组成的是函数原型，<strong>函数的原型必须在类中定义</strong>，函数体则可以在类外。假设 Sales_item 类有两个成员函数 avgPrice() 和 sameIsbn(const Sales_item &amp;):</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">avgPrice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现形参的后面有 <code>const</code>，在解释之前，说明成员函数如何定义：</p>
<h4 id="成员函数的函数体">成员函数的函数体</h4><p>类的所有成员必须在<strong>定义类的花括号中声明</strong>，并且<strong>编译器隐式地将类内定义的成员函数当作是内联函数</strong>。</p>
<blockquote>
<p>类的成员函数可以访问 private 成员，如 isbn。</p>
</blockquote>
<p><strong>this 指针的引入</strong></p>
<p>每个成员函数都有一个额外的、隐式的形参 <strong>this</strong>，在调用成员函数时，形参 this 初始化为调用函数的对象的地址。可以这样理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.sameIsbn(otherItem);</span><br></pre></td></tr></table></figure>
<p>编译器会重写这个函数调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_item::sameIsbn(&amp;item, otherItem);</span><br></pre></td></tr></table></figure>
<p><strong>const 成员函数的引入</strong></p>
<p>也就是上面提到的形参后面 <strong>const</strong>，<strong>它改变了隐式形参 this 的类型</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item *<span class="keyword">const</span> <span class="keyword">this</span>,</span><br><span class="line">			<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>-&gt;isbn == rhs.isbn);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这种使用 const 的函数称为<strong>常量成员函数</strong>（const member function）。由于 this 指向 const 对象，const 成员函数不能修改调用该函数的对象。</p>
<h4 id="类外定义成员函数">类外定义成员函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Sales_item::avgPrice() <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (units_sold)&#123;</span><br><span class="line">		<span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用了域操作符 <code>::</code> 及类名 <code>Sales_item</code>。</p>
<h4 id="Sale_item_的构造函数">Sale_item 的构造函数</h4><p>构造函数是特殊的成员函数，<strong>构造函数名与类名相同，而且无返回类型</strong>。可以有多个构造函数，相互之间的具有不同数目或类型的形参。</p>
<p>跟普通成员函数一样，必须在类内声明，类内或类外定义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Sales_item &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">avgPrice</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">sameIsbn</span><span class="params">(<span class="keyword">const</span> Sales_item &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> isbn == rhs.isbn;</span><br><span class="line">	&#125;</span><br><span class="line">	Sales_item(): units_sold(<span class="number">0</span>), revenue(<span class="number">0.0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> isbn;</span><br><span class="line">	<span class="keyword">unsigned</span> units_sold;</span><br><span class="line">	<span class="keyword">double</span> revenue;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>构造函数的初始化列表</strong></p>
<p><strong>在冒号与花括号之间的代码称为构造函数的初始化列表</strong>，即 <code>units_sold(0), revenue(0.0)</code> 为成员指定初值，括号内是初值。<strong>构造函数的形参表为空说明此为默认调用的</strong></p>
<p><strong>类代码的组织</strong></p>
<p>通常将类的声明放置在头文件中，在类外定义的成员函数则置于源文件中。</p>
<h3 id="重载函数">重载函数</h3><p>在相同作用域中，出现相同名字而形参表不同的函数，称为重载函数。如电话本的查找：基于姓名、基于号码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Name&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>重载与重复声明的区别</strong></p>
<p>如果两个函数声明的返回类型和参数表完全匹配，叫重复声明；<strong>如果形参表完全相同，返回类型不同，则第二个错误</strong>。</p>
<p>在函数中局部声明的名字会屏蔽全局名，即使是变量名对函数名也同样成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> init = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">string</span> s = init(); <span class="comment">// error: global init is hidden</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指向函数的指针">指向函数的指针</h3><p>函数指针是指指向函数而非对象的指针，像其他指针一样，函数指针指向的是函数类型，<strong>函数类型由其返回类型和形参表确定，与函数名无关</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>
<h4 id="用typedef简化定义">用typedef简化定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*cmpFcn)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则 <code>cmpFcn</code> 表示<strong>指向返回类型为 bool 类型并带有两个 const string 引用形参的函数的指针</strong>。若要定义此类型的函数指针，则直接使用 <code>cmpFcn</code> 即可。</p>
<h4 id="初始化和赋值">初始化和赋值</h4><p>在引用函数名又没调用该函数，函数名将被自动解释为指向函数的指针。假设有函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCpmpare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>会被解释为如下类型的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure>
<p>可以做如下初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = <span class="number">0</span>;				<span class="comment">// ok：不指向任何函数</span></span><br><span class="line">cmpFcn pf2 = lengthCompare;	<span class="comment">// ok：指向类型匹配的函数</span></span><br><span class="line">pf1 = lengthCompare;		<span class="comment">// ok：同上</span></span><br><span class="line">pf2 = pf1;					<span class="comment">// ok：同上</span></span><br></pre></td></tr></table></figure>
<p>此时，直接饮用函数名等效于在函数名上应用取地址操作符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf1 = lengthCompare;</span><br><span class="line">cmpFcn pf2 = &amp;lengthCompare;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数指针只能通过同类型的函数或函数指针或 0 值常量表达式进行初始化或赋值</p>
</blockquote>
<h4 id="通过指针调用函数">通过指针调用函数</h4><p>不需要解引用操作符，直接通过指针调用函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmpFcn pf = lengthcompare;</span><br><span class="line">lengthCompare(<span class="string">"hi"</span>, <span class="string">"bye"</span>);	<span class="comment">// 直接调用</span></span><br><span class="line">pf(<span class="string">"hi"</span>, <span class="string">"bye"</span>);			<span class="comment">// 等价调用：pf隐式解引用</span></span><br><span class="line">(*pf)(<span class="string">"hi"</span>, <span class="string">"bye"</span>);			<span class="comment">// 等价调用：pf显式解引用</span></span><br></pre></td></tr></table></figure>
<h4 id="函数指针形参">函数指针形参</h4><p>函数的形参可以是指向函数的指针，这种形参可以用以下两种形式编写：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void useBigger(const string &amp;, const string &amp;,</span><br><span class="line">			bool (const string &amp;, const string &amp;));</span><br><span class="line">void useBigger(const string &amp;, const string &amp;,</span><br><span class="line">			bool (*)(const string &amp;, const string &amp;));</span><br></pre></td></tr></table></figure>
<h4 id="返回指向函数的指针">返回指向函数的指针</h4><p>函数可以返回指向函数的指针，但是，这并不简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ff is a function taking an int and returing a function pointer</span></span><br><span class="line"><span class="comment">// the function pointed to returns an int and takes an int* and an int</span></span><br><span class="line"><span class="keyword">int</span> (*ff(<span class="keyword">int</span>)) (<span class="keyword">int</span>*, <span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>
<p>这样理解： <code>ff(int)</code> 表明 ff 为一个函数，它带有一个 int 型形参，该参数返回 <code>int (*)(int*, int)</code>，它是指向一个函数的指针。用 typedef 可以更加明白：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PF is a pointer to a function returing an int, taking an int* and an int</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*PF)</span><span class="params">(<span class="keyword">int</span>*, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">PF <span class="title">ff</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>跟变量一样，函数也需要先声明再使用。同样的，函数的定义和函数的声明也可以分离：一个函数只能定义一次，但可以声明多次。</p>
<p>函数声明必须包含：<strong>返回类型、函数名和形参列表</strong>。形参列表必须包含形参类型，但没强调要包含形参名。比如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="built_in">string</span>)</span></span>;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[return]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-return/"/>
    <id>http://bluestein.github.io/2015/12/cpp-return/</id>
    <published>2015-12-30T06:11:49.000Z</published>
    <updated>2016-03-05T02:37:36.898Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="没有返回值的函数">没有返回值的函数</h3><p>不带返回值的return语句用于 void 类型的函数。在 void 类型的函数中，return 语句不是必须的，它会在函数的最后一个语句隐式的完成。</p>
<p><strong>隐式的return</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">	<span class="comment">// 隐式的return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>return</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v1 == v2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">// 不带返回值的return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tmp = v2;</span><br><span class="line">	v2 = v1;</span><br><span class="line">	v1 = tmp;</span><br><span class="line">	<span class="comment">// 隐式的return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有返回值的函数">有返回值的函数</h3><p>使用第二种形式，即 <code>return expression;</code> 返回值给非 void 函数。</p>
<h4 id="主函数_main_的返回值">主函数 main 的返回值</h4><p>可将 main 函数的返回值作为状态指示器，0 表示运行成功，其他返回值则因机器的不同而不同，因此 cstdlib 头文件定义了两个预定于变量 <code>EXIT_FAILURE</code> <code>EXIT_SUCCESS</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;sctdlib&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (some_failure)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回非引用类型">返回非引用类型</h4><p>此时可以返回局部对象，或表达式的结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">makePlural</span><span class="params">(size_t ctr, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="keyword">const</span> <span class="built_in">string</span> &amp;ending)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ctr == <span class="number">1</span>) ? word : word + ending;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="返回引用">返回引用</h4><p>返回的是对象本身</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &gt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不能返回局部变量的引用">不能返回局部变量的引用</h4><p>因为程序执行完毕时，将释放该对象的存储空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">mainp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> ret = s;</span><br><span class="line">	<span class="keyword">return</span> ret; <span class="comment">// wrong: local object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样不要返回局部变量的指针</p>
</blockquote>
<h4 id="引用返回左值">引用返回左值</h4><p>可以使用在要求使用左值的地方</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> &amp;<span class="title">getVal</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="built_in">string</span>::size_type ix)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"a string"</span>)</span></span>;</span><br><span class="line">	getVal(s, <span class="number">0</span>) = <span class="string">'A'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// prints: </span></span><br><span class="line"><span class="comment">// A string</span></span><br></pre></td></tr></table></figure>
<p>如果不想引用返回值被修改，则返回值应声明为const： <code>const char &amp;getVal(...</code>。</p>
<h3 id="递归">递归</h3><p>间接或直接调用子集的函数称为递归函数（recursion function）。例如阶乘运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> val)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (val &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> fact(val - <span class="number">1</span>) * val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或最大公约数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rgcd</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v2 != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> rgcd(v2, v1 % v2);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>fact</code> 与 <code>rgcd</code> 它们的终止条件分别是： <code>val = 1</code>; 余数等于零。</p>
<p>END.</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<p>return 语句用于结束当前正在执行的函数，并将控制权返回给调用此函数的函数。有两种形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[参数传递]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-parameter_passing/"/>
    <id>http://bluestein.github.io/2015/12/cpp-parameter_passing/</id>
    <published>2015-12-29T12:49:49.000Z</published>
    <updated>2016-03-05T02:40:48.998Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="引用型形参">引用型形参</h3><p>利用引用形参，交换两个数的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<blockquote>
<p>利用引用型的形参，可以解决函数只能返回一个值得情况</p>
</blockquote>
<p>比如，在某个vector中寻找某个特定的值，然后返回它出现的位置及出现的次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::<span class="function">const_iterator <span class="title">findValue</span><span class="params">(</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator begin,</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end,</span><br><span class="line">	<span class="keyword">int</span> value,</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type &amp;occurs)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator result_iter = end;</span><br><span class="line">	occurs = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; begin != end; ++begin)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*begin == value)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// remember first occurrence of value</span></span><br><span class="line">			<span class="keyword">if</span> (result_iter == end)</span><br><span class="line">			&#123;</span><br><span class="line">				result_iter = begin;</span><br><span class="line">			&#125;</span><br><span class="line">			++occurs;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用const引用避免复制">利用const引用避免复制</h3><p>一般的形参传递时需要复制，引用不需要。当使用大型引用形参时，为了避免复制实参，使用const引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>形参是引用，所以不需要复制实参；形参是const，所以不能通过该引用形参来修改实参的值。</p>
<h3 id="传递指针的引用">传递指针的引用</h3><p>交换指向数值的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prSwap</span><span class="params">(<span class="keyword">int</span> *&amp;v1, <span class="keyword">int</span> *&amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector或其他容器作为形参">vector或其他容器作为形参</h3><p>为避免直接使用vector等类型做形参，一般使用它们的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator begin,</span><br><span class="line">			<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(begin != end)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *begin++;</span><br><span class="line">		<span class="keyword">if</span> (begin != end) <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组作为形参">数组作为形参</h3><p>肯定不能直接传递数组，通常使用指针进行操作。而下面三种是等价的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[<span class="number">10</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是后两种很容易引起误解。下面可以看出是否真的等价</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[<span class="number">10</span>])</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v1 = <span class="number">32</span>, arr[<span class="number">2</span>] = &#123;<span class="number">4</span>, <span class="number">0</span>&#125;;</span><br><span class="line">printv(&amp;v1); <span class="comment">//编译ok, 但会输出其他9个其他的值或者运行时错误</span></span><br><span class="line">printv(arr); <span class="comment">//编译ok, 但会输出其他8个其他的值或者运行时错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译器不会检查形参数组的大小。</p>
</blockquote>
<h3 id="通过引用传递数组">通过引用传递数组</h3><p>一般来讲，将数组作为形参传递给函数都会被转换为指针，但是数组的引用不会。此时，传递的是数组的引用本身，编译器会检查形参数组的大小。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void print(int (&amp;arr)[3]);</span><br><span class="line">int i = 0, j[2] = &#123;0, 1&#125;;</span><br><span class="line">int k[3] = &#123;0, 1, 2&#125;;</span><br><span class="line">print(&amp;i); // error</span><br><span class="line">print(j); // error</span><br><span class="line">print(k); // ok</span><br></pre></td></tr></table></figure>
<h3 id="多维数组的传递">多维数组的传递</h3><p>所谓多维数组，就是数组的数组。它的每个元素就是一个数组，第二维必须指定</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void print(int (matrix*)[10], int row_size);</span><br><span class="line">// 或者</span><br><span class="line">void print(int matrix[][10], int row_size);</span><br></pre></td></tr></table></figure>
<p><code>matrix</code> 是指向含10个int值的数组的指针。</p>
<h3 id="在函数内处理数组">在函数内处理数组</h3><p>任何数组的操作都必须保持在数组的边界内。</p>
<p>有三种常见的方法可以保证这一点：</p>
<ol>
<li>第一种是在数组的本身放置一个标记进行检测数组的结束。如C风格的字符串，使用 <code>\0</code> 标记表示结束；</li>
<li>第二种是传递指向数组的第一个和最后一个元素的下一个位置的指针；</li>
<li>显式地传递数组的大小。意思是告诉函数，我的大小是多少；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> ia[], size_t size)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="引用型形参">引用型形参</h3><p>利用引用形参，交换两个数的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Cpp primer" scheme="http://bluestein.github.io/tags/Cpp-primer/"/>
    
      <category term="Dev" scheme="http://bluestein.github.io/categories/Dev/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Dev/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex7.3 - 7.6]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-9/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-9/</id>
    <published>2015-12-25T11:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.948Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_7-3">Exercise 7.3</h3><p>产生第一个参数的第二个参数次幂的值</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base, <span class="keyword">int</span> power)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>, result = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt; power) </span><br><span class="line">	&#123;</span><br><span class="line">		result *= base;</span><br><span class="line">		++i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_7-4">Exercise 7.4</h3><p>返回一个数的绝对值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">abs</span><span class="params">(<span class="keyword">int</span> v)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (v &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> -v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_7-5">Exercise 7.5</h3><p>两个形参，一个int型，另一个int型指针，返回值较大的数值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">biggerOne</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">const</span> <span class="keyword">int</span> *ip)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> biggerOne = v &gt; *ip ? v : *ip;</span><br><span class="line">	ip = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> biggerOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_7-6">Exercise 7.6</h3><p>交换两个int指针所指对象的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pSwap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = *p1;</span><br><span class="line">	*p1 = *p2;</span><br><span class="line">	*p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bonus">Bonus</h3><p>利用引用交换两个数的值（跟ex 7.6一样的效果）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rSwap</span><span class="params">(<span class="keyword">int</span> &amp;v1, <span class="keyword">int</span> &amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>利用引用型的形参，可以解决函数只能返回一个值得情况</p>
</blockquote>
<h3 id="Bonus-1">Bonus</h3><p>交换指向数值的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prSwap</span><span class="params">(<span class="keyword">int</span> *&amp;v1, <span class="keyword">int</span> *&amp;v2)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *temp = v1;</span><br><span class="line">	v1 = v2;</span><br><span class="line">	v2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_7-3">Exercise 7.3</h3><p>产生第一个参数的第二个参数次幂的值</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex6.18, 6.20, 6.21]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-8/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-8/</id>
    <published>2015-12-24T12:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.952Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_6-18">Exercise 6.18</h3><p>输入两个string对象，比较哪个按字典序靠前。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dictOrder</span><span class="params">(<span class="built_in">string</span> a, <span class="built_in">string</span> b)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp1 = a.c_str();</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp2 = b.c_str();</span><br><span class="line">	<span class="keyword">while</span> (*cp1 &amp;&amp; *cp2)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (*cp1 != *cp2)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> *cp1 &gt; *cp2 ? <span class="string">"First bigger"</span> : <span class="string">"First smaller"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cp1++;</span><br><span class="line">		cp2++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"Same"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str1, str2;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input two strings.\nIf you want to quit, input two 'q'."</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"\nTwo strings:\n"</span>;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt; dictOrder(str1, str2) &lt;&lt; endl;</span><br><span class="line">	&#125; <span class="keyword">while</span> (str1 != <span class="string">"q"</span> &amp;&amp; str2 != <span class="string">"q"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Please input two strings.</span><br><span class="line">If you want to quit, input two <span class="string">'q'</span>.</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">ab↙</span><br><span class="line">ac↙</span><br><span class="line">First smaller</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">b↙</span><br><span class="line">a↙</span><br><span class="line">First bigger</span><br><span class="line"></span><br><span class="line">Two strings:</span><br><span class="line">q↙</span><br><span class="line">q↙</span><br><span class="line">Same</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-20">Exercise 6.20</h3><p>读入一系列string，直到出现重复的单词时停止，或者没有重复时请说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ( !found &amp;&amp; <span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str == v[i]) </span><br><span class="line">			&#123;</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		v.push_back(str);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (found ? <span class="string">"Repeat found"</span> : <span class="string">"No repeated"</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1</span></span><br><span class="line">hi↙</span><br><span class="line">hey↙</span><br><span class="line">hello↙</span><br><span class="line">hi↙</span><br><span class="line">Repeat found</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line">hi↙</span><br><span class="line">hey↙</span><br><span class="line">hello↙</span><br><span class="line">^Z↙</span><br><span class="line">No repeated</span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-21">Exercise 6.21</h3><p>读入一系列string，直到出现重复的以大写字母开头的单词时停止，或者没有重复时请说明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isUpper</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> ( !found &amp;&amp; <span class="built_in">cin</span> &gt;&gt; str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str == v[i]) </span><br><span class="line">			&#123;</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isUpper(str[<span class="number">0</span>]))</span><br><span class="line">		&#123;</span><br><span class="line">			v.push_back(str);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; (found ? <span class="string">"Repeat found"</span> : <span class="string">"No repeated"</span>) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test1</span></span><br><span class="line">hi↙</span><br><span class="line">hI↙</span><br><span class="line">Hi↙</span><br><span class="line">HI↙</span><br><span class="line">Hi↙</span><br><span class="line">Repeat found</span><br><span class="line"></span><br><span class="line"><span class="comment">// test2</span></span><br><span class="line">hi↙</span><br><span class="line">hI↙</span><br><span class="line">Hi↙</span><br><span class="line">HI↙</span><br><span class="line">^Z↙</span><br><span class="line">No repeated</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_6-18">Exercise 6.18</h3><p>输入两个string对象，比较哪个按字典序靠前。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ex6.16]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-7/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-7/</id>
    <published>2015-12-22T12:03:42.000Z</published>
    <updated>2016-03-05T02:39:55.955Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_6-16">Exercise 6.16</h3><p>比较两个int型vector对象，判断一个是否是另一个的前缀。<br>即，假设有{ 0, 1, 1, 2 } 和 { 0, 1, 1, 2, 3, 5, 8 }则应返回true。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrefix</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sz1 = a.size(), sz2 = b.size();</span><br><span class="line">	<span class="keyword">int</span> sz = sz1 &gt; sz2 ? sz2 : sz1;</span><br><span class="line">	<span class="keyword">int</span> matched = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] == b[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			++matched;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sz == matched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr1[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> arr2[<span class="number">7</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> sz1 = <span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line">	<span class="keyword">int</span> sz2 = <span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(*arr2);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1(arr1, arr1 + sz1);</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2(arr2, arr2 + sz2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; isPrefix(vec1, vec2) &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Exercise_6-16">Exercise 6.16</h3><p>比较两个int型vector对象，判断一个是否是另一个的前缀。<br>即，假设有{ 0, 1, 1, 2 } 和 { 0, 1, 1, 2, 3, 5, 8 }则应返回true。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[while, ex6.12]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-6/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-6/</id>
    <published>2015-12-22T07:03:42.000Z</published>
    <updated>2016-03-05T02:41:46.787Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Example">Example</h3><p>将一个数组拷贝到另一个数组</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> *source = arr;</span><br><span class="line">	<span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">	<span class="keyword">int</span> *dest = <span class="keyword">new</span> <span class="keyword">int</span>[sz];</span><br><span class="line">	<span class="keyword">while</span> (source != arr + sz) </span><br><span class="line">	&#123;</span><br><span class="line">		*dest++ = *source++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// test</span></span><br><span class="line">	<span class="keyword">int</span> *dp = dest - sz;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sz; ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; *dp &lt;&lt; endl;</span><br><span class="line">		dp++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-12">Exercise 6.12</h3><p>输入一些单词，统计里面单词出现的次数。</p>
<p>如：how, now now now brown cow cow<br>则需输出: how 1次，now 3次，brown 1次，cow 2次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCharacter</span><span class="params">(<span class="keyword">char</span> ch)</span> </span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) || (ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// 把单词存入vector，并忽略非字母</span></span><br><span class="line">	<span class="built_in">string</span> str;</span><br><span class="line">	getline(<span class="built_in">cin</span>, str);</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *cp = str.c_str();</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; raw;</span><br><span class="line">	<span class="built_in">string</span> tmp = <span class="string">""</span>;</span><br><span class="line">	<span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">		<span class="keyword">if</span> (isCharacter(*cp)) </span><br><span class="line">		&#123;</span><br><span class="line">			tmp += *cp++;</span><br><span class="line">			<span class="keyword">if</span> (*cp != <span class="string">'\0'</span>) </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!tmp.empty()) </span><br><span class="line">		&#123;</span><br><span class="line">			raw.push_back(tmp);</span><br><span class="line">			tmp = <span class="string">""</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		++cp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 统计各单词出现的次数</span></span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; unique;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cnt;</span><br><span class="line">	unique.push_back(raw[<span class="number">0</span>]);</span><br><span class="line">	cnt.push_back(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type i = <span class="number">0</span>; i != raw.size(); ++i) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type j = <span class="number">0</span>; j != unique.size(); ++j) </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (raw[i] == unique[j]) </span><br><span class="line">			&#123;</span><br><span class="line">				++cnt[j];</span><br><span class="line">				found = <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!found) </span><br><span class="line">		&#123;</span><br><span class="line">			unique.push_back(raw[i]);</span><br><span class="line">			cnt.push_back(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出</span></span><br><span class="line">	<span class="keyword">int</span> max = cnt[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">int</span> max_index = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; i != cnt.size(); ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"单词："</span> &lt;&lt; unique[i] &lt;&lt; <span class="string">",出现次数为："</span> &lt;&lt; cnt[i] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">if</span> (max &lt; cnt[i]) </span><br><span class="line">		&#123;</span><br><span class="line">			max = cnt[i];</span><br><span class="line">			max_index = i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; endl &lt;&lt;<span class="string">"出现最多的是："</span>&lt;&lt; unique[max_index] &lt;&lt; <span class="string">",次数为："</span> &lt;&lt; cnt[max_index] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">how, now now now brown cow cow↙</span><br><span class="line">单词：how,出现次数为：<span class="number">1</span></span><br><span class="line">单词：now,出现次数为：<span class="number">3</span></span><br><span class="line">单词：brown,出现次数为：<span class="number">1</span></span><br><span class="line">单词：cow,出现次数为：<span class="number">2</span></span><br><span class="line"></span><br><span class="line">出现最多的是：now,次数为：<span class="number">3</span></span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Example">Example</h3><p>将一个数组拷贝到另一个数组</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[switch, ex6.9]]></title>
    <link href="http://bluestein.github.io/2015/12/cpp-demo-5/"/>
    <id>http://bluestein.github.io/2015/12/cpp-demo-5/</id>
    <published>2015-12-22T01:42:42.000Z</published>
    <updated>2016-03-05T02:41:48.529Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" rel="external">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Example">Example</h3><p>统计输入的一句话中元音出现的次数。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>, otherCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">switch</span> (ch)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">			++aCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">			++eCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">			++iCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">			++oCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">			++uCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			++otherCnt;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Number of vowel a/A:\t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel e/E:\t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel i/I:\t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel o/O:\t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of vowel u/U:\t"</span> &lt;&lt; uCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of other characters:\t"</span> &lt;&lt; otherCnt &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sorry! Who Are You Again?↙</span><br><span class="line">^Z↙</span><br><span class="line">Number of vowel a/A:    <span class="number">3</span></span><br><span class="line">Number of vowel e/E:    <span class="number">1</span></span><br><span class="line">Number of vowel i/I:    <span class="number">1</span></span><br><span class="line">Number of vowel o/O:    <span class="number">3</span></span><br><span class="line">Number of vowel u/U:    <span class="number">1</span></span><br><span class="line">Number of other characters:     <span class="number">12</span></span><br></pre></td></tr></table></figure>
<h3 id="Exercise_6-9">Exercise 6.9</h3><p>统计下列字符序列出现的次数：ff、fl以及fi。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> pre_ch = <span class="string">'\0'</span>, cur_ch;</span><br><span class="line">	<span class="keyword">int</span> ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>, otherCnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> ((cur_ch = getchar()) != EOF)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (pre_ch == <span class="string">'f'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">switch</span> (cur_ch)</span><br><span class="line">			&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">				++ffCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">				++flCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">				++fiCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				++otherCnt;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pre_ch = cur_ch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"Number of ff:\t"</span> &lt;&lt; ffCnt &lt;&lt;<span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of fl:\t"</span> &lt;&lt; flCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of fi:\t"</span> &lt;&lt; fiCnt &lt;&lt; <span class="string">"\n"</span></span><br><span class="line">		&lt;&lt; <span class="string">"Number of other:\t"</span> &lt;&lt; otherCnt &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>outputs</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flfmffi↙</span><br><span class="line">^Z↙</span><br><span class="line">Number of ff:   <span class="number">1</span></span><br><span class="line">Number of fl:   <span class="number">1</span></span><br><span class="line">Number of fi:   <span class="number">1</span></span><br><span class="line">Number of other:        <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>END.</p>
<hr>
<p>Github Pages同步更新: <a href="http://bluestein.github.io/">Humooo’s Blog</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名 | <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">Creative Commons BY-NC-ND 4.0</a></p>
</blockquote>
<h3 id="Example">Example</h3><p>统计输入的一句话中元音出现的次数。</p>]]>
    
    </summary>
    
      <category term="Cpp" scheme="http://bluestein.github.io/tags/Cpp/"/>
    
      <category term="Code" scheme="http://bluestein.github.io/categories/Code/"/>
    
      <category term="Cpp" scheme="http://bluestein.github.io/categories/Code/Cpp/"/>
    
  </entry>
  
</feed>
