<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>11:指针 | Liu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="指针跟迭代器类似，也可以对指针进行 解引用（*） 和 自增（++） 操作，其含义和迭代器类似。
指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：">
<meta property="og:type" content="article">
<meta property="og:title" content="11:指针">
<meta property="og:url" content="http://bluestein.github.io/2015/11/cpp-primer4-11/index.html">
<meta property="og:site_name" content="Liu">
<meta property="og:description" content="指针跟迭代器类似，也可以对指针进行 解引用（*） 和 自增（++） 操作，其含义和迭代器类似。
指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：">
<meta property="og:updated_time" content="2015-11-28T09:23:05.461Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="11:指针">
<meta name="twitter:description" content="指针跟迭代器类似，也可以对指针进行 解引用（*） 和 自增（++） 操作，其含义和迭代器类似。
指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：">
  
    <link rel="alternative" href="/atom.xml" title="Liu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Inconsolata:400,700|Open+Sans:700,400" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <div id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <div id="header-title">
        <h1 id="logo-wrap">
          <a href="/" id="logo">Liu
          
              <span id="subtitle">Writing Something</span>
          
          </a>
        </h1>
      </div>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://bluestein.github.io"></form>
      </div>
    </div>
  </div>
</div>
      <div class="outer">
        <section id="main"><article id="post-cpp-primer4-11" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/cpp-primer4-11/" class="article-date">
  <time datetime="2015-11-21T08:49:49.000Z" itemprop="datePublished">2015-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-primer/">C++ primer</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      11:指针
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>指针跟迭代器类似，也可以对指针进行 <strong>解引用</strong>（<code>*</code>） 和 <strong>自增</strong>（<code>++</code>） 操作，其含义和迭代器类似。</p>
<p>指针用于指向对象，与迭代器类似，指针提供对其所指对象的间接访问。不同在于：指针指向单个对象，而迭代器只能访问容器内的元素。具体来说，指针保存的是另一个对象的地址：</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;s;		<span class="comment">//指针 p 保存 s 的地址</span></span><br></pre></td></tr></table></figure>
<p><code>&amp;</code> 是取地址符号，该符号只能用于左值。只有变量作为左值时，才能取其地址。</p>
<h3 id="1、指针的定义和初始化">1、指针的定义和初始化</h3><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *vp;	<span class="comment">//指向 vector&lt;int&gt; 对象的指针</span></span><br><span class="line"><span class="keyword">int</span> *ip;			<span class="comment">//指向 int 对象的指针</span></span><br><span class="line"><span class="built_in">string</span> *sp; 		<span class="comment">//指向 string 对象的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>另一种风格的指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip;</span><br></pre></td></tr></table></figure>
<p>但容易引起误解，会认为 <code>int*</code> 是一种类型。但下例只有 <code>ip1</code> 是指针，<code>ip2</code> 是普通的整型变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip1, ip2;</span><br></pre></td></tr></table></figure>
<p><strong>指针的取值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = <span class="number">0</span>;		<span class="comment">//ip1 不指向任何对象</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = &amp;val;	<span class="comment">//ip2 指向val</span></span><br><span class="line"><span class="keyword">int</span> *ip3;			<span class="comment">//ip3 未初始化</span></span><br><span class="line">ip1 = ip2;			<span class="comment">//ip1 指向 val</span></span><br><span class="line">ip2 = <span class="number">0</span>;			<span class="comment">//ip2 不指向任何对象</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>避免使用未初始化的指针</p>
</blockquote>
<p><strong>初始化的约束</strong></p>
<p>对指针初始化或赋值只能使用下列四种类型的值：</p>
<ul>
<li>0常量表达式(编译时能获得0值得const对象或字面值常量0)；</li>
<li>类型匹配的对象的地址；</li>
<li>另一对象之后的下一地址；</li>
<li>同一类型的另一有效指针；</li>
</ul>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> dval = <span class="number">1.5</span>;</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> czero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">double</span> *dp;</span><br><span class="line"></span><br><span class="line">ip = ival;		<span class="comment">//error</span></span><br><span class="line">ip = zero;		<span class="comment">//error</span></span><br><span class="line">ip = czero;		<span class="comment">//ok：编译时可以获得 0</span></span><br><span class="line">ip = <span class="number">0</span>；			<span class="comment">//ok：字面值常量 0</span></span><br><span class="line">ip = &amp;ival;		<span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">dp = ip;		<span class="comment">//error：类型不匹配</span></span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">当然 <span class="number">0</span> 值还可以使用从C语言继承下来的预处理器变量 `<span class="literal">NULL</span>`，它在 cstdlib 头文件中定义，其值为 <span class="number">0</span>。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line"><span class="keyword">int</span> *ip = <span class="literal">NULL</span>;	<span class="comment">//相当于 int *ip = 0;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>NULL</code> 不是标准库中定义的，所以不需要 <code>std::</code>。</p>
</blockquote>
<p><strong>void*指针</strong></p>
<p>void* 指针可以保存任何类型对象的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;</span><br><span class="line"><span class="keyword">void</span> *vp = &amp;dval;	<span class="comment">//ok</span></span><br><span class="line">vp = dp;			<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>但 void* 指针只允许有限的操作：</p>
<ul>
<li>与另一指针比较；</li>
<li>向函数传递 void<em> 指针，或函数返回 void</em> 指针；</li>
<li>给另一个 void* 指针赋值。</li>
</ul>
<blockquote>
<p>不允许 void* 指针操作所指向的对象。</p>
</blockquote>
<h3 id="3、指针的操作">3、指针的操作</h3><hr>
<p><strong>*操作符</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string s1("hello");</span><br><span class="line">string s2("world")；</span><br><span class="line">string *sp = &amp;s1;</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">sp = &amp;s2;				//改变指针所指对象</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br><span class="line">*sp = "hello world";	//改变所指的内容</span><br><span class="line">cout &lt;&lt; *sp &lt;&lt; endl;	//解引用</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<p>对 <code>sp</code> 的解引用可以获得 <code>s</code> 的值，因为 <code>sp</code> 指向 <code>s</code>，所以给 <code>*sp</code> 赋值可以改变 <code>s</code> 的值。</p>
<p><strong>指针和引用的比较</strong></p>
<p>虽然引用（reference）和指针都可以间接访问另一个值，但有区别：</p>
<ul>
<li>定义引用时没有初始化时错误的；</li>
<li>赋值行为的差异：给引用赋值修改的是该引用所关联的对象的值，并不是与另一个对象关联；</li>
<li>引用一经初始化，就始终指向同一个特定的对象</li>
</ul>
<p>指针的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival1 = <span class="number">1024</span>, ival2 = <span class="number">2048</span>;</span><br><span class="line"><span class="keyword">int</span> *ip1 = &amp;ival1, *ip2 = &amp;ival2;</span><br><span class="line">ip1 = ip2;		<span class="comment">//ip1 此时指向 ival2</span></span><br></pre></td></tr></table></figure>
<p>而引用的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;r1 = ival1; <span class="keyword">int</span> &amp;r2 = ival2;</span><br><span class="line">r1 = r2;		<span class="comment">//将 ival2 赋给 ival1</span></span><br></pre></td></tr></table></figure>
<p>上面的修改只会修改引用所关联的对象，并不会改变改变引用本身。并且修改后，两个引用还是指向原来关联的对象。</p>
<p><strong>指向指针的指针</strong></p>
<p>指针本身也是需要占内存的对象，所以指针也可以被指针访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *ip = &amp;ival;</span><br><span class="line"><span class="keyword">int</span> **ipp = &amp;ip;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ival &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; **ipp &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="number">1024</span></span><br></pre></td></tr></table></figure>
<p>可以用三种方式输出ival的值。</p>
<p>最后举一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>, j =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p1 = &amp;i, *p2 = &amp;j;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p2 = *p1 * *p2;			<span class="comment">//改变 p2 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">*p1 *= *p1;				<span class="comment">//改变 p1 所指的内容</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; endl;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>
<h3 id="4、使用指针访问数组">4、使用指针访问数组</h3><hr>
<p>指针与数组密切相关。特别是在表达式中使用数组名时，改名字会自动转换为指向数组第一个元素的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = val;	<span class="comment">//p 指向 val[0]</span></span><br><span class="line">p = &amp;val[<span class="number">3</span>];	<span class="comment">//p 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<p><strong>指针的算术运算</strong></p>
<p>上面的 <code>p = &amp;val[3];</code> 使用下标操作，也可以通过 <strong>指针的算术操作（pointer arithmetic）</strong> 来获取指定的地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = val;			<span class="comment">//p 指向 val[0]</span></span><br><span class="line"><span class="keyword">int</span> *p2 = p + <span class="number">3</span>;	<span class="comment">//p2 指向 val[3]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针的算术操作只有在计算过后的新指针还是指向同一数组的元素才算合法，且不能越界，比如上面 <code>int *p2 = p + 3;</code> 改成 <code>int *p2 = p + 4;</code> 就会出错，因为数组 <code>val</code> 的大小为 4，最大的下标为 3。</p>
</blockquote>
<p>两个指针之间还可以做减法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ptrdiff_t</span> n = p2 - p1;	<span class="comment">//n = 3</span></span><br></pre></td></tr></table></figure>
<p><code>p1</code> 和 <code>p2</code> 之间相差3个对象，所以 <code>n = 3</code>。 <code>n</code> 是标准库类型（library type） <strong>ptrdiff_t</strong> 类型。与 size_t 类型一样，ptrdiff_t 也是一种与机器相关类型，在cstddef头文件中定义。</p>
<p>允许在指针上加减 0，使指针保持不变。</p>
<p><strong>解引用和指针算术操作之间的相互作用</strong></p>
<p>在指针上加上一个整数值，其结果仍是指针。允许在这个结果上直接进行解引用操作，而不必先把它赋给一个新的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> last = *(val + <span class="number">3</span>);	<span class="comment">//相当于 val[3]</span></span><br></pre></td></tr></table></figure>
<p>需要写括号，如果写成 <code>int last = *val + 3;</code> 则相当于 <code>val[0] + 3</code>。</p>
<p><strong>下标和指针</strong></p>
<p>使用下标访问数组时，它实际上是使用下标访问指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = val[<span class="number">0</span>]	<span class="comment">//val 指向数组 val[] 的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;val[<span class="number">2</span>];	<span class="comment">//ok: p 指向第二个元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];		<span class="comment">//ok: p[1] 相当于 *(p + 1), j = val[3]</span></span><br><span class="line"><span class="keyword">int</span> k = p[-<span class="number">2</span>];		<span class="comment">//ok: p[-2] 相当于 val[0]</span></span><br></pre></td></tr></table></figure>
<p><strong>计算数组的超出末端指针</strong></p>
<p>vector 类型提供的end操作将返回指向超出 vector 末端位置的一个迭代器。类似的，可以计算数组的超出末端指针的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="keyword">int</span> *p2 = p + arr_size;	<span class="comment">//ok:超出末端的指针</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>C++允许计算数组或对象的超出末端的地址，但不允许对此地址进行解引用操作。而计算数组超出末端之后或数组首地址之前的地址都是不合法的。</p>
</blockquote>
<p><code>p2</code> 不能解引用操作，但能与其他指针比较，或者用作指针算术表达式的操作数。</p>
<p><strong>输出数组元素</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> arr_size = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[arr_size] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> *begin = arr, *end = arr + arr_size; begin != end; ++begin)&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *begin &lt;&lt; <span class="string">","</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>指针是数组的迭代器。上面的程序与迭代器程序非常相似，事实上，内置类型具有标准库容器的许多性质，指针就是数组的迭代器。</p>
</blockquote>
<h3 id="5、指针与const限定符">5、指针与const限定符</h3><hr>
<p>两种类型：</p>
<ul>
<li>指向const对象的指针；</li>
<li>const指针；</li>
</ul>
<p><strong>指向const对象的指针</strong></p>
<p>如果指针指向的是const对象，则不再能够使用指针来修改对象的内容。为了保证这个特性，C++语言强制要求指向const对象的指针也必须具有const特性：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp;</span><br></pre></td></tr></table></figure>
<p><code>cdp</code> 是指向一个double类型const对象的指针，const限定了 <code>cdp</code> 指针所指向的对象，而并非 <code>cdp</code> 本身。即 <code>cdp</code> 不是const类型，在定义时不一定需要给它初始化；如果有需要的话，允许给 <code>cdp</code> 重新赋值，使其指向另一个const对象，但不能通过 <code>cdp</code> 修改所指对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*cdp = <span class="number">2</span>;	<span class="comment">//error: *cdp might be const</span></span><br></pre></td></tr></table></figure>
<p>把一个const对象的地址赋给一个普通的、非const对象的指针也会导致编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *dp = &amp;pi;			<span class="comment">//error: dp is a plain pointer</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;pi;	<span class="comment">//ok: cdp is a pointer to const</span></span><br></pre></td></tr></table></figure>
<p><strong>不能使用 void* 指针保存const对象的地址</strong>，而必须使用const void*指针保存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span> *cvp = &amp;val;		<span class="comment">//ok: cvp is const</span></span><br><span class="line"><span class="keyword">void</span> *vp = &amp;val;			<span class="comment">//error: val is const</span></span><br></pre></td></tr></table></figure>
<p>允许将非const对象赋给指向const对象的指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br></pre></td></tr></table></figure>
<p>尽管 dval 不是 const 对象，但任何企图通过指针 <code>cdp</code> 修改其值得行为都会导致错误。</p>
<p>事实上，也有办法通过指向const对象指针改变所指的非const对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cdp = &amp;dval;	<span class="comment">//ok: 但是不能通过指针 cdp 改变 dval 的值</span></span><br><span class="line">*cdp = <span class="number">3.14159</span>;				<span class="comment">//error: 不能通过 cdp 改变所指对象的值</span></span><br><span class="line"><span class="keyword">double</span> *dp = &amp;dval;			<span class="comment">//ok：dp 可以指向非const对象</span></span><br><span class="line">*dp = <span class="number">3.14159</span>;				<span class="comment">//ok</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *cdp &lt;&lt; endl;		<span class="comment">//此时会输出：3.14159</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以这样理解指向const对象的指针：自以为指向const对象的指针。但并不能保证所指向的对象一定是const对象。</p>
</blockquote>
<p><strong>const指针</strong></p>
<p>这种指针本身不能修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> icp = &amp;ival;	<span class="comment">//icp 是const指针</span></span><br></pre></td></tr></table></figure>
<p>这样理解：<code>icp</code> 是指向int对象的const的指针。跟其他const对象类似，const指针的值不能修改，意思就是不能使 <code>icp</code> 指向其他对象。任何企图给const指针赋值的行为都会出错（即使是赋它本身的值也一样）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">icp = icp;	<span class="comment">//error: icp is const</span></span><br></pre></td></tr></table></figure>
<p>并且 <strong>const指针在定义时必须初始化</strong>。</p>
<p>const指针所指对象的值能否被该指针修改完全取决于该对象的类型，例如 <code>icp</code> 指向一个普通的非 const int 型的对象，则可以使用 <code>icp</code> 修改该对象的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*icp = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>指向const对象的const指针</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> cdcp = &amp;pi;</span><br></pre></td></tr></table></figure>
<p>上面的意思是既不能修改 <code>pi</code> 的值，也不能修改 <code>cdcp</code> 所指的对象。</p>
<p><strong>指针和typedef</strong></p>
<p>在typedef中使用指针往往会带来意外的结果，下面是一个几乎所有初学者都会搞错的问题：请问 <code>cstr</code> 变量是什么类型？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="keyword">const</span> sp cstr;</span><br></pre></td></tr></table></figure>
<p>简单的回答是：const sp 类型的指针。进一步：const sp 所表示的真实类型是什么？可能会认为是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *cstr;	<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
<p>但这是错误的，原因是：声明const sp时，const修饰的是 sp 类型，而 sp 是一个指针。所以等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解const声明：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//s1 和 s2 都是const</span></span><br><span class="line"><span class="built_in">string</span> <span class="keyword">const</span> s1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> s2;</span><br></pre></td></tr></table></figure>
<p>用typedef写const类型定义时，const限定符加在类型前面容易引起误解</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span> *sp;</span><br><span class="line"><span class="comment">//下面三种定义时等价的</span></span><br><span class="line"><span class="keyword">const</span> sp cstr1 = &amp;s;	<span class="comment">//容易误解</span></span><br><span class="line">sp <span class="keyword">const</span> cstr2 = &amp;s;</span><br><span class="line"><span class="built_in">string</span> *<span class="keyword">const</span> cstr3 = &amp;s;</span><br></pre></td></tr></table></figure>
<hr>
<p>举例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic = i;				<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pic = &amp;ic; 			<span class="comment">//ok</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> cpi = &amp;ic;			<span class="comment">//error</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> cpic = &amp;ic;	<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>
<p>END.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://bluestein.github.io/2015/11/cpp-primer4-11/" data-id="cihix2apt0020jcfo6yw4eltg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-primer/">C++ primer</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/11/cpp-primer4-12/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          12:C风格字符串
        
      </div>
    </a>
  
  
    <a href="/2015/11/cpp-primer4-10/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">10:数组</div>
    </a>
  
</nav>

  
</article>

</section>
        
          
            <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-primer/">C++ primer</a><span class="category-list-count">18</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget recents">
      <ul>
        
          <li>
            <a href="/2015/11/cpp-primer4-18/">18:类型转换</a>
          </li>
        
          <li>
            <a href="/2015/11/cpp-primer4-17/">17:new &amp; delete</a>
          </li>
        
          <li>
            <a href="/2015/11/cpp-primer4-16/">16:赋值操作和自增自减</a>
          </li>
        
          <li>
            <a href="/2015/11/cpp-primer4-15/">15:赋值操作和自增自减</a>
          </li>
        
          <li>
            <a href="/2015/11/cpp-primer4-14/">14:位操作符</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 10px;">C++</a> <a href="/tags/C-primer/" style="font-size: 10px;">C++ primer</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a><span class="archive-list-count">18</span></li></ul>
    </div>
  </div>

  
</aside>
          
        
      </div>
      <div id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/4.0/88x31.png" /></a></br>
      &copy; 2015 Bluestein/Humooo(humooo@outlook.com)<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</div>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>